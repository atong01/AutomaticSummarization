{{Redirect|Bash (software)|other software|Bash (disambiguation)}}
{{Use mdy dates|date=March 2014}}
{{Infobox software
| name                   = Bash
| logo                   = 
| screenshot             = [[Image:Bash screenshot.png|250px]]
| caption                = Screenshot of a Bash session
| author                 = [[Brian Fox (computer programmer)|Brian Fox]]
| released               = {{start date and age|1989|6|7}}
| latest release version = 4.3.42
| latest release date    = {{Start date and age|2015|08|13}}<ref>{{cite web | url = https://ftp.gnu.org/gnu/bash/bash-4.3-patches/ | title = Bash-4.3 patch list | accessdate = May 19, 2015 | date = May 19, 2015}}</ref>
| programming language   = [[C (programming language)|C]]
| operating system       = [[Cross-platform]]
| platform               = [[GNU]]
| language               = English, multilingual ([[gettext]])
| status                 = 
| genre                  = [[Unix shell]], [[command language]]
| source model           = [[Free software]]
| license                = [[GNU GPL#Version 3|GNU GPL v3]]+<ref name="license">{{cite web | author = GNU Project | authorlink = GNU Project | title = README file | url = https://www.gnu.org/software/bash/ | quote = Bash is free software, distributed under the terms of the [GNU] General Public License as published by the Free Software Foundation, version 3 of the License (or any later version).}}</ref>
| website                = {{URL|https://www.gnu.org/software/bash/}}
}}

'''Bash''' is a [[Unix shell]] and [[command language]] written by [[Brian Fox (computer programmer)|Brian Fox]] for the [[GNU Project]] as a [[free software]] replacement for the [[Bourne shell]].<ref name="GNUBSD">
{{Cite newsgroup
  | title = GNU + BSD = ?
  | author = [[Richard Stallman]] (forwarded with comments by Chet Ramey)
  | date = February 10, 1988
  | newsgroup = comp.unix.questions
  |message-id=2362@mandrill.CWRU.Edu
  | url=https://groups.google.com/forum/#!original/comp.unix.questions/iNjWwkyroR8/yedr9yDWSuQJ
  | accessdate = March 22, 2011
  | quote = For a year and a half, the GNU shell was "just about done".  The author made repeated promises to deliver what he had done, and never kept them.  Finally I could no longer believe he would ever deliver anything.  So Foundation staff member Brian Fox is now implementing an imitation of the Bourne shell.
}}
</ref><ref>
{{Citation
  | last = Hamilton
  | first = Naomi
  | title = The A-Z of Programming Languages: BASH/Bourne-Again Shell
  | journal = Computerworld
  | page = 2
  | date = May 30, 2008
  | accessdate = March 21, 2011
  | url = http://www.computerworld.com.au/article/222764/a-z_programming_languages_bash_bourne-again_shell/?pp=2&fp=16&fpid=1
  | quote = When Richard Stallman decided to create a full replacement for the then-encumbered Unix systems, he knew that he would eventually have to have replacements for all of the common utilities, especially the standard shell, and those replacements would have to have acceptable licensing.
}}
</ref>  Released in 1989,<ref name=BashBeta>
{{Cite newsgroup
  | title = Bash is in beta release!
  | author = Brian Fox (forwarded by Leonard H. Tower Jr.)
  | date = June 8, 1989
  | newsgroup = gnu.announce
  | url = http://groups.google.com/group/gnu.announce/msg/a509f48ffb298c35?hl=en
  | accessdate = October 28, 2010
}}
</ref> it has been distributed widely as the shell for the [[GNU operating system]] and as a default shell on [[Linux]] and {{nowrap|[[OS X]]}}.  It has been ported to [[Microsoft Windows]] and distributed with [[Cygwin]] and [[MinGW]], to [[DOS]] by the [[DJGPP]] project, to [[Novell NetWare]] and to [[Android (operating system)|Android]] via various terminal emulation applications. In the late 1990s, Bash was a minor player among multiple commonly used shells; at present Bash has overwhelming favor.

Bash is a [[Command-line interpreter|command processor]] that typically runs in a text window, where the user types commands that cause actions. Bash can also read commands from a file, called a  [[Shell script|script]].  Like all Unix shells, it supports  filename [[glob (programming)|globbing]] (wildcard matching), [[Pipeline (Unix)|piping]], [[here document]]s, [[command substitution]], [[Variable (programming)|variables]] and [[control flow|control structures]] for [[Conditional (programming)|condition-testing]] and [[iteration]]. The [[Keyword (computer programming)|keywords]], [[Syntax (programming languages)|syntax]] and other basic features of the [[Language (computer science)|language]] were all copied from [[Thompson shell|sh]].  Other features, e.g., [[C shell#History|history]], were copied from [[C shell|csh]] and [[Korn shell|ksh]].  Bash is a [[POSIX]] shell, but with a number of extensions.

The name itself is an [[acronym]], a [[pun]], and a description.  As an acronym, it stands for ''Bourne-again shell'', referring to its objective as a free replacement for the Bourne shell.<ref>[http://www.ddj.com/cpp/184404693 C Programming] by Al Stevens, [[Dr. Dobb's Journal]], July 1, 2001</ref>
As a pun, it expressed that objective in a phrase that sounds similar to ''[[Born again (Christianity)|born again]]'', a term for spiritual rebirth.<ref>
{{cite web
  | author = [[Richard Stallman]]
  | title = About the GNU Project
  | publisher = [[Free Software Foundation]]
  | date = November 12, 2010
  | url = https://www.gnu.org/gnu/thegnuproject.html
  | quote = "Bourne Again Shell" is a play on the name ''Bourne Shell'', which was the usual shell on Unix.
  | accessdate = March 13, 2011
| archiveurl= https://web.archive.org/web/20110424064815/http://www.gnu.org/gnu/thegnuproject.html| archivedate=April 24, 2011 <!--DASHBot-->| deadurl= no}}
</ref><ref>
{{Citation
  | last = Gattol
  | first = Markus
  | title = Bourne-again Shell
  | date = March 13, 2011
  | url = http://www.markus-gattol.name/ws/bash.html
  | quote = The name is a pun on the name of the Bourne shell (sh), an early and important Unix shell written by Stephen Bourne and distributed with Version 7 Unix circa 1978, and the concept of being "born again".
  | accessdate = March 13, 2011
}}
</ref> The name is also descriptive of what it did, ''bashing together'' the features of sh, csh, and ksh.<ref>
{{Cite newsgroup
  | title = at&t-free ksh (was: job control is a bug, not a feature)
  | author = Ian Darwin
  | date = June 13, 1989
  | newsgroup = comp.os.minix
  |message-id=
  | url = http://groups.google.com/group/comp.os.minix/msg/63c036d82ceca4d6?hl=en
  | accessdate = March 21, 2011
  | quote = Yup, the gnu project's Born Again Shell ("bash") is an attempt at bashing all the features of sh together with many of those from both csh and ksh.
}}
</ref>

A [[security bug|security hole]] in Bash dating from version 1.03 (August 1989),<ref name="Seclists-20141004">{{cite web |last=Chazelas |first=Stephane |title=oss-sec mailing list archives |url=http://seclists.org/oss-sec/2014/q4/102 |date=4 October 2014 |work=Seclists.org |accessdate=4 October 2014}}</ref> dubbed [[Shellshock (software bug)|Shellshock]], was discovered in early September 2014.<ref name="TR-20140924">{{cite web |last=Leyden |first=John |title=Patch Bash NOW: 'Shell Shock' bug blasts OS X, Linux systems wide open |url=http://www.theregister.co.uk/2014/09/24/bash_shell_vuln/ |work=[[The Register]] |date=September 24, 2014 |accessdate=September 25, 2014}}</ref><ref name="NYT-20140925-NP">{{cite news |last=Perlroth |first=Nicole |title=Security Experts Expect ‘Shellshock’ Software Bug in Bash to Be Significant |url=http://www.nytimes.com/2014/09/26/technology/security-experts-expect-shellshock-software-bug-to-be-significant.html |date=September 25, 2014 |work=[[New York Times]] |accessdate=September 25, 2014 }}</ref>

== History ==
[[Brian Fox (computer programmer)|Brian Fox]] began [[Computer programming|coding]] Bash on January 10, 1988<ref>
{{Citation
  | author = Brian Fox
  | title = shell.c
  | place =
  | publisher = [[Free Software Foundation]]
  | date = August 29, 1996
  | url = http://ftp.gnu.org/gnu/bash/bash-1.14.7.tar.gz
  | quote = Birthdate:  Sunday, January 10th, 1988.  Initial author:  Brian Fox
 }}
</ref> after [[Richard Stallman]] became dissatisfied with the lack of progress being made by a prior developer.<ref name=GNUBSD/>  Stallman and the [[Free Software Foundation]] (FSF) considered a free shell that could run existing shell scripts so strategic to a completely free system built from BSD and GNU code that this was one of the few projects they funded themselves, with Fox undertaking the work as an employee of FSF.<ref name=GNUBSD/><ref>
{{cite web
  | author = [[Richard Stallman]]
  | title = About the GNU Project
  | publisher = [[Free Software Foundation]]
  | date =  October 3, 2010
  | url = https://www.gnu.org/gnu/thegnuproject.html
  | accessdate = March 21, 2011
  | quote = Free Software Foundation employees have written and maintained a number of GNU software packages. Two notable ones are the C library and the shell. ...  We funded development of these programs because the GNU Project was not just about tools or a development environment. Our goal was a complete operating system, and these programs were needed for that goal.
| archiveurl= https://web.archive.org/web/20110424064815/http://www.gnu.org/gnu/thegnuproject.html| archivedate=April 24, 2011 <!--DASHBot-->| deadurl= no}}
</ref> Fox released Bash as a beta, version .99, on June 7, 1989<ref name=BashBeta/> and remained the primary maintainer until sometime between mid-1992<ref>
{{Cite newsgroup
  | title = January 1993 GNU's Bulletin
  | author = len (g...@prep.ai.mit.edu)
  | date = April 20, 1993
  | newsgroup = gnu.announce
  |message-id= gnusenet930421bulletin@prep.ai.mit.edu
  | url = http://groups.google.com/group/gnu.misc.discuss/msg/4f42c739cd7e8bd8
  | accessdate = October 28, 2010
}}
</ref> and mid-1994,<ref name="Bourne shell grammar">{{cite web|first=Chet|last=Ramey|title=Bash - the GNU shell (Reflections and Lessons Learned)|url=http://www.linuxjournal.com/article/2800#N0xa50890.0xb46380|accessdate=November 13, 2008| date=August 1, 1994|work=[[Linux Journal]]| archiveurl= http://web.archive.org/web/20081205082152/http://www.linuxjournal.com/article/2800| archivedate=December 5, 2008 <!--DASHBot-->| deadurl= no}}</ref> when he was laid off from FSF<ref>
{{Citation
  | title = Dates in your Computerworld interview
  | author = Chet Ramey
  | date = October 31, 2010
  | url = http://www.scribd.com/doc/40556434/2010-10-31-Chet-Ramey-Early-Bash-Dates
  | accessdate = October 31, 2010
}}
</ref> and his responsibility was transitioned to another early contributor, Chet Ramey.<ref>
{{Cite newsgroup
  | title = Bash 0.99 fixes & improvements
  | author = Chet Ramey
  | date = June 12, 1989
  | newsgroup = gnu.bash.bug
  |message-id=
  | url = http://groups.google.com/group/gnu.bash.bug/msg/1fc7b688f5d44438?hl=en
  | accessdate = November 1, 2010
}}
</ref><ref>
{{Cite newsgroup
  | title = Some bash-1.02 fixes
  | author = Chet Ramey
  | date = July 24, 1989
  | newsgroup = gnu.bash.bug
  |message-id=
  | url = http://groups.google.com/group/gnu.bash.bug/msg/072a03645663caea?hl=en
  | accessdate = October 30, 2010
}}
</ref><ref>
{{Cite newsgroup
| title = Availability of bash 1.05
| author = Brian Fox
| date = March 2, 1990
| newsgroup = gnu.bash.bug
|message-id=
| url = http://groups.google.com/group/gnu.bash.bug/msg/e6112ccc8866e2f4?hl=en
| accessdate = October 30, 2010
}}
</ref>

In September 2014, Stéphane Chazelas, a Unix/Linux, network and telecom specialist working in the UK,<ref>https://www.linkedin.com/pub/st%C3%A9phane-chazelas/7/2a2/834</ref> discovered a [[security bug]] in the program. The bug, first disclosed on September 24, was named [[Shellshock (software bug)|Shellshock]] and assigned the numbers [http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 CVE-2014-6271], CVE-2014-6277<ref>https://cve.mitre.org/cgi-bin/cvename.cgi?name=2014-6277</ref> and [http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-7169 CVE-2014-7169]. The bug was regarded as severe, since [[Common Gateway Interface|CGI]] scripts using Bash could be vulnerable, enabling [[arbitrary code execution]].  The bug is related to how Bash passes function definitions to subshells through [[environment variable]]s.<ref>{{Cite web
| author =  Huzaifa Sidhpurwala
| title = Bash specially-crafted environment variables code injection attack
| publisher = [[Redhat]]
| url = https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/
| date = 2014-09-24
}}</ref>

==Features==
{{Expand section|with=Bash ${PIPESTATUS[*]}[http://www.cyberciti.biz/faq/unix-linux-bash-find-out-the-exit-codes-of-all-piped-commands/][http://unix.stackexchange.com/questions/14270/get-exit-status-of-process-thats-piped-to-another]|date=August 2015}}
The Bash [[command (computing)|command]] syntax is a [[superset]] of the Bourne shell command syntax. Bash can execute the vast majority of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc.  Bash command syntax includes ideas drawn from the [[Korn shell]] (ksh) and the [[C shell]] (csh) such as command line editing, [[command history]], the directory stack, the <code>$RANDOM</code> and <code>$PPID</code> variables, and POSIX [[command substitution]] syntax <code>$(…)</code>.

When a user presses the [[tab key]] within an interactive command-shell, Bash automatically uses [[command line completion]] to match partly typed program names, filenames and variable names.  The Bash command-line completion system is very flexible and customizable, and is often packaged with functions that complete arguments and filenames for specific programs and tasks.

Bash's syntax has many extensions lacking in the Bourne shell. Bash can perform integer calculations ("arithmetic evaluation") without spawning external processes. It uses the <code>((…))</code> command and the <code>$((…))</code> variable syntax for this purpose. Its syntax simplifies [[redirection (computing)|I/O redirection]]. For example, it can redirect [[standard out]]put (stdout) and [[Standard error stream|standard error]] (stderr) at the same time using the <code>&></code> operator. This is simpler to type than the Bourne shell equivalent '<code>command > file 2>&1</code>'.  Bash supports [[process substitution]] using the <code><(command)</code> and <code>>(command)</code>syntax, which substitutes the output of (or input to) a command where a filename is normally used.  (This is implemented through ''/proc/fd/'' unnamed pipes on systems which support that, or via temporary [[named pipe]]s where necessary).

When using the 'function' keyword, Bash function declarations are not compatible with Bourne/Korn/POSIX scripts (the Korn shell has the same problem when using 'function'), but Bash accepts the same function declaration syntax as the Bourne and Korn shells, and is POSIX-conformant. Because of these and other differences, Bash shell scripts are rarely runnable under the Bourne or Korn shell interpreters unless deliberately written with that compatibility in mind, which is becoming less common as Linux becomes more widespread.  But in POSIX mode,<ref name="GNUBASHREF">
{{Citation
  | title = The GNU Bash Reference Manual, for Bash, Version 4.1
  | place =
  | publisher =
  | origyear =
  | date = December 23, 2009
  | volume =
  | edition =
  | chapter = 6.11 Bash POSIX Mode
  | chapterurl = https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
  | accessdate = October 26, 2010

  | url = https://www.gnu.org/software/bash/manual/html_node/index.html
| archiveurl= https://web.archive.org/web/20101203065400/http://www.gnu.org/software/bash/manual/html_node/index.html| archivedate= December 3, 2010 <!--DASHBot-->| deadurl= no}}
</ref> Bash conformance with POSIX is nearly perfect.{{Citation needed|date=March 2014}}

Bash supports [[here document]]s. Since version 2.05b Bash can redirect [[Stdin|standard input]] (stdin) from a "here string" using the <code><<<</code> operator.

Bash 3.0 supports in-process [[regular expression]] matching using a syntax reminiscent of [[Perl]].<ref>The syntax matches that shown on the <code>[http://www.tin.org/bin/man.cgi?section=7&topic=regex regex(7)]</code> [[man page]].</ref>

Bash 4.0 introduced support for associative arrays.<ref name=GNUBASHREF/><ref>"The shell provides associative array variables, with the appropriate support to create, delete, assign values to, and expand them." http://tiswww.case.edu/php/chet/bash/NEWS</ref> Associative arrays allow a fake support for multi-dimensional (indexed) arrays, in a similar way to [[AWK]]:

<source lang="bash">
declare -A a         # declare an associative array 'a' faking a bi-dimensional indexed array
i=1; j=2             # initialize some indices
a[$i,$j]=5           # associate value "5" to key "$i,$j" (i.e. "1,2")
echo ${a[$i,$j]}     # print the stored value at key "$i,$j"
</source>

===Brace expansion===

Brace expansion, also called alternation, is a feature copied from the [[C shell]]. It generates a set of alternative combinations. Generated results need not exist as files. The results of each expanded string are not sorted and left to right order is preserved:

<source lang="bash">
echo a{p,c,d,b}e # ape ace ade abe
echo {a,b,c}{d,e,f} # ad ae af bd be bf cd ce cf
</source>
Users should not use brace expansions in portable shell scripts, because the Bourne shell does not produce the same output.

<source lang="bash">
#!/bin/sh

# A traditional shell does not produce the same output
echo a{p,c,d,b}e # a{p,c,d,b}e
</source>

When brace expansion is combined with wildcards, the braces are expanded first, and then the resulting wildcards are substituted normally.  Hence, a listing of JPEG and PNG images in the current directory could be obtained using:

<source lang="bash">
ls *.{jpg,jpeg,png}    # expands to *.jpg *.jpeg *.png - after which,
                       # the wildcards are processed
echo *.{png,jp{e,}g}   # echo just show the expansions -
                       # and braces in braces are possible.
</source>

In addition to alternation, brace expansion can be used for sequential ranges between two integers or characters separated by double dots. Newer versions of Bash allow a third integer to specify the increment.

<source lang="bash">
echo {1..10}        # expands to 1 2 3 4 5 6 7 8 9 10
echo file{1..4}.txt # expands to file1.txt file2.txt file3.txt file4.txt
echo {a..e}         # expands to a b c d e
echo {1..10..3}     # expands to 1 4 7 10
echo {a..j..3}      # expands to a d g j
</source>

When brace expansion is combined with variable expansion the variable expansion is performed '''after''' the brace expansion, which in some cases may necessitate the use of the built-in <code>eval</code> function thus:

<source lang="bash">
start=1; end=10
echo {$start..$end}  # fails to expand due to the evaluation order
eval echo {$start..$end} # variable expansion occurs
   # then resulting string is evaluated
</source>

===Startup scripts===
When Bash starts, it executes the commands in a variety of [[Hidden file and hidden directory#Unix and Unix-like environments|dot files]].  Though similar to Bash shell script commands, which have execute permission enabled and an [[interpreter directive]] like <code>#!/bin/bash</code>, the initialization files used by Bash require neither.

====Execution order of startup files====
<!-- A little margin for readability -->
<div style="margin: 1.5em 3em">

=====When started as an interactive login shell=====
Bash reads and executes <code>/etc/profile</code> (if it exists). (Often this file calls <code>/etc/bash.bashrc</code>.)

After reading that file, it looks for <code>~/.bash_profile</code>, <code>~/.bash_login</code>, and <code>~/.profile</code> ''in that order'', and reads and executes the first one that exists and is readable.

=====When a login shell exits=====
Bash reads and executes <code>~/.bash_logout</code> (if it exists).

=====When started as an interactive shell (but not a login shell)=====
Bash reads and executes <code>~/.bashrc</code> (if it exists). This may be inhibited by using the <code>--norc</code> option. The <code>--rcfile file</code> option forces Bash to read and execute commands from <code>file</code> instead of <code>~/.bashrc</code>.
</div>

====Comparison with the Bourne shell and csh startup sequences====

Elements of Bash were derived from the [[Bourne shell]] and [[C shell|csh]], and allow limited startup file sharing with the Bourne shell and provide some startup features familiar to users of the csh.

<!-- A little margin for readability -->
<div style="margin: 1.5em 3em">

=====Setting inheritable environment variables=====
The Bourne shell uses the <code>~/.profile</code> at login to set environment variables that subprocesses then inherit. Bash can use the <code>~/.profile</code> in a compatible way, by executing it explicitly from the Bash-specific <code>~/.bash_profile</code> or <code>~/.bash_login</code> with the line below.  Bash-specific syntax can be kept out of the <code>~/.profile</code> to keep the latter compatible with the Bourne shell.
<source lang="bash">. ~/.profile</source>

=====Aliases and Functions=====
These two facilities, [[alias (command)|aliases]] from ''csh'' and the more general functions that largely supersede them from Bourne shell, were not typically inheritable from the login shell, and had to be redefined in each subshell spawned from the login shell.  Although there is an <code>ENV</code> environment variable that could be applied to the problem, both ''csh'' and Bash support per-subshell startup files that address it directly.  In Bash, the <code>~/.bashrc</code> is called for interactive subshells.  If user-defined functions from the <code>~/.bashrc</code> are desired in the login shell as well, the <code>~/.bash_login</code> can include the line below after any setting up of environment variables:
<source lang="bash">. ~/.bashrc</source>

=====Commands performed only at login and logout=====
The ''csh'' supports a <code>~/.login</code> file for purposes of tasks performed only during initial login, such as displaying system load, disk status, whether email has come in, logging the login time, etc.  The Bourne shell can emulate this in the <code>~/.profile</code>, but doesn't predefine a file name.  To achieve similar semantics to the csh model, the <code>~/.bash_profile</code> can contain the line below, after the environment setup and function setup:
<source lang="bash">. ~/.bash_login</source> 
Likewise, the ''csh'' has a <code>~/.logout</code> file run only when the login shell exits.  The Bash equivalent is <code>~/.bash_logout</code>, and requires no special setup.  In the Bourne shell, the <code>trap</code> built-in can be used to achieve a similar effect. 
</div>

=====Legacy-compatible Bash startup example=====

The skeleton <code>~/.bash_profile</code> below is compatible with the Bourne shell and gives semantics similar to csh for the <code>~/.bashrc</code> and <code>~/.bash_login</code>.  The <code>[ -r ''filename'' ]</code> are tests to see if the ''filename'' exists and is readable, simply skipping the part after the <code>&&</code> if it's not.

<source lang="bash">
[ -r ~/.profile ] && . ~/.profile             # set up environment, once, Bourne-sh syntax only.
if [ -n "$PS1" ] ; then                       # are we interactive?
   [ -r ~/.bashrc     ] && . ~/.bashrc        # tty/prompt/function setup for interactive shells.
   [ -r ~/.bash_login ] && . ~/.bash_login    # any at-login tasks for login shell only.
fi
</source>

====Operating system issues in Bash startup====

Some versions of [[Unix]] and [[Linux]] contain Bash system startup scripts, generally under the <code>/etc</code> directories. Bash calls these as part of its standard initialization, but other startup files can read them in a different order than the documented Bash startup sequence.  The default content of the root user's files may also have issues, as well as the skeleton files the system provides to new user accounts upon setup.  The startup scripts that launch the [[X window system]] may also do surprising things with the user's Bash startup scripts in an attempt to set up user-environment variables before launching the [[window manager]]. These issues can often be addressed using a <code>~/.xsession</code> or <code>~/.xprofile</code> file to read the <code>~/.profile</code> — which provides the environment variables which Bash shell windows spawned from the window manager need, such as [[xterm]] or [[Gnome Terminal]].

===Portability===
Invoking Bash with the <code>--posix</code> option or stating <code>set -o posix</code> in a script causes Bash to conform very closely to the [[Posix#POSIX.2|POSIX 1003.2 standard]].<ref name=tldp />
Bash shell scripts intended for [[portability (computer science)|portability]] should at least take into account the Bourne shell it intends to replace.  
Bash has certain features that the traditional Bourne shell lacks. The include:<ref name=tldp>{{cite web|author=Mendel Cooper|title=Portability Issues|url=http://tldp.org/LDP/abs/html/portabilityissues.html|work=The Linux Documentation Project|publisher=ibiblio.org}}</ref>
* Certain extended invocation options
* Command substitution using $( ) notation (this feature is part of the POSIX 1003.2 standard though)
* Brace expansion
* Certain array operations, and associative arrays
* The double brackets extended test construct
* The double-parentheses arithmetic-evaluation construct
* Certain string-manipulation operations
* Process substitution
* A Regular Expression matching operator
* Bash-specific builtins
* [[Coprocess]]es

===Keyboard shortcuts===
The following shortcuts work when using default ([[Emacs]]) key bindings. [[Vi-binding]]s can be enabled by running <code>set -o vi</code>.<ref>{{cite web|url=http://www.hypexr.org/bash_tutorial.php#emacs |title=BASH Help - A Bash Tutorial |publisher=Hypexr.org |date=October 5, 2012 |accessdate=July 21, 2013}}</ref>

Note: For shortcuts involving {{key press|Alt}}, you may be able to use {{key press|Esc}} instead.

Note: Sometimes, you must use {{key press|Esc}} instead of {{key press|Alt}}, because the {{key press|Alt}} shortcut conflicts with another shortcut. For example, in [[Trisquel|Trisquel 5.0]] (a distribution of Linux), pressing {{key press|Alt|f}} does not move the cursor forward one word, but activates "File" in the menu of the terminal window.

{{See also|Readline}}

* {{key press|TAB}} : [[Autocomplete]]s from the cursor position.
* {{key press|Ctrl|a}} : Moves the cursor to the line start (equivalent to the key {{key press|[[home key|Home]]}}).
* {{key press|Ctrl|b}} : Moves the cursor back one character (equivalent to the key {{key press|[[arrow keys|Left]]}}).
* {{key press|Ctrl|c}} : Sends the signal [[SIGINT (POSIX)|SIGINT]] to the current task, which aborts and closes it.
* {{key press|Ctrl|d}}
** Sends an EOF marker, which (unless disabled by an option) closes the current shell (equivalent to the command <code>[[exit (command)|exit]]</code>). (Only if there is no text on the current line)
** If there is text on the current line, deletes the current character (then equivalent to the key {{key press|[[Delete key|Delete]]}}).
* {{key press|Ctrl|e}} : ([[wikt:end|end]]) moves the cursor to the line end (equivalent to the key {{key press|[[end key|End]]}}).
* {{key press|Ctrl|f}} : Moves the cursor forward one character (equivalent to the key {{key press|[[arrow keys|Right]]}}).
* {{key press|Ctrl|g}} : Abort the research and restore the original line.
* {{key press|Ctrl|h}} : Deletes the previous character (same as backspace).
* {{key press|Ctrl|i}} : Equivalent to the tab key.
* {{key press|Ctrl|j}} : Equivalent to the enter key.
* {{key press|Ctrl|k}} : Clears the line content after the cursor and copies it into the [[clipboard (software)|clipboard]].
* {{key press|Ctrl|l}} : Clears the screen content (equivalent to the command <code>[[clear (Unix)|clear]]</code>).
* {{key press|Ctrl|n}} : ([[wikt:next|next]]) recalls the next command (equivalent to the key {{key press|[[arrow keys|Down]]}}).
* {{key press|Ctrl|o}} : Executes the found command from history, and fetch the next line relative to the current line from the history for editing.
* {{key press|Ctrl|p}} : ([[wikt:previous|previous]]) recalls the prior command (equivalent to the key {{key press|[[arrow keys|Up]]}}).
* {{key press|Ctrl|r}} : (reverse search) recalls the last command including the specified character(s). A second {{key press|Ctrl|r}} recalls the next anterior command that corresponds to the search
* {{key press|Ctrl|s}} : Go back to the next more recent command of the research (beware to not execute it from a terminal because this command also launches its XOFF). If you changed that XOFF setting, use {{key press|Ctrl|q}} to return.
* {{key press|Ctrl|t}} : Transpose the previous two characters.
* {{key press|Ctrl|u}} : Clears the line content before the cursor and copies it into the [[clipboard (software)|clipboard]].
* {{key press|Ctrl|v}} : If the next input is also a control sequence, type it literally (e. g. * {{key press|Ctrl|v}} {{key press|Ctrl|h}} types "^H", a literal backspace.)
* {{key press|Ctrl|w}} : Clears the word before the cursor and copies it into the [[clipboard (software)|clipboard]].
* {{key press|Ctrl|x}} {{key press|Ctrl|e}} : Edits the current line in the $EDITOR program, or [[vi]] if undefined.
* {{key press|Ctrl|x}} {{key press|Ctrl|r}} : Read in the contents of the inputrc file, and incorporate any bindings or variable assignments found there.
* {{key press|Ctrl|x}} {{key press|Ctrl|u}} : Incremental undo, separately remembered for each line.
* {{key press|Ctrl|x}} {{key press|Ctrl|v}} : Display version information about the current instance of Bash.
* {{key press|Ctrl|x}} {{key press|Ctrl|x}} : Alternates the cursor with its old position. (C-x, because x has a crossing shape).
* {{key press|Ctrl|y}} : ([[wikt:yank|yank]]) adds the [[clipboard (software)|clipboard]] content from the cursor position.
* {{key press|Ctrl|z}} : Sends the signal [[SIGTSTP]] to the current task, which suspends it. To execute it in background one can enter <code>bg</code>. To bring it back from background or suspension <code>fg ['process name or job id']</code> ([[foreground process|foreground]]) can be issued.
* {{key press|Ctrl|_}} : Incremental undo, separately remembered for each line.
* {{key press|Alt|b}} : ([[wikt:backward|backward]]) moves the cursor backward one word.
* {{key press|Alt|c}} : Capitalizes the character under the cursor and moves to the end of the word.
* {{key press|Alt|d}} : Cuts the word after the cursor.
* {{key press|Alt|f}} : ([[wikt:forward|forward]]) moves the cursor forward one word.
* {{key press|Alt|l}} : Lowers the case of every character from the cursor's position to the end of the current word.
* {{key press|Alt|r}} : Cancels the changes and puts back the line as it was in the history.
* {{key press|Alt|u}} : Capitalizes every character from the cursor's position to the end of the current word.
* {{key press|Alt|.}} : Insert the last argument to the previous command (the last word of the previous history entry).

=== Process management ===
The Bash shell has two modes of execution for commands: [[batch (Unix)]], and concurrent mode.

To execute commands in batch (i.e., in sequence) they must be separated by the character ";":
<source lang="bash">
command1; command2
</source>
in this example, when command1 is finished, command2 is executed.

To have a concurrent execution of command1 and command2, they must be executed in the Bash shell in the following way:
<source lang="bash">
command1 & command2
</source>
In this case command1 is executed in background (symbol &), returning immediately the control to the shell that executes command2.

Summarizing:
* Normally a command is executed in foreground (<code>fg</code>). The control of the shell returns to the user after the command finishes its execution and the special variable <code>$!</code> is set to the process ID of the newly spawned background job.
* With the symbol & after the command, it can be executed in background (<code>bg</code>). The shell is ready to execute other commands, concurrently to the first command.
* A program in the running state and in foreground (<code>fg</code>) can be suspended pressing {{keypress|Ctrl|z}}
* A suspended program can be resumed in foreground using the command <code>fg</code> or background using the command <code>bg</code>.
* A background process may become blocked on attempts to write to the terminal device (as distinct from simple writes to its standard output).
* The shell can synchronize with the completion of specific background jobs using the <code>wait</code> command by supplying a process ID or job number, or await completion of all background jobs by calling <code>wait</code> with no arguments.

=== Conditional Execution ===
Bash supplies "conditional execution" command separators which allow for the execution of a command to be contingent on the [[Exit status|exit code]] set by a precedent command.  For example:

<source lang="bash">
cd "$SOMEWHERE" && ./do_something || echo "An error occurred" >&2
</source>

Where ''./do_something'' is only executed if the ''cd'' (change directory) command was "successful" (returned an exit status of zero) and the ''echo'' command would only be executed if either the ''cd' or the ''./do_something'' command return an "error" (non-zero exit status).

For all commands the exit status is stored in the special variable <code>$?</code>.  Bash also support {{code|2=bash|if ...;then ...;else ...;fi}} and {{code|2=bash|case $VARIABLE in $pattern)...;;$other_pattern)...;; esac}} forms of conditional command evaluation.

===Bug reporting===
{{Redirect|bashbug|the widely reported September 2014 bug found in Bash|Shellshock (software bug)}}
An external command called ''bashbug'' reports Bash shell bugs.<ref>
[http://linux.die.net/man/1/bashbug bashbug(1)], die.net
</ref><ref>
[https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man1/bashbug.1.html "Linux / Unix Command: bashbug"], apple.com
</ref>
When the command is invoked, it brings up the user's default editor with a form to fill in. The form is mailed to the Bash maintainers (or optionally to other email addresses).

==See also==
{{Portal|Free software}}

* [[Comparison of command shells]]

==References==
{{Reflist|30em}}

==External links==
{{Commons category|GNU Bash|Bash}}
{{wikibooks|Bash Shell Scripting}}
* {{official website|https://www.gnu.org/software/bash/bash.html}}
* [https://www.gnu.org/software/bash/manual/ Bash Reference Manual]&nbsp; ([https://www.gnu.org/software/bash/manual/html_node/index.html HTML] [https://www.gnu.org/software/bash/manual/bash.ps.gz PS] [https://www.gnu.org/software/bash/manual/bash.pdf PDF])
* {{tldp|LDP/Bash-Beginners-Guide|Bash Guide for Beginners}}
* {{tldp|LDP/abs|Advanced Bash Scripting Guide}}
* [http://bash.cyberciti.biz/guide/Main_Page Linux Shell Scripting Tutorial (LSST) v2.0 wiki]
* [http://www.bashcookbook.com/bashinfo/ "The Comprehensive List of bash Reference Documentation and Examples"]
* [http://spsneo.com/blog/2009/09/19/bash-history-tips-and-tricks/ Useful Bash History Tips and Tricks]
* [http://www.computerworld.com.au/index.php/id;1591223321;fp;16;fpid;1;pf;1 2008 interview with GNU Bash's maintainer, Chet Ramey]
* [http://www.geeksww.com/tutorials/operating_systems/linux/tips_and_tricks/working_bash_environment_variables_beginners_linux.php Working with BASH environment variables]
* [http://www.galatech.co.uk/index.php/component/content/article/37-blogs/100-how-to-create-a-bash-script Video Tutorial for Creating a Bash Script]
* [http://www.shell-fu.org/lister.php?tag=bash Bash commands and examples]
* [http://www.markus-gattol.name/ws/bash.html#colorized_shell_prompt Colorized Bash prompt] - how to set up a colorized Bash prompt based on the current connection method (SSH, telnet, etc.).
* [https://code.google.com/p/jbash/ jBash Project is a Java Parser for the Bourne Again Shell]
* [http://mywiki.wooledge.org/EnglishFrontPage The 'official' channel FAQ for freenode's #bash channel is BashFAQ.]
* [http://bashdb.sourceforge.net/ BASHDB - Bash with a built-in debugger.]
* [http://www.digilife.be/quickreferences/QRC/Bash%20Quick%20Reference.pdf Bash Quick Reference card] <-- Dates from 1999 and version 2.02.0 of BASH. Very old. -->
* [http://ryanstutorials.net/linuxtutorial Beginner Linux Command Line Tutorial] - Covers the basics, all the way up to scripting.
* [http://wiki.altervista.org/cs/bash_shell Bash tutorial] - A quick tutorial about Bash shell, with the explanation of the most useful commands. Slides provided.

{{GNU}}
{{Unix Shells}}
{{Programming languages}}

{{DEFAULTSORT:Bash (Unix Shell)}}
[[Category:Text-oriented programming languages]]
[[Category:Domain-specific programming languages]]
[[Category:Scripting languages]]
[[Category:Unix shells]]
[[Category:GNU Project software]]
[[Category:Free software programmed in C]]
[[Category:Cross-platform free software]]
[[Category:1989 software]]