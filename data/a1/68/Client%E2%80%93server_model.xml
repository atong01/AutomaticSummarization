<article title='Client%E2%80%93server_model'><paragraph><link><target>File:Client-server-model.svg</target><part>thumb</part><part>250px</part><part>A<space/><link><target>computer network diagram</target></link><space/>of clients communicating with a server via the<space/><link><target>Internet</target></link>.</part></link></paragraph><paragraph>The<space/><bold>clientserver model</bold><space/>of computing is a<space/><link><target>distributed application</target></link><space/>structure that partitions tasks or workloads between the providers of a resource or service, called<space/><link><target>server (computing)</target><part>server</part><trail>s</trail></link>, and service requesters, called<space/><link><target>client (computing)</target><part>client</part><trail>s</trail></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://java.sun.com/developer/Books/jdbc/ch07.pdf</arg><arg name="publisher">Sun Microsystem</arg><arg name="title">Distributed Application Architecture</arg><arg name="accessdate">2009-06-16</arg></template></extension><space/>Often clients and servers communicate over a<space/><link><target>computer network</target></link><space/>on separate hardware, but both client and server may reside in the same system. A server host runs one or more server programs which share their resources with clients. A client does not share any of its resources, but requests a server's content or service function. Clients therefore initiate communication sessions with servers which await incoming requests.</paragraph><paragraph>Examples of computer applications that use the clientserver model are<space/><link><target>Email</target></link>,<space/><link><target>network printing</target></link>, and the<space/><link><target>World Wide Web</target></link>.</paragraph><heading level='2'>Client and server role</heading><paragraph>The<space/><italics>Client-server</italics><space/>characteristic describes the relationship of cooperating programs in an application. The server component provides a function or service to one or many clients, which initiate requests for such services.</paragraph><paragraph>Servers are classified by the services they provide. For instance, a<space/><link><target>web server</target></link><space/>serves<space/><link><target>web page</target><trail>s</trail></link><space/>and a<space/><link><target>file server</target></link><space/>serves<space/><link><target>computer file</target><trail>s</trail></link>. A shared resource may be any of the server computer's software and electronic components, from<space/><link><target>Computer program</target><part>programs</part></link><space/>and<space/><link><target>Data (computing)</target><part>data</part></link><space/>to<space/><link><target>Microprocessor</target><part>processors</part></link><space/>and<space/><link><target>Data storage device</target><part>storage devices</part></link>. The sharing of resources of a server constitute a<space/><italics>service</italics>.</paragraph><paragraph>Whether a computer is a client, a server, or both, is determined by the nature of the application that requires the service functions. For example, a single computer can run web server and file server software at the same time to serve different data to clients making different kinds of requests. Client software can also communicate with server software within the same computer.<extension extension_name='ref'>The<space/><link><target>X Window System</target></link><space/>is one example.</extension><space/>Communication between servers, such as to synchronize data, is sometimes called<space/><italics><link><target>inter-server</target></link></italics><space/>or<space/><italics>server-to-server</italics><space/>communication</paragraph><heading level='2'>Client and server communication</heading><paragraph>In general, a service is an<space/><link><target>Abstraction (computer science)</target><part>abstraction</part></link><space/>of computer resources and a client does not have to be<space/><link><target>Concern (computer science)</target><part>concerned</part></link><space/>with how the server performs while fulfilling the request and delivering the response. The client only has to understand the response based on the well-known application protocol, i.e. the content and the formatting of the data for the requested service.</paragraph><paragraph>Clients and servers exchange messages in a<space/><link><target>requestresponse</target></link><space/><link><target>messaging pattern</target></link>: The client sends a request, and the server returns a response. This exchange of messages is an example of<space/><link><target>inter-process communication</target></link>. To communicate, the computers must have a common language, and they must follow rules so that both the client and the server know what to expect. The language and rules of communication are defined in a<space/><link><target>communications protocol</target></link>. All client-server protocols operate in the<space/><link><target>application layer</target></link>. The application-layer protocol defines the basic patterns of the dialogue. To formalize the data exchange even further, the server may implement an<space/><link><target>Application programming interface</target><part>API</part></link><space/>(such as a<space/><link><target>web service</target></link>).<extension extension_name='ref'><template><target>Cite doi/10.1109.2FMIC.2004.1260703</target></template></extension><space/>The API is an<space/><link><target>abstraction layer</target></link><space/>for such resources as databases and<space/><link><target>custom software</target></link>. By restricting communication to a specific<space/><link><target>content format</target></link>, it facilitates<space/><link><target>parsing</target></link>. By abstracting access, it facilitates<space/><link><target>cross-platform</target></link><space/>data exchange.<extension extension_name='ref'><template><target>Cite doi/10.1504.2FIJWGS.2005.007545</target></template></extension></paragraph><paragraph>A server may receive requests from many different clients in a very short period of time. Because the computer can perform a limited number of<space/><link><target>Task (computing)</target><part>tasks</part></link><space/>at any moment, it relies on a<space/><link><target>Scheduling (computing)</target><part>scheduling</part></link><space/>system to prioritize incoming requests from clients in order to accommodate them all in turn. To prevent abuse and maximize<space/><link><target>uptime</target></link>, the server's<space/><link><target>software</target></link><space/>limits how a client can use the server's resources. Even so, a server is not immune from abuse. A<space/><link><target>denial of service attack</target></link><space/>exploits a server's obligation to process requests by bombarding it with requests incessantly. This inhibits the server's ability to respond to legitimate requests.</paragraph><heading level='2'>Example</heading><paragraph>When a<space/><link><target>bank</target></link><space/>customer accesses<space/><link><target>online banking</target></link><space/>services with a<space/><link><target>web browser</target></link><space/>(the client), the client initiates a request to the bank's web server. The customer's<space/><link><target>login</target></link><space/>credentials may be stored in a<space/><link><target>database</target></link>, and the web server accesses the<space/><link><target>database server</target></link><space/>as a client. An<space/><link><target>application server</target></link><space/>interprets the returned data by applying the bank's<space/><link><target>business logic</target></link>, and provides the<space/><link><target>Input/output</target><part>output</part></link><space/>to the web server. Finally, the web server returns the result to the client web browser for display.</paragraph><paragraph>In each step of this sequence of clientserver message exchanges, a computer processes a request and returns data. This is the request-response messaging pattern. When all the requests are met, the sequence is complete and the web browser presents the data to the customer.</paragraph><paragraph>This example illustrates a<space/><link><target>design pattern</target></link><space/>applicable to the clientserver model:<space/><link><target>separation of concerns</target></link>.</paragraph><heading level='2'>Early history</heading><paragraph>While formulating the clientserver model in the 1960s and 1970s,<space/><link><target>computer scientist</target><trail>s</trail></link><space/>at<space/><link><target>Xerox</target></link><space/>and<space/><link><target>Xerox PARC</target></link><space/>used the terms<space/><italics>server-host</italics><space/>(or<space/><italics>serving host</italics>) and<space/><italics>user-host</italics><space/>(or<space/><italics>using-host</italics>).<extension extension_name='ref' name="rulifson"><template><target>cite IETF</target><arg name="title">DEL<space/></arg><arg name="rfc">5<space/></arg><arg name="last">Rulifson<space/></arg><arg name="first">Jeff<space/></arg><arg name="authorlink">Jeff Rulifson<space/></arg><arg name="year">1969<space/></arg><arg name="month">June<space/></arg><arg name="publisher">[[Internet Engineering Task Force|IETF]]<space/></arg><arg name="accessdate">30 November 2013</arg></template></extension><extension extension_name='ref'><template><target>cite IETF</target><arg name="title">Network Timetable<space/></arg><arg name="rfc">4<space/></arg><arg name="last">Shapiro<space/></arg><arg name="first">Elmer B.<space/></arg><arg name="year">1969<space/></arg><arg name="month">March<space/></arg><arg name="publisher">[[Internet Engineering Task Force|IETF]]<space/></arg><arg name="accessdate">30 November 2013</arg></template></extension></paragraph><paragraph>One context in which researchers used these terms was in the design of a<space/><link><target>computer network programming</target></link><space/>language called Decode-Encode Language (DEL).<extension extension_name='ref' name="rulifson"></extension><space/>The purpose of this language was to accept commands from one computer (the user-host), which would return status reports to the user as it encoded the commands in network packets. Another DEL-capable computer, the server-host, received the packets, decoded them, and returned formatted data to the user-host. A DEL program on the user-host received the results to present to the user. This is a clientserver transaction. Development of DEL was just beginning in 1969, the year that the<space/><link><target>United States Department of Defense</target></link><space/>established<space/><link><target>ARPANET</target></link><space/>(predecessor of<space/><link><target>Internet</target></link>).</paragraph><heading level='3'>Client-host and server-host</heading><paragraph><italics>Client-host</italics><space/>and<space/><italics>server-host</italics><space/>have subtly different meanings than<space/><italics>client</italics><space/>and<space/><italics>server</italics>. A<space/><link><target>Host (network)</target><part>host</part></link><space/>is any computer connected to a network. Whereas the words<space/><italics>server</italics><space/>and<space/><italics>client</italics><space/>may refer either to a computer or to a computer program,<space/><italics>server-host</italics><space/>and<space/><italics>user-host</italics><space/>always refer to computers. The host is a versatile, multifunction computer;<space/><italics>clients</italics><space/>and<space/><italics>servers</italics><space/>are just programs that run on a host. In the clientserver model, a server is more likely to be devoted to the task of serving.</paragraph><paragraph>An early use of the word<space/><italics>client</italics><space/>occurs in &quot;Separating Data from Function in a Distributed File System&quot;, a 1978 paper by Xerox PARC computer scientists Howard Sturgis, James Mitchell, and Jay Israel. The authors are careful to define the term for readers, and explain that they use it to distinguish between the user and the user's network node (the client).<extension extension_name='ref'><template><target>Cite journal</target><arg name="last"><space/>Sturgis<space/></arg><arg name="first"><space/>Howard E.<space/></arg><arg name="last2"><space/>Mitchell<space/></arg><arg name="first2"><space/>James George<space/></arg><arg name="last3"><space/>Israel<space/></arg><arg name="first3"><space/>Jay E.<space/></arg><arg name="chapter"><space/>Separating Data from Function in a Distributed File System<space/></arg><arg name="journal"><space/></arg><arg name="publisher">[[Xerox PARC]]<space/></arg><arg name="chapterurl">http://ip.com/IPCOM/000128883<space/></arg><arg name="year"><space/>1978</arg></template></extension><space/>(By 1992, the word<space/><italics>server</italics><space/>had entered into general parlance.)<extension extension_name='ref'><template><target>OEtymD</target><arg>server</arg><arg name="accessdate">30 November 2013</arg></template></extension><extension extension_name='ref'><template><target>cite web</target><arg name="url">https://getinfo.de/app/Separating-data-from-function-in-a-distributed/id/TIBKAT%3A509976956<space/></arg><arg name="title">Separating data from function in a distributed file system<space/></arg><arg name="author"><space/></arg><arg name="website">[[GetInfo]]<space/></arg><arg name="publisher">[[German National Library of Science and Technology]]<space/></arg><arg name="accessdate">29 November 2013</arg></template></extension></paragraph><heading level='2'>Centralized computing</heading><paragraph><template><target>Further</target><arg>History of personal computers</arg><arg>Decentralized computing</arg><arg>Computer cluster</arg></template></paragraph><paragraph>The clientserver model does not dictate that server-hosts must have more resources than client-hosts. Rather, it enables any general-purpose computer to extend its capabilities by using the shared resources of other hosts.<space/><link><target>Centralized computing</target></link>, however, specifically allocates a large amount of resources to a small number of computers. The more computation is offloaded from client-hosts to the central computers, the simpler the client-hosts can be.<extension extension_name='ref' name="Columbia"><template><target>cite journal</target><arg name="last"><space/>Nieh<space/></arg><arg name="first"><space/>Jason<space/></arg><arg name="last2"><space/>Novik<space/></arg><arg name="first2"><space/>Naomi<space/></arg><arg name="last3"><space/>Yang<space/></arg><arg name="first3"><space/>S. Jae<space/></arg><arg name="title"><space/>A Comparison of Thin-Client Computing Architectures<space/></arg><arg name="journal"><space/>Technical Report CUCS-022-00<space/></arg><arg name="publisher"><space/>Network Computing Laboratory, [[Columbia University]]<space/></arg><arg name="location"><space/>New York<space/></arg><arg name="date"><space/>Deccmu.edu/~dga/papers/tolia06-ieee.pdf<space/></arg><arg name="format">PDF</arg></template></extension><space/>It relies heavily on network resources (servers and infrastructure) for computation and storage. A<space/><link><target>diskless node</target></link><space/>loads even its<space/><link><target>operating system</target></link><space/>from the network, and a<space/><link><target>computer terminal</target></link><space/>has no operating system at all; it is only an input/output interface to the server. In contrast, a<space/><link><target>fat client</target></link>, such as a<space/><link><target>personal computer</target></link>, has many resources, and does not rely on a server for essential functions.</paragraph><paragraph>As<space/><link><target>microcomputer</target><trail>s</trail></link><space/>decreased in price and increased in power from the 1980s to the late 1990s, many organizations transitioned computation from centralized servers, such as<space/><link><target>Mainframe computer</target><part>mainframe</part><trail>s</trail></link><space/>and<space/><link><target>minicomputer</target><trail>s</trail></link>, to fat clients.<extension extension_name='ref'><template><target>Cite doi/10.1145.2F800041.801417</target></template></extension><space/>This afforded greater, more individualized dominion over computer resources, but complicated<space/><link><target>information technology management</target></link>.<extension extension_name='ref' name="Columbia"></extension><extension extension_name='ref' name="tolia"><template><target>Cite journal</target><arg name="last"><space/>Tolia<space/></arg><arg name="first"><space/>Niraj<space/></arg><arg name="last2"><space/>Andersen<space/></arg><arg name="first2"><space/>David G.<space/></arg><arg name="last3"><space/>Satyanarayanan<space/></arg><arg name="first3"><space/>M.<space/></arg><arg name="title"><space/>Quantifying Interactive User Experience on Thin Clients<space/></arg><arg name="journal"><space/>[[Computer (magazine)|Computer]]<space/></arg><arg name="volume"><space/>39<space/></arg><arg name="number"><space/>3<space/></arg><arg name="date"><space/>March 2006<space/></arg><arg name="publisher"><space/>[[IEEE Computer Society]]<space/></arg><arg name="url"><space/>http://www.cs.cmu.edu/~dga/papers/tolia06-ieee.pdf<space/></arg><arg name="format">PDF</arg></template></extension><extension extension_name='ref'><template><target>cite web</target><arg name="url">http://sqlmag.com/cloud/cloud-really-just-return-mainframe-computing<space/></arg><arg name="title">Is the Cloud Really Just the Return of Mainframe Computing?<space/></arg><arg name="last">Otey<space/></arg><arg name="first">Michael<space/></arg><arg name="date">22 March 2011<space/></arg><arg name="website">[[SQL Server Pro]]<space/></arg><arg name="publisher">[[Penton Media]]<space/></arg><arg name="accessdate">1 December 2013</arg></template></extension><space/>During the 2000s,<space/><link><target>web application</target><trail>s</trail></link><space/>matured enough to rival<space/><link><target>application software</target></link><space/>developed for a specific<space/><link><target>microarchitecture</target></link>. This maturation, more affordable<space/><link><target>mass storage</target></link>, and the advent of<space/><link><target>service-oriented architecture</target></link><space/>were among the factors that gave rise to the<space/><link><target>cloud computing</target></link><space/>trend of the 2010s.<extension extension_name='ref'><template><target>Cite doi/10.1109.2FMITP.2006.123</target></template></extension></paragraph><heading level='2'>Comparison with peer-to-peer architecture</heading><paragraph>In addition to the clientserver model,<space/><link><target>distributed computing</target></link><space/>applications often use the<space/><link><target>peer-to-peer</target></link><space/>(P2P) application architecture.</paragraph><paragraph>In the clientserver model, the server is often designed to be a centralized system that serves many clients. The computing power, memory and storage requirements of a server must be scaled appropriately to the expected work load (<italics>i.e.</italics>, the number of clients connecting simultaneously).<space/><link><target>Load balancing (computing)</target><part>Load balancing</part></link><space/>and<space/><link><target>failover</target></link><space/>systems are often employed to scale the server implementation.</paragraph><paragraph>In a<space/><link><target>peer-to-peer</target></link><space/>network, two or more computers (<italics>peers</italics>) pool their resources and communicate in a<space/><link><target>decentralized system</target></link>. Peers are coequal, or equipotent<space/><link><target>Node (networking)</target><part>nodes</part></link><space/>in a non-hierarchical network. Unlike clients in a clientserver or<space/><link><target>clientqueueclient</target></link><space/>network, peers communicate with each other directly.<extension extension_name='ref' name="Yongsheng"><template><target>Cite doi/10.3923.2Fjas.2013.700.707</target></template></extension><space/>In peer-to-peer networking, an<space/><link><target>Computer algorithm</target><part>algorithm</part></link><space/>in the peer-to-peer communications protocol balances<space/><link><target>Load (computing)</target><part>load</part></link>, and even peers with modest resources can help to share the load.<extension extension_name='ref' name="Yongsheng"></extension><space/>If a node becomes unavailable, its shared resources remain available as long as other peers offers it. Ideally, a peer does not need to achieve<space/><link><target>high availability</target></link><space/>because other,<space/><link><target>Redundancy (engineering)</target><part>redundant</part></link><space/>peers make up for any resource<space/><link><target>downtime</target></link>; as the availability and load capacity of peers change, the protocol reroutes requests.</paragraph><heading level='2'>See also</heading><paragraph><template><target>Columns-list</target><arg>2</arg><arg>
* [[Modular programming]]
* [[Observer pattern]]
* [[Publish–subscribe pattern]]
* [[Pull technology]]
* [[Push technology]]
* [[Remote procedure call]]
</arg></template></paragraph><heading level='2'>Notes</heading><paragraph><template><target>Reflist</target></template></paragraph><paragraph><template><target>IPC</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Client-server model</target></template><link><target>Category:Application layer protocols</target><part></part></link><link><target>Category:Clients (computing)</target><part></part></link><link><target>Category:Inter-process communication</target></link><link><target>Category:Servers (computing)</target><part></part></link><link><target>Category:Network architecture</target></link></paragraph></article>