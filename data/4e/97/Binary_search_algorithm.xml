<article title='Binary_search_algorithm'><paragraph><template><target>about</target><arg>searching a finite sorted array</arg><arg>searching continuous function values</arg><arg>bisection method</arg></template><template><target>Cleanup</target><arg name="date">April 2011</arg></template><template><target>Infobox algorithm</target><arg name="class">[[Search algorithm]]
</arg><arg name="image">
</arg><arg name="data">[[array data structure|Array]]
</arg><arg name="time">[[big O notation#Orders of common functions|''O''(log ''n'')]]
</arg><arg name="space"><space/>[[big O notation#Orders of common functions|''O''(1)]]
</arg><arg name="best-time">[[big O notation#Orders of common functions|''O''(1)]]
</arg><arg name="average-time">[[big O notation#Orders of common functions|''O''(log ''n'')]]
</arg><arg name="optimal">Yes
</arg></template>In<space/><link><target>computer science</target></link>, a<space/><bold>binary search</bold><space/>or<space/><bold>half-interval search</bold><space/><link><target>algorithm</target></link><space/>finds the position of a target value within a<space/><link><target>sorted array</target></link>.<extension extension_name='ref'><template><target>Introduction to Algorithms</target><arg name="edition">1</arg></template></extension><extension extension_name='ref'><template><target>MathWorld</target><arg name="title">Binary Search<space/></arg><arg name="id">BinarySearch</arg></template></extension><space/>The binary search algorithm can be classified as a<space/><link><target>dichotomic search</target><part>dichotomic</part></link><space/><link><target>divide and conquer algorithm</target><part>divide-and-conquer</part></link><space/><link><target>search algorithm</target></link><space/>and executes in<space/><link><target>logarithmic time</target></link>.</paragraph><heading level='2'>Overview</heading><paragraph>The binary search algorithm begins by comparing the target value to the value of the middle element of the sorted array. If the target value is equal to the middle element's value, then the position is returned and the search is finished. If the target value is less than the middle element's value, then the search continues on the lower half of the array; or if the target value is greater than the middle element's value, then the search continues on the upper half of the array. This process continues, eliminating half of the elements, and comparing the target value to the value of the middle element of the remaining elements - until the target value is either found (and its associated element position is returned), or until the entire array has been searched (and &quot;not found&quot; is returned).</paragraph><heading level='2'>Example</heading><preblock><preline><space/><space/><space/>Sorted array: L = [1, 3, 4, 6, 8, 9, 11]<space/></preline><preline><space/><space/><space/>Target value: X = 4</preline><preline><space/><space/><space/>Compare X to 6. X is smaller. Repeat with L = [1, 3, 4].</preline><preline><space/><space/><space/>Compare X to 3. X is larger. Repeat with L = [4].</preline><preline><space/><space/><space/>Compare X to 4. X equals 4, so the position is returned.</preline><preline></preline></preblock><heading level='3'>Number guessing game</heading><paragraph>This rather simple game begins something like &quot;I'm thinking of an integer between forty and sixty inclusive, and to your guesses I'll respond 'Higher', 'Lower', or 'Yes!' as might be the case.&quot;Supposing that<space/><italics>N</italics><space/>is the number of possible values (here, twenty-one, as &quot;inclusive&quot; was stated), then at most<space/><extension extension_name='math'>\lfloor\log_2 N\rfloor+1</extension><space/>questions are required to determine the number, since each question halves the search space. Note that one less question (iteration) is required than for the general algorithm, since the number is already constrained to be within a particular range.</paragraph><paragraph>Even if the number to guess can be arbitrarily large, in which case there is no upper bound<space/><italics>N</italics>, the number can be found in at most<space/><extension extension_name='math'>2\lfloor \log_2 k \rfloor+1</extension><space/>steps (where<space/><italics>k</italics><space/>is the (unknown) selected number) by first finding an upper bound with<space/><link><target>Binary search algorithm#One-sided search</target><part>one-sided binary search</part></link>.<template><target>Citation needed</target><arg name="date">August 2009</arg></template><space/>For example, if the number were 11, the following sequence of guesses could be used to find it: 1 (Higher), 2 (Higher), 4 (Higher), 8 (Higher), 16 (Lower), 12 (Lower), 10 (Higher). Now we know that the number must be 11 because it is higher than 10 and lower than 12.</paragraph><paragraph>One could also extend the method to include negative numbers; for example the following guesses could be used to find 13: 0, 1, 2, 4, 8, 16, 12, 14. Now we know that the number must be 13 because it is lower than 12 and higher than 14.</paragraph><heading level='3'>Word lists</heading><paragraph>People typically use a mixture of the binary search and<space/><link><target>Interpolation search</target><part>interpolative search</part></link><space/>algorithms when searching a<space/><link><target>telephone book</target></link>, after the initial guess we exploit the fact that the entries are sorted and can rapidly find the required entry. For example when searching for Smith, if Rogers and Thomas have been found, one can flip to a page about halfway between the previous guesses. If this shows Samson, it can be concluded that Smith is somewhere between the Samson and Thomas pages so these can be divided.</paragraph><heading level='3'>Applications to complexity theory</heading><paragraph>Even if we do not know a fixed range the number<space/><italics>k</italics><space/>falls in, we can still determine its value by asking<space/><extension extension_name='math'>2\lceil\log_2k\rceil</extension><space/>simple yes/no questions of the form &quot;Is<space/><italics>k</italics><space/>greater than<space/><italics>x</italics>?&quot; for some number<space/><italics>x</italics>. As a simple consequence of this, if you can answer the question &quot;Is this integer property<space/><italics>k</italics><space/>greater than a given value?&quot; in some amount of time then you can find the value of that property in the same amount of time with an added factor of<space/><extension extension_name='math'>\log_2 k</extension>. This is called a<space/><italics><link><target>reduction (complexity)</target><part>reduction</part></link></italics>, and it is because of this kind of reduction that most complexity theorists concentrate on<space/><link><target>decision problem</target><trail>s</trail></link>, algorithms that produce a simple yes/no answer.</paragraph><paragraph>For example, suppose we could answer &quot;Does this<space/><italics>n</italics><space/>x<space/><italics>n</italics><space/>matrix have<space/><link><target>permanent</target></link><space/>larger than<space/><italics>k</italics>?&quot; in O(<italics>n<xhtml:sup>2</xhtml:sup></italics>) time. Then, by using binary search, we could find the (ceiling of the) permanent itself in O(<italics>n<xhtml:sup>2</xhtml:sup></italics><space/>log<space/><italics>p</italics>) time, where<space/><italics>p</italics><space/>is the value of the permanent. Notice that<space/><italics>p</italics><space/>is not the size of the input, but the<space/><italics>value</italics><space/>of the output; given a matrix whose maximum item (in absolute value) is<space/><italics>m</italics>,<space/><italics>p</italics><space/>is bounded by<space/><extension extension_name='math'>m^n n!</extension>. Hence log<space/><italics>p</italics><space/>= O(<italics>n</italics><space/>log<space/><italics>n</italics><space/>+<space/><italics>n</italics><space/>log<space/><italics>m</italics>). A binary search could find the permanent in O(<italics>n</italics><xhtml:sup>3</xhtml:sup><space/>log<space/><italics>n</italics><space/>+<space/><italics>n</italics><xhtml:sup>3</xhtml:sup><space/>log<space/><italics>m</italics>).</paragraph><heading level='2'>Algorithm</heading><heading level='3'>Recursive</heading><paragraph>A straightforward implementation of binary search is<space/><link><target>recursion</target><part>recursive</part></link>. The initial call uses the indices of the entire array to be searched. The procedure then calculates an index midway between the two indices, determines which of the two subarrays to search, and then does a recursive call to search that subarray. Each of the calls is<space/><link><target>tail recursive</target></link>, so a compiler need not make a new stack frame for each call. The variables<space/><xhtml:code>imin</xhtml:code><space/>and<space/><xhtml:code>imax</xhtml:code><space/>are the lowest and highest inclusive indices that are searched.<extension extension_name='source' lang="C"><paragraph>int binary_search(int A[], int key, int imin, int imax){</paragraph><preblock><preline><space/>// test if array is empty</preline><preline><space/>if (imax &lt; imin)</preline><preline><space/><space/><space/>// set is empty, so return value showing not found</preline><preline><space/><space/><space/>return KEY_NOT_FOUND;</preline><preline><space/>else</preline><preline><space/><space/><space/>{</preline><preline><space/><space/><space/><space/><space/>// calculate midpoint to cut set in half</preline><preline><space/><space/><space/><space/><space/>int imid = midpoint(imin, imax);</preline><preline><space/><space/><space/><space/><space/></preline><preline><space/><space/><space/><space/><space/>// three-way comparison</preline><preline><space/><space/><space/><space/><space/>if (A[imid] &gt; key)</preline><preline><space/><space/><space/><space/><space/><space/><space/>// key is in lower subset</preline><preline><space/><space/><space/><space/><space/><space/><space/>return binary_search(A, key, imin, imid - 1);</preline><preline><space/><space/><space/><space/><space/>else if (A[imid] &lt; key)</preline><preline><space/><space/><space/><space/><space/><space/><space/>// key is in upper subset</preline><preline><space/><space/><space/><space/><space/><space/><space/>return binary_search(A, key, imid + 1, imax);</preline><preline><space/><space/><space/><space/><space/>else</preline><preline><space/><space/><space/><space/><space/><space/><space/>// key has been found</preline><preline><space/><space/><space/><space/><space/><space/><space/>return imid;</preline><preline><space/><space/><space/>}</preline></preblock><paragraph>}</paragraph></extension></paragraph><paragraph>It is invoked with initial<space/><xhtml:code>imin</xhtml:code><space/>and<space/><xhtml:code>imax</xhtml:code><space/>values of<space/><xhtml:code>0</xhtml:code><space/>and<space/><xhtml:code>N-1</xhtml:code><space/>for a zero based array of length N.</paragraph><paragraph>The number type &quot;int&quot; shown in the code has an influence on how the midpoint calculation can be implemented correctly. With unlimited numbers, the midpoint can be calculated as<space/><xhtml:code>&quot;(imin + imax) / 2&quot;</xhtml:code>. In practical programming, however, the calculation is often performed with numbers of a limited range, and then the intermediate result<space/><xhtml:code>&quot;(imin + imax)&quot;</xhtml:code><space/>might overflow. With limited numbers, the midpoint can be calculated correctly as<space/><xhtml:code>&quot;imin + ((imax - imin) / 2)&quot;</xhtml:code>.</paragraph><heading level='3'>Iterative</heading><paragraph>The binary search algorithm can also be expressed iteratively with two index limits that progressively narrow the search range.<extension extension_name='ref'><template><target>Citation</target><arg name="first1"><space/>William H.<space/></arg><arg name="last1"><space/>Press<space/></arg><arg name="first2"><space/>Brian P.<space/></arg><arg name="last2"><space/>Flannery<space/></arg><arg name="first3"><space/>Saul A.<space/></arg><arg name="last3"><space/>Teukolsky<space/></arg><arg name="first4"><space/>William T.<space/></arg><arg name="last4"><space/>Vetterling<space/></arg><arg name="year"><space/>1988<space/></arg><arg name="publisher"><space/>Cambridge University Press<space/></arg><arg name="title"><space/>Numerical Recipes in C: The Art of Scientific Computing<space/></arg><arg name="isbn"><space/>0-521-35465-X<space/></arg><arg name="doi"><space/></arg><arg name="pages"><space/>98&ndash;99<space/></arg></template></extension><extension extension_name='source' lang="C"><paragraph>int binary_search(int A[], int key, int imin, int imax){</paragraph><preblock><preline><space/>// continue searching while [imin,imax] is not empty</preline><preline><space/>while (imin &lt;= imax)</preline><preline><space/><space/><space/>{</preline><preline><space/><space/><space/><space/><space/>// calculate the midpoint for roughly equal partition</preline><preline><space/><space/><space/><space/><space/>int imid = midpoint(imin, imax);</preline><preline><space/><space/><space/><space/><space/>if(A[imid] == key)</preline><preline><space/><space/><space/><space/><space/><space/><space/>// key found at index imid</preline><preline><space/><space/><space/><space/><space/><space/><space/>return imid;<space/></preline><preline><space/><space/><space/><space/><space/>// determine which subarray to search</preline><preline><space/><space/><space/><space/><space/>else if (A[imid] &lt; key)</preline><preline><space/><space/><space/><space/><space/><space/><space/>// change min index to search upper subarray</preline><preline><space/><space/><space/><space/><space/><space/><space/>imin = imid + 1;</preline><preline><space/><space/><space/><space/><space/>else<space/></preline><preline><space/><space/><space/><space/><space/><space/><space/>// change max index to search lower subarray</preline><preline><space/><space/><space/><space/><space/><space/><space/>imax = imid - 1;</preline><preline><space/><space/><space/>}</preline><preline><space/>// key was not found</preline><preline><space/>return KEY_NOT_FOUND;</preline></preblock><paragraph>}</paragraph></extension></paragraph><heading level='3'>Deferred detection of equality</heading><paragraph>The above iterative and recursive versions take three paths based on the key comparison: one path for less than, one path for greater than, and one path for equality. (There are two conditional branches.) The path for equality is taken only when the record is finally matched, so it is rarely taken. That branch path can be moved outside the search loop in the deferred test for equality version of the algorithm. The following algorithm uses only one conditional branch per iteration.<extension extension_name='ref'><template><target>Citation</target><arg name="last">Wirth<space/></arg><arg name="first">Niklaus<space/></arg><arg name="authorlink">Niklaus Wirth<space/></arg><arg name="title">Programming in Modula-2<space/></arg><arg name="year">1983<space/></arg><arg name="isbn"><space/></arg><arg name="doi"><space/></arg><arg name="page">35</arg></template></extension></paragraph><paragraph><extension extension_name='source' lang="C"><paragraph>// inclusive indices// 0 &lt;= imin when using truncate toward zero divide// imid = (imin+imax)/2;// imin unrestricted when using truncate toward minus infinity divide// imid = (imin+imax)&gt;&gt;1; or// imid = (int)floor((imin+imax)/2.0);int binary_search(int A[], int key, int imin, int imax){</paragraph><preblock><preline><space/>// continually narrow search until just one element remains</preline><preline><space/>while (imin &lt; imax)</preline><preline><space/><space/><space/>{</preline><preline><space/><space/><space/><space/><space/>int imid = midpoint(imin, imax);</preline></preblock><preblock><preline><space/><space/><space/><space/><space/>// code must guarantee the interval is reduced at each iteration</preline><preline><space/><space/><space/><space/><space/>assert(imid &lt; imax);</preline><preline><space/><space/><space/><space/><space/>// note: 0 &lt;= imin &lt; imax implies imid will always be less than imax</preline></preblock><preblock><preline><space/><space/><space/><space/><space/>// reduce the search</preline><preline><space/><space/><space/><space/><space/>if (A[imid] &lt; key)</preline><preline><space/><space/><space/><space/><space/><space/><space/>imin = imid + 1;</preline><preline><space/><space/><space/><space/><space/>else</preline><preline><space/><space/><space/><space/><space/><space/><space/>imax = imid;</preline><preline><space/><space/><space/>}</preline><preline><space/>// At exit of while:</preline><preline><space/>// if A[] is empty, then imax &lt; imin</preline><preline><space/>// otherwise imax == imin</preline></preblock><preblock><preline><space/>// deferred test for equality</preline><preline><space/>if ((imax == imin) &amp;&amp; (A[imin] == key))</preline><preline><space/><space/><space/>return imin;</preline><preline><space/>else</preline><preline><space/><space/><space/>return KEY_NOT_FOUND;</preline></preblock><paragraph>}</paragraph></extension>The deferred detection approach foregoes the possibility of early termination on discovery of a match, so the search will take about log<xhtml:sub>2</xhtml:sub>(<italics>N</italics>) iterations. On average, a<space/><italics>successful</italics><space/>early termination search will not save many iterations. For large arrays that are a power of 2, the savings is about two iterations. Half the time, a match is found with one iteration left to go; one quarter the time with two iterations left, one eighth with three iterations, and so forth. The infinite series sum is 2.</paragraph><paragraph>The deferred detection algorithm has the advantage that if the keys are not unique, it returns the smallest index (the starting index) of the region where elements have the search key. The early termination version would return the first match it found, and that match might be anywhere in region of equal keys.</paragraph><heading level='2'>Performance</heading><paragraph>With each test that fails to find a match at the probed position, the search is continued with one or other of the two sub-intervals, each at most half the size. More precisely, if the number of items,<space/><italics>N</italics>, is odd then both sub-intervals will contain (<italics>N</italics>1)/2 elements, while if<space/><italics>N</italics><space/>is even then the two sub-intervals contain<space/><italics>N</italics>/21 and<space/><italics>N</italics>/2 elements.</paragraph><paragraph>If the original number of items is<space/><italics>N</italics><space/>then after the first iteration there will be at most<space/><italics>N</italics>/2 items remaining, then at most<space/><italics>N</italics>/4 items, at most<space/><italics>N</italics>/8 items, and so on. In the worst case, when the value is not in the list, the algorithm must continue iterating until the span has been made empty; this will have taken at most<space/><link><target>binary logarithm</target><part>log<xhtml:sub>2</xhtml:sub></part></link>(<italics>N</italics>)+1 iterations, where the &amp;nbsp; notation denotes the<space/><link><target>floor function</target></link><space/>that rounds its argument down to an integer. This<space/><link><target>worst case analysis</target></link><space/>is tight: for any<space/><italics>N</italics><space/>there exists a query that takes exactly<space/><link><target>binary logarithm</target><part>log<xhtml:sub>2</xhtml:sub></part></link>(<italics>N</italics>)+1 iterations. When compared to<space/><link><target>linear search</target></link>, whose worst-case behaviour is<space/><italics>N</italics><space/>iterations, we see that binary search is substantially faster as<space/><italics>N</italics><space/>grows large. For example, to search a list of one million items takes as many as one million iterations with linear search, but never more than twenty iterations with binary search. However, a binary search can only be performed if the list is in sorted order.</paragraph><heading level='3'>Average performance</heading><paragraph><template><target>math</target><arg>log<sub>2</sub>(''N'')−1</arg></template><space/>is the expected number of probes in an average successful search, and the worst case is<space/><template><target>math</target><arg>log<sub>2</sub>(''N'')</arg></template>, just one more probe.<template><target>citation needed</target><arg name="date">October 2011</arg></template><space/>If the list is empty, no probes at all are made.Thus binary search is a<space/><link><target>logarithmic algorithm</target></link><space/>and executes in<space/><link><target>big O notation</target><part><template><target>math</target><arg>O(log ''N'')</arg></template></part></link><space/>time. In most cases it is considerably faster than a<space/><link><target>linear search</target></link>. It can be implemented using<space/><link><target>iteration</target></link>, or<space/><link><target>recursion</target></link>. In some languages it is more elegantly expressed recursively; however, in some C-based languages tail recursion is not eliminated and the recursive version requires more stack space.</paragraph><paragraph>Binary search can interact poorly with the memory hierarchy (i.e.<space/><link><target>cache (computing)</target><part>caching</part></link>), because of its random-access nature. For in-memory searching, if the span to be searched is small, a linear search may have superior performance simply because it exhibits better<space/><link><target>locality of reference</target></link>. For external searching, care must be taken or each of the first several probes will lead to a disk seek. A common method is to abandon binary searching for linear searching as soon as the size of the remaining span falls below a small value such as 8 or 16 or even more in recent computers. The exact value depends entirely on the machine running the algorithm.</paragraph><paragraph>Notice that for multiple searches<space/><italics>with a fixed value for<space/><template><target>mvar</target><arg>N</arg></template></italics>, then (with the appropriate regard for integer division), the first iteration always selects the middle element at<space/><template><target>math</target><arg>''N''/2</arg></template>, and the second always selects either<space/><template><target>math</target><arg>''N''/4</arg></template><space/>or<space/><template><target>math</target><arg>3''N''/4</arg></template>, and so on. Thus if the array's key values are in some sort of slow storage (on a disc file, in virtual memory, not in the CPU's on-chip memory), keeping those three keys in a local array for a special preliminary search will avoid accessing widely separated memory. Escalating to seven or fifteen such values will allow further levels at not much cost in storage. On the other hand, if the searches are frequent and not separated by much other activity, the computer's various storage control features will more or less automatically promote frequently accessed elements into faster storage.</paragraph><paragraph>When multiple binary searches are to be performed for the same key in related lists,<space/><link><target>fractional cascading</target></link><space/>can be used to speed up successive searches after the first one.</paragraph><paragraph>In theory binary search is usually faster than linear search, but in practice that may not hold true. For small arrays (say about 64 items or less), linear search may have better performance. For any size unsorted array, the cost of sorting the array may exceed the speed advantage of binary search when the array is only searched a few times because the time to sort the array is comparable to<space/><template><target>math</target><arg>log(''n'')</arg></template><space/>linear searches<extension extension_name='ref'><template><target>cite web</target><arg name="first">Adam<space/></arg><arg name="last">Horvath<space/></arg><arg name="url">http://blog.teamleadnet.com/2012/02/quicksort-binary-search-and-linear.html<space/></arg><arg name="title">Binary search and linear search performance on the .NET and Mono platform<space/></arg><arg name="date">February 5, 2012</arg></template></extension><space/>For example, if an unsorted array will only be searched once, it will be faster to just do a linear search rather than sorting the array and then doing a binary search.</paragraph><heading level='2'>Variations</heading><heading level='3'>Exclusive or inclusive bounds</heading><paragraph>The most significant differences are between the &quot;exclusive&quot; and &quot;inclusive&quot; forms of the bounds. In the &quot;exclusive&quot; bound form the span to be searched is<space/><italics>(L+1)</italics><space/>to<space/><italics>(R1)</italics>, and this may seem clumsy when the span to be searched could be described in the &quot;inclusive&quot; form, as<space/><italics>L</italics><space/>to<space/><italics>R</italics>. Although the details differ the two forms are equivalent as can be seen by transforming one version into the other. The inclusive bound form can be attained by replacing all appearances of &quot;L&quot; by &quot;(L1)&quot; and &quot;R&quot; by &quot;(R+1)&quot; then rearranging. Thus, the initialisation of<space/><italics>L</italics><space/>:= 0 becomes (<italics>L</italics>1) := 0 or<space/><italics>L</italics><space/>:= 1, and<space/><italics>R</italics><space/>:=<space/><italics>N</italics>+1 becomes (<italics>R</italics>+1) :=<space/><italics>N</italics>+1 or<space/><italics>R</italics><space/>:=<space/><italics>N</italics>. So far so good, but note now that the changes to<space/><italics>L</italics><space/>and<space/><italics>R</italics><space/>are no longer simply transferring the value of<space/><italics>p</italics><space/>to<space/><italics>L</italics><space/>or<space/><italics>R</italics><space/>as appropriate but now must be (<italics>R</italics>+1) :=<space/><italics>p</italics><space/>or<space/><italics>R</italics><space/>:=<space/><italics>p</italics>1, and (<italics>L</italics>1) :=<space/><italics>p</italics><space/>or<space/><italics>L</italics><space/>:=<space/><italics>p</italics>+1.</paragraph><paragraph>Thus, the gain of a simpler initialisation, done once, is lost by a more complex calculation, and which is done for every iteration. If that is not enough, the test for an empty span is more complex also, as compared to the simplicity of checking that the value of<space/><italics>p</italics><space/>is zero. Nevertheless, the inclusive bound form is found in many publications, such as<space/><link><target>Donald Knuth</target></link>.<space/><italics>The Art of Computer Programming</italics>, Volume 3:<space/><italics>Sorting and Searching</italics>, Third Edition.</paragraph><paragraph>Another common variation uses inclusive bounds for the left bound, but exclusive bounds for the right bound. This is derived from the fact that the bounds in a language with zero-based arrays can be simply initialized to 0 and the size of the array, respectively. This mirrors the way array slices are represented in some programming languages.</paragraph><heading level='3'>Midpoint and width</heading><paragraph>A different variation involves abandoning the<space/><italics>L</italics><space/>and<space/><italics>R</italics><space/>pointers and using a current position<space/><italics>p</italics><space/>and a width<space/><italics>w</italics>. At each iteration, the position<space/><italics>p</italics><space/>is adjusted and the width<space/><italics>w</italics><space/>is halved. Knuth states, &quot;It is possible to do this, but only if extreme care is paid to the details.&quot;<extension extension_name='ref'><template><target>cite book</target><arg name="last">Knuth<space/></arg><arg name="first">Donald<space/></arg><arg name="page">414<space/></arg><arg name="edition">3rd<space/></arg><arg name="date">1968<space/></arg><arg name="title">Sorting and Searching<space/></arg><arg name="series">[[The Art of Computer Programming]]<space/></arg><arg name="volume">3<space/></arg><arg name="publisher">Addison-Wesley<space/></arg><arg name="isbn">978-0321751041</arg></template></extension></paragraph><heading level='3'>Search domain</heading><paragraph>There is no particular requirement that the array being searched has the bounds 1 to<space/><italics>N</italics>. It is possible to search a specified range, elements<space/><italics>first</italics><space/>to<space/><italics>last</italics><space/>instead of 1 to<space/><italics>N</italics>. All that is necessary is that the initialization of the bounds be<space/><italics>L := first1</italics><space/>and<space/><italics>R := last+1</italics>, then all proceeds as before.</paragraph><paragraph>The elements of the list are not necessarily all unique. If one searches for a value that occurs multiple times in the list, the index returned will be of the first-encountered equal element, and this will not necessarily be that of the first, last, or middle element of the run of equal-key elements but will depend on the positions of the values. Modifying the list even in seemingly unrelated ways such as adding elements elsewhere in the list may change the result.</paragraph><paragraph>If the location of the first and/or last equal element needs to be determined, this can be done efficiently with a variant of the binary search algorithms which perform only one inequality test per iteration. See<space/><link><target>#Deferred detection of equality</target><part>deferred detection of equality</part></link>.</paragraph><heading level='3'>Noisy search</heading><paragraph>Several algorithms closely related to or extending binary search exist. For instance,<space/><bold>noisy binary search</bold><space/>solves the same class of projects as regular binary search, with the added complexity that any given test can return a false value at random. (Usually, the number of such erroneous results are bounded in some way, either in the form of an average error rate, or in the total number of errors allowed per element in the search space.) Optimal algorithms for several classes of noisy binary search problems have been known since the late seventies, and more recently, optimal algorithms for noisy binary search in quantum computers (where several elements can be tested at the same time) have been discovered.</paragraph><heading level='3'>Exponential search<template><target>anchor</target><arg>One-sided search</arg></template></heading><paragraph><template><target>main</target><arg>Exponential search</arg></template></paragraph><paragraph>An exponential search (also called a<space/><bold>one-sided search</bold>) searches from a starting point within the array and either expects that the element<space/><extension extension_name='math'>p</extension><space/>being sought is nearby or the upper (lower) bound on the array is unknown. Starting with a step size of 1 and doubling with each step, the method looks for a number &gt;= (&lt;=)<space/><extension extension_name='math'>p</extension>. Once the upper (lower) bound is found, then the method proceeds with a binary search. The complexity of the search is<space/><extension extension_name='math'>2 \lceil\log_2 n\rceil</extension><space/>if the sought element is in the<space/><italics>n</italics>th array position. This depends only on<space/><extension extension_name='math'>n</extension><space/>and not on the size of the array.</paragraph><heading level='3'>Interpolated search</heading><paragraph><template><target>main</target><arg>Interpolation search</arg></template></paragraph><paragraph>An interpolated search tries to guess the location of the element<space/><extension extension_name='math'>p</extension><space/>you're searching for, typically by calculating a midpoint based on the lowest and highest value and assuming a fairly even distribution of values.<space/><template><target>clarify</target><arg name="date">January 2015</arg><arg name="text">When<space/><math>p</math><space/>has been determined an exponential search is performed.</arg></template></paragraph><heading level='2'>Implementation issues</heading><paragraph><extension extension_name='blockquote'>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky<space/><link><target>Donald Knuth</target></link><extension extension_name='ref'><template><target>cite book</target><arg name="last"><space/>Knuth
</arg><arg name="first"><space/>Donald
</arg><arg name="authorlink"><space/>Donald Knuth
</arg><arg name="series"><space/>[[The Art of Computer Programming]]
</arg><arg name="volume"><space/>3
</arg><arg name="title"><space/>Sorting and Searching
</arg><arg name="chapter"><space/>Section 6.2.1: Searching an Ordered Table
</arg><arg name="edition"><space/>3rd
</arg><arg name="pages"><space/>409–426
</arg><arg name="publisher"><space/>[[Addison-Wesley]]
</arg><arg name="year"><space/>1997
</arg><arg name="isbn"><space/>0-201-89685-0</arg></template></extension></extension>When<space/><link><target>Jon Bentley</target></link><space/>assigned it as a problem in a course for professional programmers, he found that an astounding ninety percent failed to code a binary search correctly after several hours of working on it,<extension extension_name='ref'><template><target>cite book</target><arg name="last"><space/>Bentley
</arg><arg name="first"><space/>Jon
</arg><arg name="authorlink"><space/>Jon Bentley
</arg><arg name="title"><space/>Programming Pearls
</arg><arg name="edition"><space/>2nd
</arg><arg name="page"><space/>341
</arg><arg name="publisher"><space/>[[Addison-Wesley]]
</arg><arg name="year"><space/>2000
</arg><arg name="origyear"><space/>1986
</arg><arg name="isbn"><space/>0-201-65788-0</arg></template></extension><space/>and another study shows that accurate code for it is only found in five out of twenty textbooks.<extension extension_name='ref'><template><target>cite journal</target><arg name="first"><space/>Richard E.<space/></arg><arg name="last"><space/>Pattis<space/></arg><arg name="doi"><space/>10.1145/52965.53012<space/></arg><arg name="title"><space/>Textbook errors in binary searching<space/></arg><arg name="journal"><space/>[[SIGCSE]] Bulletin<space/></arg><arg name="volume"><space/>20<space/></arg><arg name="year"><space/>1988<space/></arg><arg name="pages"><space/>190–194<space/></arg></template><space/>cited at<space/><template><target>cite book</target><arg name="last"><space/>Kruse
</arg><arg name="first"><space/>Robert
</arg><arg name="title"><space/>Data Structures and Program Design in C++
</arg><arg name="page"><space/>280
</arg><arg name="publisher"><space/>[[Prentice Hall]]
</arg><arg name="year"><space/>1998
</arg><arg name="isbn"><space/>0-13-768995-0</arg></template></extension><space/>Furthermore, Bentley's own implementation of binary search, published in his 1986 book<space/><italics>Programming Pearls</italics>, contains an error that remained undetected for over twenty years.<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html<space/></arg><arg name="title"><space/>Extra, Extra – Read All About It: Nearly All Binary Searches and Mergesorts are Broken<space/></arg><arg name="work"><space/>Google Research Blog<space/></arg><arg name="first"><space/>Joshua<space/></arg><arg name="last"><space/>Bloch<space/></arg><arg name="date"><space/>June 2, 2006<space/></arg><arg name="origyear"><space/>Updated 17 Feb 2008<space/></arg></template></extension></paragraph><heading level='3'>Arithmetic</heading><paragraph>In a practical implementation, the variables used to represent the indices will often be of finite size, hence only capable of representing a finite range of values. For example, 32-bit<space/><link><target>signedness</target><part>unsigned integers</part></link><space/>can only hold values from 0 to 4294967295. 32-bit signed integers can only hold values from -2147483648 to 2147483647. If the binary search algorithm is to operate on large arrays, this has three implications:</paragraph><list type='bullet'><listitem>The values<space/><xhtml:code>first 1</xhtml:code><space/>and<space/><xhtml:code>last + 1</xhtml:code><space/>must both be representable within the finite bounds of the chosen integer type . Therefore, continuing the 32-bit unsigned example, the largest value that<space/><xhtml:code>last</xhtml:code><space/>may take is +429496729<bold>4</bold>, not +429496729<bold>5</bold>. A problem exists even for the &quot;inclusive&quot; form of the method, as if<space/><xhtml:code>x &gt; A(4294967295).Key</xhtml:code>, then on the final iteration the algorithm will attempt to store 4294967296 into<space/><xhtml:code>L</xhtml:code><space/>and fail. Equivalent issues apply to the lower limit, where<space/><xhtml:code>first 1</xhtml:code><space/>could become negative as when the first element of the array is at index zero.</listitem><listitem>If the midpoint of the span is calculated as<space/><xhtml:code>p := (L + R)/2</xhtml:code>, then the value<space/><xhtml:code>(L + R)</xhtml:code><space/>will exceed the number range if<space/><xhtml:code>last</xhtml:code><space/>is greater than (for unsigned) 4294967295/2 or (for signed) 2147483647/2 and the search wanders toward the upper end of the search space. This can be avoided by performing the calculation as<space/><xhtml:code>p := (R - L)/2 + L</xhtml:code>. For example, this bug existed in Java SDK at<space/><xhtml:code>Arrays.binarySearch()</xhtml:code><space/>from 1.2 to 5.0 and was fixed in 6.0.<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://bugs.sun.com/bugdatabase/view_bug.do?bug_id</arg><arg name="title"><space/>Bug ID: 5045582 (coll) binarySearch() fails for size larger than 1<<30<space/></arg><arg name="date"><space/>11 May 2004<space/></arg><arg name="publisher"><space/>[[Oracle Corporation|Oracle]]<space/></arg><arg name="work"><space/>Java Bug Database<space/></arg></template></extension><space/>However, if the binary search is over a range of numbers that includes large negative numbers (e.g. if the basic binary search technique is applied in areas other than searching an array), neither<space/><xhtml:code>(R + L)/2</xhtml:code><space/>nor<space/><xhtml:code>(R - L)/2 + L</xhtml:code><space/>will be always correct in a language with fixed-width integers.</listitem><listitem>KEY_NOT_FOUND must be a valid value of the return type, but this value can never be an index of the array</listitem></list><heading level='2'>Language support</heading><paragraph>Many standard libraries provide a way to do a binary search:</paragraph><list type='bullet'><listitem><link><target>C (programming language)</target><part>C</part></link><space/>provides the algorithm function<space/><xhtml:code>bsearch()</xhtml:code><space/>in its<space/><link><target>C standard library</target><part>standard library</part></link>.</listitem><listitem><link><target>C++</target></link>'s<space/><link><target>Standard Template Library</target><part>STL</part></link><space/>provides the<space/><link><target>algorithm function</target><trail>s</trail></link><space/><xhtml:code>binary_search()</xhtml:code>,<space/><xhtml:code>lower_bound()</xhtml:code><space/>and<space/><xhtml:code>upper_bound()</xhtml:code>.</listitem><listitem><link><target>Java (programming language)</target><part>Java</part></link><space/>offers a set of<space/><link><target>function overloading</target><part>overload</part><trail>ed</trail></link><space/><xhtml:code>binarySearch()</xhtml:code><space/>static methods in the classes<space/><template><target>Javadoc:SE</target><arg>java/util</arg><arg>Arrays</arg></template><space/>and<space/><template><target>Javadoc:SE</target><arg>java/util</arg><arg>Collections</arg></template><space/>in the standard<space/><xhtml:code>java.util</xhtml:code><space/>package for performing binary searches on Java arrays and on<space/><xhtml:code>List</xhtml:code>s, respectively. They must be arrays of primitives, or the arrays or Lists must be of a type that implements the<space/><xhtml:code>Comparable</xhtml:code><space/>interface, or you must specify a custom<space/><xhtml:code>Comparator</xhtml:code><space/>object.</listitem><listitem><link><target>Microsoft</target></link>'s<space/><link><target>.NET Framework</target></link><space/>2.0 offers static<space/><link><target>generic programming</target><part>generic</part></link><space/>versions of the binary search algorithm in its collection base classes. An example would be<space/><xhtml:code>System.Array</xhtml:code>'s method<space/><xhtml:code>BinarySearch&lt;T&gt;(T[] array, T value)</xhtml:code>.</listitem><listitem><link><target>Python (programming language)</target><part>Python</part></link><space/>provides the<space/><xhtml:code><link type='external' href='https://docs.python.org/library/bisect.html'>bisect</link></xhtml:code><space/>module.</listitem><listitem><link><target>COBOL</target></link><space/>can perform binary search on internal tables using the<space/><xhtml:code>SEARCH ALL</xhtml:code><space/>statement.</listitem><listitem><link><target>Perl</target></link><space/>can perform a generic binary search using the<space/><link><target>CPAN</target></link><space/>module List::BinarySearch.<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>https://metacpan.org/module/List::BinarySearch<space/></arg><arg name="publisher"><space/>[[CPAN]]<space/></arg><arg name="title"><space/>List::BinarySearch<space/></arg></template></extension></listitem><listitem><link><target>Ruby (programming language)</target><part>Ruby</part></link>'s Array class has included a<space/><xhtml:code><link type='external' href='http://www.ruby-doc.org/core-2.0.0/Array.html#method-i-bsearch'>bsearch</link></xhtml:code><space/>method since version 2.0.0.</listitem><listitem><link><target>Go (programming language)</target><part>Go</part></link>'s<space/><xhtml:code>sort</xhtml:code><space/>standard library package contains the functions<space/><xhtml:code>Search</xhtml:code>,<space/><xhtml:code>SearchInts</xhtml:code>,<space/><xhtml:code>SearchFloat64s</xhtml:code>, and<space/><xhtml:code>SearchStrings</xhtml:code>, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.<extension extension_name='ref'><template><target>cite web</target><arg name="work"><space/>The Go Programming Language<space/></arg><arg name="url"><space/>http://golang.org/pkg/sort/<space/></arg><arg name="title"><space/>Package sort<space/></arg></template></extension></listitem><listitem>For<space/><link><target>Objective-C</target></link>, the<space/><link><target>Cocoa (API)</target><part>Cocoa</part></link><space/>framework provides the<space/><link type='external' href='http://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html#//apple_ref/occ/instm/NSArray/indexOfObject:inSortedRange:options:usingComparator:'>NSArray -indexOfObject:inSortedRange:options:usingComparator:</link><space/>method in Mac OS X 10.6+. Apple's<space/><link><target>Core Foundation</target></link><space/>C framework also contains a<space/><link type='external' href='http://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFArrayRef/Reference/reference.html#//apple_ref/c/func/CFArrayBSearchValues'>CFArrayBSearchValues()</link><space/>function.</listitem></list><heading level='2'>See also</heading><paragraph><template><target>Portal</target><arg>Computer science</arg></template></paragraph><list type='bullet'><listitem><link><target>Interpolation search</target></link>, similar method with better average complexity</listitem><listitem><link><target>Index (database)</target><part>Index (information technology)</part></link>, very fast 'lookup' using an index to directly select an entry</listitem><listitem><link><target>Branch table</target></link>, alternative indexed 'lookup' method for decision making</listitem><listitem><link><target>Self-balancing binary search tree</target></link></listitem><listitem><link><target>Run-time analysis</target></link>, illustrating binary search method on machines of differing speeds</listitem><listitem><link><target>Bisection method</target></link>, the same idea used to solve equations in the real numbers</listitem></list><heading level='2'>References</heading><paragraph><template><target>Reflist</target><arg>30em</arg></template></paragraph><heading level='3'>Other sources</heading><list type='bullet'><listitem>Kruse, Robert L.: &quot;Data Structures and Program Design in C++&quot;, Prentice-Hall, 1999, ISBN 0-13-768995-0, page 280.</listitem><listitem><template><target>cite web</target><arg name="first1"><space/>Netty<space/></arg><arg name="last1"><space/>van Gasteren<space/></arg><arg name="first2"><space/>Wim<space/></arg><arg name="last2"><space/>Feijen<space/></arg><arg name="url"><space/>http://www.mathmeth.com/wf/files/wf2xx/wf214.pdf<space/></arg><arg name="format"><space/>PDF<space/></arg><arg name="title"><space/>The Binary Search Revisited<space/></arg><arg name="work"><space/>AvG127/WF214<space/></arg><arg name="year"><space/>1995<space/></arg></template><space/>(investigates the foundations of the binary search, debunking the myth that it applies only to sorted arrays)</listitem></list><heading level='2'>External links</heading><paragraph><template><target>Wikibooks</target><arg>Algorithm implementation</arg><arg>Search/Binary search</arg><arg>Binary search</arg></template></paragraph><list type='bullet'><listitem><link type='external' href='http://www.nist.gov/dads/HTML/binarySearch.html'>NIST Dictionary of Algorithms and Data Structures: binary search</link></listitem><listitem><link type='external' href='http://www.codecodex.com/wiki/Binary_search'>Binary search implemented in 12 languages</link></listitem><listitem><link type='external' href='http://codeabbey.com/index/wiki/binary-search'>Binary search casual examples - dictionary, array and monotonic function</link></listitem><listitem><link type='external' href='https://sites.google.com/site/binarysearchcube/binary-search'>Benchmark of 7 binary search variants implemented in C</link></listitem></list><paragraph><template><target>DEFAULTSORT:Binary Search Algorithm</target></template><link><target>Category:Search algorithms</target></link></paragraph></article>