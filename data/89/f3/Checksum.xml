<article title='Checksum'><paragraph><template><target>Refimprove</target><arg name="date">August 2012</arg></template><link><target>File:Checksum.svg</target><part>thumb</part><part>330px</part><part>right</part><part>Effect of a typical checksum function (the Unix<space/><xhtml:tt><link><target>cksum</target></link></xhtml:tt><space/>utility)</part></link></paragraph><paragraph>A<space/><bold>checksum</bold><space/>or<space/><bold>hash sum</bold><space/>is a small-size datum from a block of<space/><link><target>digital data</target></link><space/>for the purpose of<space/><link><target>error detection</target><part>detecting errors</part></link><space/>which may have been introduced during its<space/><link><target>telecommunication</target><part>transmission</part></link><space/>or<space/><link><target>computer storage</target><part>storage</part></link>. It is usually applied to an installation file after it is received from the download server. By themselves checksums are often used to verify data integrity, but should not be relied upon to also verify data<space/><link><target>authentication</target><part>authenticity</part></link>.<space/></paragraph><paragraph>The actual<space/><link><target>algorithm</target><part>procedure</part></link><space/>which yields the checksum, given a data input is called a<space/><bold>checksum function</bold><space/>or<space/><bold><link><target>checksum algorithm</target></link></bold>. Depending on its design goals, a good checksum algorithm will usually output a significantly different value, even for small changes made to the input. This is especially true of<space/><link><target>cryptographic hash function</target><trail>s</trail></link>, which may be used to detect many data corruption errors and verify overall<space/><link><target>data integrity</target></link>; if the computed checksum for the current data input matches the stored value of a previously computed checksum, there is a very high probability the data has not been accidentally altered or corrupted.</paragraph><paragraph>Checksum functions are related to<space/><link><target>hash function</target><trail>s</trail></link>,<space/><link><target>fingerprint (computing)</target><part>fingerprint</part><trail>s</trail></link>,<space/><link><target>randomization function</target><trail>s</trail></link>, and<space/><link><target>cryptographic hash function</target><trail>s</trail></link>. However, each of those concepts has different applications and therefore different design goals. Checksums are used as cryptographic primitives in larger authentication algorithms. For cryptographic systems with these two specific design goals, see<space/><link><target>HMAC</target></link>.</paragraph><paragraph><link><target>Check digit</target><trail>s</trail></link><space/>and<space/><link><target>parity bit</target><trail>s</trail></link><space/>are special cases of checksums, appropriate for small blocks of data (such as<space/><link><target>Social Security number</target><trail>s</trail></link>,<space/><link><target>bank account</target></link><space/>numbers,<space/><link><target>Word (data type)</target><part>computer word</part><trail>s</trail></link>, single<space/><link><target>byte</target><trail>s</trail></link>, etc.). Some<space/><link><target>error-correcting code</target><trail>s</trail></link><space/>are based on special checksums which not only detect common errors but also allow the original data to be recovered in certain cases.</paragraph><heading level='2'>Checksum algorithms</heading><heading level='3'>Parity byte or parity word</heading><paragraph>The simplest checksum algorithm is the so-called<space/><link><target>longitudinal redundancy check</target><part>longitudinal parity check</part></link>, which breaks the data into &quot;words&quot; with a fixed number<space/><italics>n</italics><space/>of bits, and then computes the<space/><link><target>exclusive or</target></link><space/>of all those words. The result is appended to the message as an extra word.To check the integrity of a message, the receiver computes the exclusive or (XOR) of all its words, including the checksum; if the result is not a word with<space/><italics>n</italics><space/>zeros, the receiver knows a transmission error occurred.</paragraph><paragraph>With this checksum, any transmission error which flips a single bit of the message, or an odd number of bits, will be detected as an incorrect checksum. However, an error which affects two bits will not be detected if those bits lie at the same position in two distinct words. Also swapping of two or more words will not be detected. If the affected bits are independently chosen at random, the probability of a two-bit error being undetected is 1/<italics>n</italics>.</paragraph><heading level='3'>Modular sum</heading><paragraph>A variant of the previous algorithm is to add all the &quot;words&quot; as unsigned binary numbers, discarding any overflow bits, and append the<space/><link><target>two's complement</target></link><space/>of the total as the checksum. To validate a message, the receiver adds all the words in the same manner, including the checksum; if the result is not a word full of zeros, an error must have occurred. This variant too detects any single-bit error, but the promodular sum is used in<space/><link><target>J1708</target><part>SAE J1708</part></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.kvaser.com/zh/about-can/related-protocols-and-standards/50.html<space/></arg><arg name="title">SAE J1708<space/></arg><arg name="publisher">Kvaser.com<space/></arg><arg name="archiveurl">http://web.archive.org/web/20131211152639/http://www.kvaser.com/zh/about-can/related-protocols-and-standards/50.html<space/></arg><arg name="archivedate">{{date|2013-12-11}}<space/></arg></template></extension></paragraph><heading level='3'>Position-dependent checksums</heading><paragraph>The simple checksums described above fail to detect some common errors which affect many bits at once, such as changing the order of data words, or inserting or deleting words with all bits set to zero. The checksum algorithms most used in practice, such as<space/><link><target>Fletcher's checksum</target></link>,<space/><link><target>Adler-32</target></link>, and<space/><link><target>cyclic redundancy check</target><trail>s</trail></link><space/>(CRCs), address these weaknesses by considering not only the value of each word but also its position in the sequence. This feature generally increases the<space/><link><target>Analysis of algorithms</target><part>cost</part></link><space/>of computing the checksum.</paragraph><heading level='3'>General considerations</heading><paragraph>A single-bit transmission error then corresponds to a displacement from a valid corner (the correct message and checksum) to one of the<space/><italics>m</italics><space/>adjacent corners. An error which affects<space/><italics>k</italics><space/>bits moves the message to a corner which is<space/><italics>k</italics><space/>steps removed from its correct corner. The goal of a good checksum algorithm is to spread the valid corners as far from each other as possible, so as to increase the likelihood &quot;typical&quot; transmission errors will end up in an invalid corner.</paragraph><heading level='2'>See also</heading><paragraph>General topic</paragraph><list type='bullet'><listitem><link><target>Algorithm</target></link></listitem><listitem><link><target>Data degradation</target><part>Bit rot</part></link></listitem><listitem><link><target>Check digit</target></link></listitem><listitem><link><target>Damm algorithm</target></link></listitem><listitem><link><target>File verification</target></link></listitem><listitem><link><target>Fletcher's checksum</target></link></listitem><listitem><link><target>Frame check sequence</target></link></listitem><listitem><link><target>cksum</target></link></listitem><listitem><link><target>md5sum</target></link></listitem><listitem><link><target>sha1sum</target></link></listitem><listitem><link><target>Parchive</target></link></listitem><listitem><link><target>Sum (Unix)</target><part>sum</part></link></listitem><listitem><link><target>SYSV checksum</target></link></listitem><listitem><link><target>BSD checksum</target></link></listitem></list><paragraph>Error correction</paragraph><list type='bullet'><listitem><link><target>Hamming code</target></link></listitem><listitem><link><target>IPv4 header checksum</target></link></listitem></list><paragraph>Hash functions</paragraph><list type='bullet'><listitem><link><target>List of hash functions</target></link></listitem><listitem><link><target>Luhn algorithm</target></link></listitem><listitem><link><target>Parity bit</target></link></listitem><listitem><link><target>Rolling checksum</target></link></listitem><listitem><link><target>Verhoeff algorithm</target></link></listitem><listitem><link><target>ZFS</target></link>&amp;nbsp; a file system which performs automatic file integrity checking using checksums</listitem></list><heading level='2'>References</heading><paragraph><template><target>reflist</target></template></paragraph><heading level='2'>External links</heading><paragraph><template><target>wikibooks</target><arg name="1"><space/>Algorithm Implementation
<space/></arg><arg name="2"><space/>Checksums
</arg></template></paragraph><list type='bullet'><listitem><link type='external' href='http://www.netrino.com/Embedded-Systems/How-To/Additive-Checksums'>Additive Checksums (C)</link><space/>theory from Barr Group</listitem><listitem><link type='external' href='http://hashingapp.github.io'>Hashing</link><space/>- Standalone hashing application for Windows that let's you hash multiple files</listitem><listitem><link type='external' href='http://corz.org/windows/software/checksum'>checksum</link>, a fast file, folder and drive hashing application for<space/><link><target>Microsoft Windows</target><part>Windows</part></link>, which computes MD5, SHA-1 and BLAKE2 hashes.</listitem><listitem><link type='external' href='http://compressme.net/'>CHK Checksum Utility</link><space/>- an advanced checksum tool</listitem><listitem><link type='external' href='http://filechecksumutility.sourceforge.net/'>File Checksum Utility</link><space/>- Calculate MD5, SHA1, SHA256 and SHA512 Hashes</listitem><listitem><link type='external' href='http://support.microsoft.com/kb/841290'>MD5 and SHA-1 tool</link><space/>from Microsoft.com<space/></listitem><listitem><link type='external' href='http://www.jonelo.de/java/jacksum/index.html'>Jacksum</link>, is a<space/><link><target>Java (software platform)</target><part>Java</part></link>-based application that supports a large number of algorithms for computing and verifying checksums, CRCs and message digests<space/></listitem><listitem><link type='external' href='http://rhash.anz.ru/'>RHash</link>, a<space/><link><target>C (programming language)</target><part>C</part></link>-based application which supports<space/><italics>recursion</italics><space/>and many other unique features<space/></listitem><listitem><link type='external' href='http://code.google.com/p/jdigest/'>jdigest</link>, a<space/><link><target>Java (software platform)</target><part>Java</part></link>-based tool from Google which works<space/><link><target>MD5</target></link><space/>and<space/><link><target>Secure Hash Algorithm</target><part>SHA</part></link><space/>sums for Windows via right-clicking</listitem><listitem><link type='external' href='http://www.richherrick.com/software/hash/index.html'>Hash Generator and Validation Tool (Hash)</link>, a command-prompt utility which will generate/validate several types of hash values for multiple files and directory trees.</listitem></list><paragraph><link><target>Category:Checksum algorithms</target><part>*</part></link></paragraph></article>