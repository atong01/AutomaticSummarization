<article title='Database_normalization'><paragraph><bold>Database normalization</bold><space/>(or<space/><bold>normalisation</bold>) is the process of organizing the<space/><link><target>column (database)</target><part>columns</part></link><space/>(attributes) and<space/><link><target>table (database)</target><part>table</part><trail>s</trail></link><space/>(relations) of a<space/><link><target>relational database</target></link><space/>to minimize<space/><link><target>data redundancy</target></link>.</paragraph><paragraph>Normalization involves decomposing a table into less redundant (and smaller) tables without losing information; defining<space/><link><target>Foreign Key</target><part>foreign key</part><trail>s</trail></link><space/>in the old table referencing the<space/><link><target>Primary Key</target><part>primary key</part><trail>s</trail></link><space/>of the new ones. The objective is to isolate data so that additions, deletions, and modifications of an attribute can be made in just one table and then propagated through the rest of the database using the defined foreign keys.</paragraph><paragraph><link><target>Edgar F. Codd</target></link>, the inventor of the<space/><link><target>relational model</target></link><space/>(RM), introduced the concept of normalization and what we now know as the<space/><link><target>First normal form</target></link><space/>(1NF) in 1970.<extension extension_name='ref' name="Codd1970"><template><target>cite journal</target><arg name="first">E. F.</arg><arg name="last">Codd</arg><arg name="authorlink">E.F. Codd</arg><arg name="title">A Relational Model of Data for Large Shared Data Banks</arg><arg name="journal">[[Communications of the ACM]]</arg><arg name="volume">13</arg><arg name="issue">6</arg><arg name="date">June 1970</arg><arg name="pages">377â€“387</arg><arg name="url">http://www.acm.org/classics/nov95/toc.html<space/></arg><arg name="doi"><space/>10.1145/362384.362685</arg></template></extension><space/>Codd went on to define the<space/><link><target>Second normal form</target></link><space/>(2NF) and<space/><link><target>Third normal form</target></link><space/>(3NF) in 1971,<extension extension_name='ref' name="Codd, E.F 1971">Codd, E.F. &quot;Further Normalization of the Data Base Relational Model&quot;. (Presented at Courant Computer Science Symposia Series 6, &quot;Data Base Systems&quot;, New York City, May 2425, 1971.) IBM Research Report RJ909 (August 31, 1971). Republished in Randall J. Rustin (ed.),<space/><italics>Data Base Systems: Courant Computer Science Symposia Series 6</italics>. Prentice-Hall, 1972.</extension><space/>and Codd and<space/><link><target>Raymond F. Boyce</target></link><space/>defined the Boyce-Codd Normal Form (<link><target>BoyceCodd normal form</target><part>BCNF</part></link>) in 1974.<extension extension_name='ref' name="CoddBCNF">Codd, E. F. &quot;Recent Investigations into Relational Data Base Systems&quot;. IBM Research Report RJ1385 (April 23, 1974). Republished in<space/><italics>Proc. 1974 Congress</italics><space/>(Stockholm, Sweden, 1974). , N.Y.: North-Holland (1974).</extension><space/>Informally, a relational database table is often described as &quot;normalized&quot; if it meets Third Normal Form.<extension extension_name='ref' name="DateIntroDBSys">C.J. Date.<space/><italics>An Introduction to Database Systems</italics>. Addison-Wesley (1999), p. 290</extension><space/>Most 3NF tables are free of insertion, update, and deletion anomalies.</paragraph><paragraph>The relational model separates the<space/><link><target>logical design</target></link><space/>from the<space/><link><target>Database design#Physical database design</target><part>physical design</part></link>:<space/><link><target>DBMS</target></link><space/>performance is a matter of physical design using indexes, view materialization, big buffers, etc. It is not a matter of changing the logical design.</paragraph><paragraph>A typical example of normalization is that an entity's<space/><link><target>Unique identifier</target><part>unique ID</part></link><space/>is stored everywhere in the system but its name is held in only one table. The name can be updated more easily in one row of one table. A typical update in such an example would be the RIM company changing its name to BlackBerry.<extension extension_name='ref' name="EXAMPLE"><template><target>cite web</target><arg name="last1">Reed</arg><arg name="first1">B</arg><arg name="title">RIM changes its name to BlackBerry</arg><arg name="url">http://bgr.com/2013/01/30/rblackberry-z10-q10-announce-311920/</arg><arg name="website">BGR.com</arg><arg name="accessdate">2014-06-03</arg></template></extension><space/>That update would be done in one place and immediately the correct &quot;BlackBerry&quot; name would be displayed throughout the system.</paragraph><heading level='2'>Objectives</heading><paragraph>A basic objective of the<space/><link><target>first normal form</target></link><space/>defined by Codd in 1970 was to permit data to be queried and manipulated using a &quot;universal data sub-language&quot; grounded in<space/><link><target>first-order logic</target></link>.<extension extension_name='ref'>&quot;The adoption of a relational model of data ... permits the development of a universal data sub-language based on an applied predicate calculus. A first-order predicate calculus suffices if the collection of relations is in first normal form. Such a language would provide a yardstick of linguistic power for all other proposed data languages, and would itself be a strong candidate for embedding (with appropriate syntactic modification) in a variety of host Ianguages (programming, command- or problem-oriented).&quot; Codd,<space/><link type='external' href='http://www.acm.org/classics/nov95/toc.html'>&quot;A Relational Model of Data for Large Shared Data Banks&quot;</link>, p. 381</extension><space/>(<link><target>SQL</target></link><space/>is an example of such a data sub-language, albeit one that Codd regarded as seriously flawed.)<extension extension_name='ref'>Codd, E.F. Chapter 23, &quot;Serious Flaws in SQL&quot;, in<space/><italics>The Relational Model for Database Management: Version 2</italics>. Addison-Wesley (1990), pp. 371389</extension></paragraph><paragraph>The objectives of normalization beyond 1NF (First Normal Form) were stated as follows by Codd:</paragraph><paragraph><template><target>Quotation</target><arg>
:1. To free the collection of relations from undesirable insertion, update and deletion dependencies;
:2. To reduce the need for restructuring the collection of relations, as new types of data are introduced, and thus increase the life span of application programs;
:3. To make the relational model more informative to users;
:4. To make the collection of relations neutral to the query statistics, where these statistics are liable to change as time goes by.
</arg><arg>E.F. Codd</arg><arg>"Further Normalization of the Data Base Relational Model"<ref>Codd, E.F. "Further Normalization of the Data Base Relational Model", p. 34</ref></arg></template></paragraph><paragraph>The sections below give details of each of these objectives.</paragraph><heading level='3'>Free the database of modification anomalies</heading><paragraph><link><target>File:Update anomaly.svg</target><part>280px</part><part>thumb</part><part>right</part><part>An '''update anomaly'''. Employee 519 is shown as having different addresses on different records.</part></link><link><target>File:Insertion anomaly.svg</target><part>280px</part><part>thumb</part><part>right</part><part>An '''insertion anomaly'''. Until the new faculty member, Dr. Newsome, is assigned to teach at least one course, his details cannot be recorded.</part></link><link><target>File:Deletion anomaly.svg</target><part>280px</part><part>thumb</part><part>right</part><part>A '''deletion anomaly'''. All information about Dr. Giddens is lost if he temporarily ceases to be assigned to any courses.</part></link>When an attempt is made to modify (update, insert into, or delete from) a table, undesired side-effects may arise in tables that have not been sufficiently normalized. An insufficiently normalized table might have one or more of the following characteristics:</paragraph><list type='bullet'><listitem>The same information can be expressed on multiple rows; therefore updates to the table may result in logical inconsistencies. For example, each record in an &quot;Employees' Skills&quot; table might contain an Employee ID, Employee Address, and Skill; thus a change of address for a particular employee will potentially need to be applied to multiple records (one for each skill). If the update is not carried through successfullyif, that is, the employee's address is updated on some records but not othersthen the table is left in an inconsistent state. Specifically, the table provides conflicting answers to the question of what this particular employee's address is. This phenomenon is known as an<space/><bold>update anomaly</bold>.</listitem><listitem>There are circumstances in which certain facts cannot be recorded at all. For example, each record in a &quot;Faculty and Their Courses&quot; table might contain a Faculty ID, Faculty Name, Faculty Hire Date, and Course Codethus we can record the details of any faculty member who teaches at least one course, but we cannot record the details of a newly hired faculty member who has not yet been assigned to teach any courses except by setting the Course Code to null. This phenomenon is known as an<space/><bold>insertion anomaly</bold>.</listitem><listitem>Under certain circumstances, deletion of data representing certain facts necessitates deletion of data representing completely different facts. The &quot;Faculty and Their Courses&quot; table described in the previous example suffers from this type of anomaly, for if a faculty member temporarily ceases to be assigned to any courses, we must delete the last of the records on which that faculty member appears, effectively also deleting the faculty member, unless we set the Course Code to null in the record itself. This phenomenon is known as a<space/><bold>deletion anomaly</bold>.</listitem></list><heading level='3'>Minimize redesign when extending the database structure</heading><paragraph>When a fully normalized database structure is extended to allow it to accommodate new types of data, the pre-existing aspects of the database structure can remain largely or entirely unchanged. As a result, applications interacting with the database are minimally affected.</paragraph><paragraph>Normalized tables, and the relationship between one normalized table and another, mirror real-world concepts and their interrelationships.</paragraph><heading level='3'>Avoid bias towards any particular pattern of querying</heading><paragraph>Normalized tables are suitable for general-purpose querying. This means any queries against these tables, including future queries whose details cannot be anticipated, are supported. In contrast, tables that are not normalized lend themselves to some types of queries, but not others.</paragraph><paragraph>For example, consider an online bookseller whose customers maintain wishlists of books they'd like to have. For the obvious, anticipated querywhat books does this customer want?it's enough to store the customer's wishlist in the table as, say, a homogeneous string of authors and titles.</paragraph><paragraph>With this design, though, the database can answer only that one single query. It cannot by itself answer interesting but unanticipated queries: What is the most-wished-for book? Which customers are interested in WWII espionage? How does Lord Byron stack up against his contemporary poets? Answers to these questions must come from special adaptive tools completely separate from the database. One tool might be software written especially to handle such queries. This special adaptive software has just one single purpose: in effect to normalize the non-normalized attribute.</paragraph><paragraph>Unforeseen queries can be answered trivially, and entirely within the database framework, with a normalized table.</paragraph><heading level='3'>Example</heading><paragraph>Querying and manipulating the data within a data structure that is not normalized, such as the following non-1NF representation of customers' credit card transactions, involves more complexity than is really necessary:</paragraph><table class="wikitable"><tablerow><tablehead>Customer</tablehead><tablehead>Transactions</tablehead></tablerow><tablerow><tablecell>Jones</tablecell><tablecell><paragraph>|<space/></paragraph><table class="wikitable"><tablerow><tablehead>Tr. ID</tablehead><tablehead>Date</tablehead><tablehead>Amount</tablehead></tablerow><tablerow><tablecell>12890</tablecell><tablecell>14-Oct-2003</tablecell><tablecell>&amp;minus;87</tablecell></tablerow><tablerow><tablecell>12904</tablecell><tablecell>15-Oct-2003</tablecell><tablecell>&amp;minus;50</tablecell></tablerow></table></tablecell></tablerow><tablerow><tablecell>Wilkinson</tablecell><tablecell><paragraph>|<space/></paragraph><table class="wikitable"><tablerow><tablehead>Tr. ID</tablehead><tablehead>Date</tablehead><tablehead>Amount</tablehead></tablerow><tablerow><tablecell>12898</tablecell><tablecell>14-Oct-2003</tablecell><tablecell>&amp;minus;21</tablecell></tablerow></table></tablecell></tablerow><tablerow><tablecell>Stevens</tablecell><tablecell><paragraph>|<space/></paragraph><table class="wikitable"><tablerow><tablehead>Tr. ID</tablehead><tablehead>Date</tablehead><tablehead>Amount</tablehead></tablerow><tablerow><tablecell>12907</tablecell><tablecell>15-Oct-2003</tablecell><tablecell>&amp;minus;18</tablecell></tablerow><tablerow><tablecell>14920</tablecell><tablecell>20-Nov-2003</tablecell><tablecell>&amp;minus;70</tablecell></tablerow><tablerow><tablecell>15003</tablecell><tablecell>27-Nov-2003</tablecell><tablecell>&amp;minus;60</tablecell></tablerow></table></tablecell></tablerow></table><paragraph><xhtml:br></xhtml:br>To each customer corresponds a<space/><italics>repeating group</italics><space/>of transactions. The automated evaluation of any query relating to customers' transactions therefore would broadly involve two stages:</paragraph><list type='numbered'><listitem>Unpacking one or more customers' groups of transactions allowing the individual transactions in a group to be examined, and</listitem><listitem>Deriving a query result based on the results of the first stage</listitem></list><paragraph>For example, in order to find out the monetary sum of all transactions that occurred in October 2003 for all customers, the system would have to know that it must first unpack the<space/><italics>Transactions</italics><space/>group of each customer, then sum the<space/><italics>Amounts</italics><space/>of all transactions thus obtained where the<space/><italics>Date</italics><space/>of the transaction falls in October 2003.</paragraph><paragraph>One of Codd's important insights was that this structural complexity could always be removed completely, leading to much greater power and flexibility in the way queries could be formulated (by<space/><link><target>user (computing)</target><part>users</part></link><space/>and<space/><link><target>application software</target><part>applications</part></link>) and evaluated (by the<space/><link><target>database management system</target><part>DBMS</part></link>). The normalized equivalent of the structure above would look like this:</paragraph><table class="wikitable"><tablerow><tablehead>Customer</tablehead><tablehead>Cust. ID</tablehead></tablerow><tablerow><tablecell>Jones</tablecell><tablecell>1</tablecell></tablerow><tablerow><tablecell>Wilkins</tablecell><tablecell>2</tablecell></tablerow><tablerow><tablecell>Stevens</tablecell><tablecell>3</tablecell></tablerow></table><table class="wikitable"><tablerow><tablehead>Cust. ID</tablehead><tablehead>Tr. ID</tablehead><tablehead>Date</tablehead><tablehead>Amount</tablehead></tablerow><tablerow><tablecell>1</tablecell><tablecell>12890</tablecell><tablecell>14-Oct-2003</tablecell><tablecell>&amp;minus;87</tablecell></tablerow><tablerow><tablecell>1</tablecell><tablecell>12904</tablecell><tablecell>15-Oct-2003</tablecell><tablecell>&amp;minus;50</tablecell></tablerow><tablerow><tablecell>2</tablecell><tablecell>12898</tablecell><tablecell>14-Oct-2003</tablecell><tablecell>&amp;minus;21</tablecell></tablerow><tablerow><tablecell>3</tablecell><tablecell>12907</tablecell><tablecell>15-Oct-2003</tablecell><tablecell>&amp;minus;18</tablecell></tablerow><tablerow><tablecell>3</tablecell><tablecell>14920</tablecell><tablecell>20-Nov-2003</tablecell><tablecell>&amp;minus;70</tablecell></tablerow><tablerow><tablecell>3</tablecell><tablecell>15003</tablecell><tablecell>27-Nov-2003</tablecell><tablecell>&amp;minus;60</tablecell></tablerow></table><paragraph>Now each row represents an individual credit card transaction, and the DBMS can obtain the answer of interest, simply by finding all rows with a Date falling in October, and summing their Amounts. The data structure places all of the values on an equal footing, exposing each to the DBMS directly, so each can potentially participate directly in queries; whereas in the previous situation some values were embedded in lower-level structures that had to be handled specially. Accordingly, the normalized design lends itself to general-purpose query processing, whereas the unnormalized design does not. The normalized version also allows the user to change the customer name in one place and guards against errors that arise if the customer name is misspelled on some records.</paragraph><heading level='2'>List of Normal Forms</heading><list type='bullet'><listitem><link><target>First normal form</target><part>1NF - First Normal Form</part></link></listitem><listitem><link><target>Second normal form</target><part>2NF - Second Normal Form</part></link></listitem><listitem><link><target>Third normal form</target><part>3NF - Third Normal Form</part></link></listitem><listitem><link><target>BoyceCodd normal form</target><part>BCNF - BoyceCodd Normal Form</part></link></listitem><listitem><link><target>Fourth normal form</target><part>4NF - Fourth Normal Form</part></link></listitem><listitem><link><target>Fifth normal form</target><part>5NF - Fifth Normal Form</part></link></listitem><listitem><link><target>Sixth normal form</target><part>6NF - Sixth Normal Form</part></link></listitem><listitem><link><target>Domain/key normal form</target><part>DKNF - Domain/Key Normal Form</part></link></listitem></list><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Refactoring</target></link></listitem></list><heading level='2'>Notes and references</heading><paragraph><template><target>reflist</target><arg>2</arg></template><template><target>refbegin</target></template><template><target>refend</target></template></paragraph><heading level='2'>Further reading</heading><list type='bullet'><listitem><link type='external' href='http://www.troubleshooters.com/littstip/ltnorm.html'>Litt's Tips: Normalization</link></listitem><listitem>Date, C. J. (1999),<space/><italics><link type='external' href='http://www.aw-bc.com/catalog/academic/product/0,1144,0321197844,00.html'>An Introduction to Database Systems</link></italics><space/>(8th ed.). Addison-Wesley Longman. ISBN 0-321-19784-4.</listitem><listitem>Kent, W. (1983)<space/><italics><link type='external' href='http://www.bkent.net/Doc/simple5.htm'>A Simple Guide to Five Normal Forms in Relational Database Theory</link></italics>, Communications of the ACM, vol. 26, pp.&amp;nbsp;120125</listitem><listitem>H.-J. Schek, P. Pistor Data Structures for an Integrated Data Base Management and Information Retrieval System</listitem></list><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://databases.about.com/od/specificproducts/a/normalization.htm'>Database Normalization Basics</link><space/>by Mike Chapple (About.com)</listitem><listitem><link type='external' href='http://www.databasejournal.com/sqletc/article.php/1428511'>Database Normalization Intro</link>,<space/><link type='external' href='http://www.databasejournal.com/sqletc/article.php/26861_1474411_1'>Part 2</link></listitem><listitem><link type='external' href='http://mikehillyer.com/articles/an-introduction-to-database-normalization/'>An Introduction to Database Normalization</link><space/>by Mike Hillyer.</listitem><listitem><link type='external' href='http://phlonx.com/resources/nf3/'>A tutorial on the first 3 normal forms</link><space/>by Fred Coulson</listitem><listitem><link type='external' href='http://www.dbnormalization.com/'>DB Normalization Examples</link></listitem><listitem><link type='external' href='http://support.microsoft.com/kb/283878'>Description of the database normalization basics</link><space/>by Microsoft</listitem><listitem><link type='external' href='http://www.barrywise.com/2008/01/database-normalization-and-design-techniques/'>Database Normalization and Design Techniques</link><space/>by Barry Wise, recommended reading for the Harvard MIS.</listitem><listitem><link type='external' href='http://www.bkent.net/Doc/simple5.htm'>A Simple Guide to Five Normal Forms in Relational Database Theory</link></listitem><listitem><link type='external' href='http://beginnersbook.com/2015/05/normalization-in-dbms/'>Normalization in DBMS by Chaitanya (beginnersbook.com)</link></listitem></list><paragraph><template><target>Database normalization</target></template><template><target>Database</target></template><template><target>Databases</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Database Normalization</target></template><link><target>Category:Data management</target><part></part></link><link><target>Category:Data modeling</target></link><link><target>Category:Database constraints</target></link><link><target>Category:Database normalization</target><part></part></link><link><target>Category:Relational algebra</target></link></paragraph></article>