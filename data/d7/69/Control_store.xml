<article title='Control_store'><paragraph><template><target>Lead too short</target><arg name="date">August 2015</arg></template></paragraph><paragraph>A<space/><bold>control store</bold><space/>is the part of a<space/><link><target>Central processing unit</target><part>CPU's</part></link><space/><link><target>control unit</target></link><space/>that stores the CPU's<space/><link><target>microprogram</target></link>. It is usually accessed by a<space/><link><target>microsequencer</target></link>.</paragraph><heading level='2'>Implementation</heading><heading level='3'>Early use</heading><paragraph>Early control stores were implemented as a<space/><link><target>Diode matrix</target><part>diode-array</part></link><space/>accessed via address decoders, a form of<space/><link><target>read-only memory</target></link>. This tradition dates back to the<space/><italics>program timing matrix</italics><space/>on the<space/><link><target>MIT Whirlwind</target></link>, first described in 1947. Modern<space/><link><target>VLSI</target></link><space/>processors instead use matrices of<space/><link><target>field-effect transistor</target><trail>s</trail></link><space/>to build the<space/><link><target>Read-only memory</target><part>ROM</part></link><space/>and/or<space/><link><target>programmable logic array</target><part>PLA</part></link><space/>structures used to control the processor as well as its internal sequencer in a<space/><link><target>microcode</target><trail>d</trail></link><space/>implementation.</paragraph><heading level='3'>Writable stores</heading><paragraph>Some computers were built using &quot;writable microcode&quot; rather than storing the microcode in ROM or hard-wired logic, the microcode was stored in a RAM called a<space/><italics>writable control store</italics><space/>or<space/><italics>WCS</italics>. Such a computer is sometimes called a<space/><italics>Writable Instruction Set Computer</italics><space/>or<space/><italics>WISC</italics>.<extension extension_name='ref'><link type='external' href='http://www.ece.cmu.edu/~koopman/forth/rochester_87.pdf'>&quot;Writable instruction set, stack oriented computers: The WISC Concept&quot;</link><space/>article by Philip Koopman Jr. 1987</extension><space/>Many of these machines were experimental laboratory prototypes, such as the WISC CPU/16<extension extension_name='ref'><link type='external' href='http://www.ece.cmu.edu/~koopman/stack_computers/sec4_2.html'>&quot;Architecture of the WISC CPU/16&quot;</link><space/>by Phil Koopman 1989</extension><space/>and the RTX 32P.<extension extension_name='ref'><link type='external' href='http://www.ece.cmu.edu/~koopman/stack_computers/sec5_3.html'>&quot;Architecture of the RTX 32P&quot;</link><space/>by Philip Koopman 1989</extension></paragraph><paragraph>The original<space/><link><target>IBM System/360</target><part>System/360</part></link><space/>models of<space/><link><target>IBM mainframe</target></link><space/>had read-only control store, but later System/360,<space/><link><target>IBM System/370</target><part>System/370</part></link><space/>and successor models loaded part or all of their microprograms from floppy disks or other DASD into a writable control store consisting of ultra-high speed<space/><link><target>random-access memory</target><part>random-access</part></link><space/><link><target>read-write memory</target></link>. The System/370 architecture included a facility called<space/><bold>Initial-Microprogram Load</bold><space/>(<bold>IML</bold><space/>or<space/><bold>IMPL</bold>)<extension extension_name='ref'><template><target>cite manual</target><arg name="author"><space/>IBM
<space/></arg><arg name="title"><space/>IBM System/370 Principles of Operation
<space/></arg><arg name="id"><space/>GA22-7000-4
<space/></arg><arg name="version"><space/>Fourth Edition
<space/></arg><arg name="date"><space/>September 1974
<space/></arg><arg name="url"><space/>http://www.bitsavers.org/pdf/ibm/370/princOps/GA22-7000-4_370_Principles_Of_Operation_Sep75.pdf
<space/></arg><arg name="pages"><space/>98, 245
<space/></arg><arg name="mode">cs2
<space/></arg></template></extension><space/>that could be invoked from the console, as part of<space/><bold><link><target>Power-on reset#Power-on reset on IBM mainframes</target><part>Power On Reset</part></link></bold><space/>(<bold>POR</bold>) or from another processor in a<space/><link><target>Tightly coupled system</target><part>tightly coupled</part></link><space/><link><target>multiprocessor</target></link><space/>complex. This permitted IBM to easily repair microprogramming defects in the field. Even when the majority of the control store is stored in ROM of some sort, computer vendors often sell writeable control store as an option, allowing the customers to customize the machine's microprogram. Other vendors, e.g., IBM, use the WCS to run microcode for emulator features<extension extension_name='ref'><template><target>cite manual</target><arg name="author"><space/>IBM
<space/></arg><arg name="title"><space/>IBM System/360 Model 85 Functional Characteristics
<space/></arg><arg name="id"><space/>A22-6916-1
<space/></arg><arg name="url"><space/>http://www.bitsavers.org/pdf/ibm/360/funcChar/A22-6916-1_360-85_funcChar_Jun68.pdf
<space/></arg><arg name="version"><space/>SECOND EDITION
<space/></arg><arg name="date"><space/>June 1968
<space/></arg><arg name="mode">cs2
<space/></arg></template></extension><extension extension_name='ref'><template><target>cite manual</target><arg name="author"><space/>IBM
<space/></arg><arg name="title"><space/>IBM System/360 Special Feature Description 709/7090/7094 Compatibility Feature for IBM System/360 Model 85
<space/></arg><arg name="id"><space/>GA27-2733-0
<space/></arg><arg name="version"><space/>First Edition
<space/></arg><arg name="date"><space/>March 1969
<space/></arg><arg name="mode">cs2
<space/></arg></template></extension><space/>and hardware diagnostics.<extension extension_name='ref'><template><target>cite manual</target><arg name="author"><space/>IBM
<space/></arg><arg name="title"><space/>IBM System/370 Model 155 Functional Characteristics
<space/></arg><arg name="id"><space/>GA22-6942-1
<space/></arg><arg name="url"><space/>http://www.bitsavers.org/pdf/ibm/370/funcChar/GA22-6942-1_370-155_funcChar_Jan71.pdf
<space/></arg><arg name="version"><space/>SECOND EDITION
<space/></arg><arg name="date"><space/>January 1971
<space/></arg><arg name="mode">cs2
<space/></arg></template></extension></paragraph><paragraph>Other commercial machines that used writable microcode include the<space/><link><target>Burroughs Small Systems</target></link><space/>(1970s and 1980s), the Xerox processors used in their<space/><link><target>Lisp machine</target><trail>s</trail></link><space/>and<space/><link><target>Xerox Star</target></link><space/>workstations, the<space/><link><target>Digital Equipment Corporation</target><part>DEC</part></link><space/><link><target>VAX</target></link><space/>8800 (&quot;Nautilus&quot;) family, and the<space/><link><target>Symbolics</target></link><space/>L- and G-machines (1980s). Some DEC<space/><link><target>PDP-10</target></link><space/>machines stored their microcode in SRAM chips (about 80 bits wide x 2 Kwords), which was typically loaded on power-on through some other front-end CPU.<extension extension_name='ref'>http://pdp10.nocrew.org/cpu/kl10-ucode.txt</extension><space/>Many more machines offered user-programmable writable control stores as an option (including the<space/><link><target>HP 2100</target></link>, DEC<space/><link><target>PDP-11</target><part>PDP-11/60</part></link><space/>and<space/><link><target>Varian Data Machines</target></link><space/>V-70 series<space/><link><target>minicomputer</target><trail>s</trail></link>).The<space/><link><target>Mentec PDP-11#M11</target><part>Mentec M11</part></link><space/>and<space/><link><target>Mentec PDP-11#M1</target><part>Mentec M1</part></link><space/>stored its microcode in SRAM chips, loaded on power-on through another CPU.The<space/><link><target>Data General Eclipse MV/8000</target></link><space/>(&quot;Eagle&quot;) had a SRAM writable control store, loaded on power-on through another CPU.<extension extension_name='ref'><template><target>cite web</target><arg name="author">Mark Smotherman</arg><arg name="title">CPSC 330 / The Soul of a New Machine</arg><arg name="url">http://www.cs.clemson.edu/~mark/330/eagle.html</arg><arg name="quote">4096 x 75-bit SRAM writeable control store: 74-bit microinstruction with 1 parity bit (18 fields)</arg></template></extension></paragraph><paragraph>WCS offered several advantages including the ease of patching the microprogram and, for certain hardware generations, faster access than ROMs could provide. User-programmable WCS allowed the user to optimize the machine for specific purposes.</paragraph><paragraph>Some CPU designs compile the instruction set to a writable<space/><link><target>RAM</target></link><space/>or<space/><link><target>Flash memory</target><part>FLASH</part></link><space/>inside the CPU (such as the<space/><link><target>Rekursiv</target></link><space/>processor and the<space/><link><target>Imsys</target></link><space/><link><target>Cjip</target></link>),<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://cpushack.com/CPU/cpu7.html<space/></arg><arg name="title">Great Microprocessors of the Past and Present (V 13.4.0)<space/></arg><arg name="publisher">Cpushack.com<space/></arg><arg name="date"><space/></arg><arg name="accessdate">2010-04-26</arg></template></extension><space/>or an FPGA (<link><target>reconfigurable computing</target></link>).</paragraph><paragraph>Several Intel CPUs in the<space/><link><target>x86</target></link><space/>architecture family have writable microcode.<extension extension_name='ref'><link type='external' href='http://www.intel.com/Assets/PDF/manual/253668.pdf'>&quot;Intel(R) 64 and IA-32 Architectures Software Developers Manual&quot;, Volume 3A: System Programming Guide, Part 1</link>, chapter 9.11: &quot;Microcode update facilities&quot;, December 2009.</extension>This has allowed bugs in the<space/><link><target>Intel Core 2</target></link><space/>microcode and Intel<space/><link><target>Xeon</target></link><space/>microcode to be fixed in software, rather than requiring the entire chip to be replaced.Such fixes can be installed by Linux,<extension extension_name='ref'><link type='external' href='http://urbanmyth.org/microcode/'>&quot;Intel Microcode Update Utility for Linux&quot;</link></extension><space/><link><target>FreeBSD</target></link>,<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.freebsd.org/cgi/cvsweb.cgi/ports/sysutils/devcpu/<space/></arg><arg name="title">ports/sysutils/devcpu/<space/></arg><arg name="publisher">Freebsd.org<space/></arg><arg name="date">2008-09-23<space/></arg><arg name="accessdate">2010-04-26</arg></template></extension><space/>Microsoft Windows,<extension extension_name='ref'><link type='external' href='http://support.microsoft.com/kb/936357'>&quot;A microcode reliability update is available that improves the reliability of systems that use Intel processors&quot;</link></extension><space/>or the motherboard BIOS.<extension extension_name='ref'><link type='external' href='http://www.intel.com/support/motherboards/server/sb/cs-021619.htm'>&quot;BIOS Update required when Missing Microcode message is seen during POST&quot;</link></extension></paragraph><heading level='3'>Timing, latching and avoiding a race condition</heading><paragraph>The control store usually has a register on its outputs. The outputs that go back into the sequencer to determine the next address have to go through some sort of register to prevent the creation of a<space/><link><target>race condition</target></link>. In most designs all of the other bits also go through a register. This is because the machine will work faster if the execution of the next microinstruction is delayed by one cycle. This register is known as a pipeline register. Very often the execution of the next microinstruction is dependent on the result of the current microinstruction, which will not be stable until the end of the current microcycle. It can be seen that either way, all of the outputs of the control store go into one big register. Historically it used to be possible to buy EPROMs with these register bits on the same chip.</paragraph><paragraph>The<space/><link><target>clock signal</target></link><space/>determining the<space/><link><target>clock rate</target></link>, which is the cycle time of the system, primarily clocks this register.</paragraph><heading level='2'>References</heading><paragraph><template><target>wikibooks</target><arg name="1"><space/>Microprocessor Design
<space/></arg><arg name="2"><space/>Microcode
</arg></template></paragraph><paragraph><template><target>Reflist</target><arg>30em</arg></template></paragraph><preblock><preline>*<space/><template><target>cite journal</target><arg name="last">Smith<space/></arg><arg name="first">Richard E.<space/></arg><arg name="title">A Historical Overview of Computer Architecture<space/></arg><arg name="journal">Annals of the History of Computing<space/></arg><arg name="year">1988<space/></arg><arg name="volume">10<space/></arg><arg name="issue">4<space/></arg><arg name="pages">277–303<space/></arg><arg name="url">http://doi.ieeecomputersociety.org/10.1109/MAHC.1988.10039<space/></arg><arg name="doi"><space/>10.1109/MAHC.1988.10039<space/></arg><arg name="accessdate">2006-06-21</arg></template></preline></preblock><paragraph><template><target>-</target></template><template><target>CPU technologies</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Control Store</target></template><link><target>Category:Instruction processing</target></link><link><target>Category:Firmware</target></link></paragraph></article>