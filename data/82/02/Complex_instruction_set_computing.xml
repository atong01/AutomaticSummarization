<article title='Complex_instruction_set_computing'><paragraph><template><target>more footnotes</target><arg name="date">January 2012</arg></template></paragraph><paragraph><bold>Complex instruction set computing</bold><space/>(<bold>CISC</bold><space/><template><target>IPAc-en</target><arg>ˈ</arg><arg>s</arg><arg>ɪ</arg><arg>s</arg><arg>k</arg></template>) is a<space/><link><target>processor design</target></link><space/>where single<space/><link><target>instruction set architecture</target><part>instruction</part><trail>s</trail></link><space/>can execute several low-level operations (such as a load from<space/><link><target>Memory (computers)</target><part>memory</part></link>, an<space/><link><target>arithmetic</target></link><space/><link><target>operator (programming)</target><part>operation</part></link>, and a<space/><link><target>memory (computers)</target><part>memory store</part></link>) or are capable of multi-step operations or<space/><link><target>addressing mode</target><trail>s</trail></link><space/>within single instructions. The term was retroactively coined in contrast to<space/><link><target>reduced instruction set computing</target><part>reduced instruction set computer</part></link><space/>(RISC)<space/><extension extension_name='ref'><template><target>cite journal</target><arg name="title">The case for the reduced instruction set computer</arg><arg name="journal">SIGARCH Computer Architecture News</arg><arg name="last1"><space/>Patterson</arg><arg name="first1">D. A.</arg><arg name="authorlink1">David A. Patterson (scientist)</arg><arg name="last2">Ditzel</arg><arg name="first2"><space/>D. R.</arg><arg name="date">October 1980</arg><arg name="volume">8</arg><arg name="issue">6</arg><arg name="pages">25–33</arg><arg name="publisher">[[Association for Computing Machinery|ACM]]</arg><arg name="doi">10.1145/641914.641917</arg></template></extension><extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://www.ijirs.com/vol2_issue-6/59.pdf</arg><arg name="last"><space/>Lakhe<space/></arg><arg name="first"><space/>Pravin R.</arg><arg name="date">June 2013</arg><arg name="title"><space/>A Technology in Most Recent Processor is Complex Reduced Instruction Set Computers (CRISC): A Survey<space/></arg><arg name="journal">International Journal of Innovation Research and Studies<space/></arg><arg name="volume">2</arg><arg name="issue">6<space/></arg><arg name="pages">711–715</arg></template></extension><space/>and has therefore become something of an<space/><link><target>umbrella term</target></link><space/>for everything that is not RISC, i.e. everything from large and complex<space/><link><target>mainframe computer</target><part>mainframes</part></link><space/>to simplistic microcontrollers where memory load and store operations are not separated from arithmetic instructions.<space/></paragraph><paragraph>A modern RISC processor can therefore be much more complex than, say, a modern microcontroller using a CISC-labeled instruction set, especially in terms of implementation (electronic circuit complexity), but also in terms of the number of instructions or the complexity of their encoding patterns. The only differentiating characteristic (nearly) &quot;guaranteed&quot; is the fact that most RISC designs use uniform instruction length for (almost) all instructions and employ strictly separate load/store-instructions.</paragraph><paragraph>Examples of instruction set architectures that have been retroactively labeled CISC are<space/><link><target>System/360</target></link><space/>through<space/><link><target>z/Architecture</target></link>, the<space/><link><target>PDP-11</target></link><space/>and<space/><link><target>VAX</target></link><space/>architectures,<space/><link><target>Data General Nova</target></link><space/>and many others. Well known microprocessors and microcontrollers that have also been labeled CISC in many academic publications include the<space/><link><target>Motorola 6800</target></link>,<space/><link><target>6809</target></link><space/>and<space/><link><target>68000</target></link>-families; the Intel<space/><link><target>8080</target></link>,<space/><link><target>iAPX432</target></link><space/>and<space/><link><target>x86</target></link>-family; the Zilog<space/><link><target>Z80</target></link>,<space/><link><target>Zilog Z8</target><part>Z8</part></link><space/>and<space/><link><target>Z8000</target></link>-families; the National Semiconductor<space/><link><target>32016</target></link><space/>and<space/><link><target>NS320xx</target></link>-line; the MOS Technology<space/><link><target>6502</target></link>-family; the Intel<space/><link><target>8051</target></link>-family; and others.</paragraph><paragraph>Some designs have been regarded as borderline cases by some writers. For instance, the Microchip Technology<space/><link><target>PIC microcontroller</target><part>PIC</part></link><space/>has been labeled RISC in some circles and CISC in others and the<space/><link><target>6502</target></link><space/>and<space/><link><target>6809</target></link><space/>have both been described as &quot;RISC-like&quot;, although they have complex addressing modes as well as arithmetic instructions that access memory, contrary to the RISC-principles.</paragraph><heading level='2'>Historical design context</heading><paragraph><template><target>Unreferenced section</target><arg name="date">December 2013</arg></template></paragraph><heading level='3'>Incitements and benefits</heading><paragraph>Before the<space/><link><target>Reduced instruction set computing</target><part>RISC</part></link><space/>philosophy became prominent, many<space/><link><target>computer Architecture</target><part>computer architects</part></link><space/>tried to bridge the so-called<space/><link><target>semantic gap</target></link>, i.e. to design instruction sets that directly supported high-level programming constructs such as procedure calls, loop control, and complex<space/><link><target>addressing mode</target><trail>s</trail></link>, allowing data structure and array accesses to be combined into single instructions. Instructions are also typically highly encoded in order to further enhance the code density. The compact nature of such instruction sets results in smaller<space/><link><target>Computer program</target><part>program</part></link><space/>sizes and fewer (slow) main memory accesses, which at the time (early 1960s and onwards) resulted in a tremendous savings on the cost of computer memory and disc storage, as well as faster execution. It also meant good<space/><link><target>programming productivity</target></link><space/>even in<space/><link><target>assembly language</target></link>, as<space/><link><target>high level language</target><trail>s</trail></link><space/>such as<space/><link><target>Fortran</target></link><space/>or<space/><link><target>ALGOL</target><part>Algol</part></link><space/>were not always available or appropriate (microprocessors in this category are sometimes still programmed in assembly language for certain types of critical applications<template><target>Citation needed</target><arg name="date">October 2011</arg></template>).</paragraph><heading level='4'>New instructions</heading><paragraph>In the 1970s, analysis of high level languages indicated some complex machine language implementations and it was determined that new instructions could improve performance. Some instructions were added that were never intended to be used in assembly language but fit well with compiled high level languages. Compilers were updated to take advantage of these instructions. The benefits of semantically rich instructions with compact encodings can be seen in modern processors as well, particularly in the high performance segment where caches are a central component (as opposed to most<space/><link><target>embedded system</target><trail>s</trail></link>). This is because these fast, but complex and expensive, memories are inherently limited in size, making compact code beneficial. Of course, the fundamental reason they are needed is that main memories (i.e.<space/><link><target>dynamic RAM</target></link><space/>today) remain slow compared to a (high performance) CPU-core.</paragraph><heading level='3'>Design issues</heading><paragraph>While many designs achieved the aim of higher throughput at lower cost and also allowed high-level language constructs to be expressed by fewer instructions, it was observed that this was not<space/><italics>always</italics><space/>the case. For instance, low-end versions of complex architectures (i.e. using less hardware) could lead to situations where it was possible to improve performance by<space/><italics>not</italics><space/>using a complex instruction (such as a procedure call or enter instruction), but instead using a sequence of simpler instructions.</paragraph><paragraph>One reason for this was that architects (<link><target>microcode</target></link><space/>writers) sometimes &quot;over-designed&quot; assembler language instructions, i.e. including features which were not possible to implement efficiently on the basic hardware available. This could, for instance, be &quot;side effects&quot; (above conventional flags), such as the setting of a register or memory location that was perhaps seldom used; if this was done via ordinary (non duplicated) internal buses, or even the<space/><italics>external</italics><space/>bus, it would demand extra cycles every time, and thus be quite inefficient.</paragraph><paragraph>Even in balanced high performance designs, highly encoded and (relatively) high-level instructions could be complicated to decode and execute efficiently within a limited transistor budget. Such architectures therefore required a great deal of work on the part of the processor designer in cases where a simpler, but (typically) slower, solution based on decode tables and/or microcode sequencing is not appropriate. At a time when transistors and other components were a limited resource, this also left fewer components and less opportunity for other types of performance optimizations.</paragraph><heading level='4'>The RISC idea</heading><paragraph>The circuitry that performs the actions defined by the microcode in many (but not all) CISC processors is, in itself, a processor which in many ways is reminiscent in structure to very early CPU designs. In the early 1970s, this gave rise to ideas to return to simpler processor designs in order to make it more feasible to cope without (<italics>then</italics><space/>relatively large and expensive) ROM tables and/or PLA structures for sequencing and/or decoding. The first (retroactively) RISC-<italics>labeled</italics><space/>processor (<link><target>IBM 801</target></link><space/>-<space/><link><target>IBM</target></link>'s Watson Research Center, mid-1970s) was a tightly pipelined simple machine originally intended to be used as an internal microcode kernel, or engine, in CISC designs, but also became the processor that introduced the RISC idea to a somewhat larger public. Simplicity and regularity also in the visible instruction set would make it easier to implement overlapping processor stages (<link><target>Pipeline (computing)</target><part>pipelining</part></link>) at the machine code level (i.e. the level seen by compilers). However, pipelining at that level was already used in some high performance CISC &quot;supercomputers&quot; in order to reduce the instruction cycle time (despite the complications of implementing within the limited component count and wiring complexity feasible at the time). Internal microcode execution in CISC processors, on the other hand, could be more or less pipelined depending on the particular design, and therefore more or less akin to the basic structure of RISC processors.</paragraph><heading level='4'>Superscalar</heading><paragraph>In a more modern context, the complex variable length encoding used by some of the typical CISC architectures makes it complicated, but still feasible, to build a<space/><link><target>superscalar</target></link><space/>implementation of a CISC programming model<space/><italics>directly</italics>; the in-order superscalar original<space/><link><target>Intel P5</target><part>Pentium</part></link><space/>and the out-of-order superscalar<space/><link><target>Cyrix 6x86</target></link><space/>are well known examples of this. The frequent memory accesses for operands of a typical CISC machine may limit the instruction level parallelism that can be extracted from the code, although this is strongly mediated by the fast cache structures used in modern designs, as well as by other measures. Due to inherently compact and semantically rich instructions, the average amount of work performed per machine code unit (i.e. per byte or bit) is higher for a CISC than a RISC processor, which may give it a significant advantage in a modern cache based implementation.</paragraph><paragraph>Transistors for logic, PLAs, and microcode are no longer scarce resources; only large high-speed cache memories are limited by the maximum number of transistors today. Although complex, the transistor count of CISC decoders do not grow exponentially like the total number of transistors per processor (the majority typically used for caches). Together with better tools and enhanced technologies, this has led to new implementations of highly encoded and variable length designs without load-store limitations (i.e. non-RISC). This governs re-implementations of older architectures such as the ubiquitous x86 (see below) as well as new designs for<space/><link><target>microcontroller</target><trail>s</trail></link><space/>for<space/><link><target>embedded system</target><trail>s</trail></link>, and similar uses. The superscalar complexity in the case of modern x86 was solved by converting instructions into one or more<space/><link><target>micro-operations</target></link><space/>and dynamically issuing those micro-operations, i.e. indirect and dynamic superscalar execution; the<space/><link><target>Pentium Pro</target></link><space/>and<space/><link><target>AMD K5</target></link><space/>are early examples of this. It allows a fairly simple superscalar design to be located after the (fairly complex) decoders (and buffers), giving, so to speak, the best of both worlds in many respects.</paragraph><heading level='4'>CISC and RISC terms</heading><paragraph>The terms CISC and RISC have become less meaningful with the continued evolution of both CISC and RISC designs and implementations. The first highly (or tightly) pipelined x86 implementations, the 486 designs from<space/><link><target>Intel</target></link>,<space/><link><target>AMD</target></link>,<space/><link><target>Cyrix</target></link>, and<space/><link><target>IBM</target></link>, supported every instruction that their predecessors did, but achieved<space/><italics>maximum efficiency</italics><space/>only on a fairly simple x86 subset that was only a little more than a typical RISC instruction set (i.e. without typical RISC<space/><italics><link><target>load-store architecture</target><part>load-store</part></link></italics><space/>limitations). The Intel<space/><link><target>P5 (microarchitecture)</target><part>P5</part></link><space/><link><target>Pentium (brand)</target><part>Pentium</part></link><space/>generation was a superscalar version of these principles. However, modern x86 processors also (typically) decode and split instructions into dynamic sequences of internally buffered<space/><link><target>micro-operations</target></link>, which not only helps execute a larger subset of instructions in a pipelined (overlapping) fashion, but also facilitates more advanced extraction of parallelism out of the code stream, for even higher performance.</paragraph><paragraph>Contrary to popular simplifications (present also in some academic texts), not all CISCs are microcoded or have &quot;complex&quot; instructions. As CISC became a catch-all term meaning anything that's not a load-store (RISC) architecture, it's not the number of instructions, nor the complexity of the implementation or of the instructions themselves, that define CISC, but the fact that arithmetic instructions also perform memory accesses.<space/><template><target>Citation needed</target><arg name="date">October 2011</arg></template><space/>Compared to a small 8-bit CISC processor, a RISC floating-point instruction is complex. CISC does not even need to have complex addressing modes; 32 or 64-bit RISC processors may well have more complex addressing modes than small 8-bit CISC processors.</paragraph><paragraph>A<space/><link><target>PDP-10</target></link>, a<space/><link><target>PDP-8</target></link>, an<space/><link><target>Intel 386</target></link>, an<space/><link><target>Intel 4004</target></link>, a<space/><link><target>Motorola 68000</target></link>, a<space/><link><target>System z</target></link><space/>mainframe, a<space/><link><target>Burroughs B5000</target></link>, a<space/><link><target>VAX</target></link>, a<space/><link><target>Zilog Z80000</target></link>, and a<space/><link><target>MOS Technology 6502</target></link><space/>all vary wildly in the number, sizes, and formats of instructions, the number, types, and sizes of registers, and the available data types. Some have hardware support for operations like scanning for a substring, arbitrary-precision BCD arithmetic, or<space/><link><target>transcendental function</target><trail>s</trail></link>, while others have only 8-bit addition and subtraction. But they are all in the CISC category because they have &quot;load-operate&quot; instructions that load and/or store memory contents within the same instructions that perform the actual calculations. For instance, the PDP-8, having only 8 fixed-length instructions and no microcode at all, is a CISC because of<space/><italics>how</italics><space/>the instructions work, PowerPC, which has over 230 instructions (more than some VAXes) and complex internals like register renaming and a reorder buffer is a RISC, while<space/><link type='external' href='http://www.cs.uiowa.edu/~jones/arch/cisc/'>Minimal CISC</link><space/>has 8 instructions, but is clearly a CISC because it combines memory access and computation in the same instructions.</paragraph><paragraph>Some of the problems and contradictions in this terminology will perhaps disappear as more systematic terms, such as (<bold><italics>non</italics></bold>)<space/><bold><italics>load/store</italics></bold>, become more popular and eventually replace the imprecise and slightly counter-intuitive RISC/CISC terms.</paragraph><heading level='2'>See also</heading><paragraph><template><target>Portal</target><arg>Computer science</arg></template></paragraph><list type='bullet'><listitem><link><target>CPU design</target></link></listitem><listitem><link><target>Computer architecture</target></link></listitem><listitem><link><target>Computer</target></link></listitem><listitem><link><target>Central processing unit</target><part>CPU</part></link></listitem><listitem><link><target>Minimal instruction set computer</target><part>MISC</part></link></listitem><listitem><link><target>Reduced instruction set computing</target><part>RISC</part></link></listitem><listitem><link><target>Zero instruction set computer</target><part>ZISC</part></link></listitem><listitem><link><target>Very long instruction word</target><part>VLIW</part></link></listitem><listitem><link><target>Microprocessor</target></link></listitem></list><heading level='2'>Notes</heading><list type='bullet'><listitem>Tanenbaum, Andrew S. (2006)<space/><italics>Structured Computer Organization, Fifth Edition</italics>, Pearson Education, Inc. Upper Saddle River, NJ.</listitem></list><heading level='2'>References</heading><paragraph><extension extension_name='references'></extension><template><target>FOLDOC</target></template></paragraph><heading level='2'>Further reading</heading><list type='bullet'><listitem><template><target>cite book</target><arg name="first1">M. Morris</arg><arg name="last1">Mano</arg><arg name="title">Computer System Architecture (3rd Edition)</arg><arg name="isbn">978-0131755635</arg></template></listitem></list><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://www.cs.otago.ac.nz/cosc243/lectures/243-2013print13.pdf'>COSC 243_Computer Architecture 2</link></listitem></list><paragraph><template><target>CPU technologies</target></template></paragraph><paragraph><template><target>Authority control</target></template></paragraph><paragraph><link><target>Category:Classes of computers</target></link></paragraph></article>