'''Dhrystone''' is a [[#Dhrystone_vs._Whetstone|synthetic]] computing [[Benchmark (computing)|benchmark]] program developed in 1984 by [[Reinhold P. Weicker]] intended to be representative of system (integer) programming. The Dhrystone grew to become representative of general processor ([[CPU]]) performance. The name "Dhrystone" is a pun on a different benchmark algorithm called [[Whetstone (benchmark)|Whetstone]].<ref>[[Pun]]: w'''h'''etstone → wet stone → dry stone → d'''h'''rystone.</ref>

With Dhrystone, Weicker gathered meta-data from a broad range of software, including programs written in [[FORTRAN]], [[PL/1]], SAL, [[ALGOL 68]], and [[Pascal (programming language)|Pascal]]. He then characterized these programs in terms of various common constructs: procedure calls, pointer [[indirection]]s, assignments, etc. From this he wrote the Dhrystone benchmark to correspond to a representative mix.  Dhrystone was published in [[Ada (programming language)|Ada]], with the [[C (programming language)|C]] version for [[Unix]] developed by Rick Richardson ("version 1.1") greatly contributing to its popularity.

==Dhrystone vs. Whetstone ==
The Dhrystone benchmark contains no [[floating point]] operations, thus the name is a pun on the then-popular [[Whetstone (benchmark)|Whetstone]] benchmark for floating point operations. The output from the benchmark is the number of Dhrystones per second (the number of iterations of the main code loop per second).

Both Whetstone and Dhrystone are ''synthetic'' benchmarks, meaning that they are simple programs that are carefully designed to statistically mimic the processor usage of some common set of programs. Whetstone, developed in 1972, originally strove to mimic typical Algol 60 programs based on measurements from 1970, but eventually became most popular in its Fortran version, reflecting the highly numerical orientation of computing in the 1960s.

==Issues addressed by Dhrystone==
Dhrystone's eventual importance as an indicator of general-purpose ("integer") performance of new computers made it a target for commercial compiler writers. Various modern compiler [[static code analysis]] techniques (such as [[dead code elimination|elimination of dead code]]: for example, code which uses the processor but produces internal results which are not used or output) make the use and design of synthetic benchmarks more difficult. Version 2.0 of the benchmark, released by Weicker and Richardson in March 1988, had a number of changes intended to foil a range of compiler techniques. Yet it was carefully crafted so as not to change the underlying benchmark.  This effort to foil compilers was only partly successful.  Dhrystone 2.1, released in May of the same year, had some minor changes and {{As of|2010|7|lc=on}} remains the current definition of Dhrystone.

Other than issues related to compiler optimization, various other issues have been cited with the Dhrystone. Most of these, including the small code size and small data set size, were understood at the time of its publication in 1984. More subtle is the slight over-representation of string operations, which is largely language-related: both Ada and Pascal have strings as normal variables in the language, whereas C does not, so what was simple variable assignment in reference benchmarks became buffer copy operations in the C library. Another issue is that the score reported does not include information which is critical when comparing systems such as which compiler was used, and what optimizations.

Dhrystone remains remarkably resilient as a simple benchmark, but its continuing value in establishing true performance is questionable.  It is easy to use, well documented, fully self-contained, well understood, and can be made to work on almost any system.  In particular, it has remained in broad use in the embedded computing world, though the recently developed '''[[EEMBC]]''' benchmark suite, HINT, Stream, and even Bytemark are widely quoted and used, as well as more specific benchmarks for the memory subsystem (Cachebench), TCP/IP (TTCP), and many others.

Dhrystone remains in use 30 years after it was designed by Weicker, a longer life than most software.

==Dhrystone vs. CoreMark==
[[CoreMark]] is a small benchmark released by the non-profit Embedded Microprocessor Benchmark Consortium ([[EEMBC]]) that targets the CPU core, similar to Dhrystone. Both benchmarks are available free of charge and are small enough to execute on any processor, including small micro-controllers. CoreMark avoids issues such as the compiler computing the work during compile time, and uses real algorithms rather than being completely synthetic. CoreMark also has established rules for running the benchmark and for reporting the results.

==Results ==
Dhrystone may represent a result more meaningfully than MIPS (million instructions per second) because instruction count comparisons between different instruction sets (e.g. [[RISC]] vs. [[Complex instruction set computer|CISC]]) can confound simple comparisons.  For example, the same high-level task may require many more instructions on a RISC machine, but might execute faster than a single CISC instruction.  Thus, the Dhrystone score counts only the number of program iteration completions per second, allowing individual machines to perform this calculation in a machine-specific way.  Another common representation of the Dhrystone benchmark is the '''DMIPS''' (Dhrystone [[million instructions per second|MIPS]]) obtained when the Dhrystone score is divided by 1757 (the number of Dhrystones per second obtained on the [[VAX|VAX 11/780]], nominally a 1 MIPS machine).

Another way to represent results is in DMIPS/MHz, where DMIPS result is further divided by CPU frequency, to allow for easier comparison of CPUs running at different [[clock rate]]s.

==Shortcomings==
Using Dhrystone as a benchmark has pitfalls: 
* it features unusual code that is not usually representative of real-life programs<ref name="crit1">{{cite web | url=http://www.johnloomis.org/NiosII/dhrystone/ECLDhrystoneWhitePaper.pdf ECL | last=Weiss | first=Alan | title=Dhrystone Benchmark: History, Analysis, "Scores" and Recommendations}}</ref>
* it is susceptible to compiler optimizations. For example, it does a lot of string copying in an attempt to measure string copying performance. However, the strings in Dhrystone are of known constant length and their starts are aligned on natural boundaries, two characteristics usually absent from real programs. Therefore, an optimizer can replace a string copy with a sequence of word moves without any loops, which will be much faster. This optimization consequently overstates system performance, sometimes by more than 30%{{Citation needed|date=June 2012}}.
* Dhrystone's small code size may fit in the [[instruction cache]] of a modern CPU, so that [[instruction fetch]] performance is not rigorously tested.<ref name="crit1" />

==See also==
*[[Benchmark (computing)]]
*[[Whetstone (benchmark)]]

==References==

===Notes===
<references/>

===Bibliography===
{{refbegin}}
*{{cite journal |author=Weicker, Reinhold |title=Dhrystone: A Synthetic Systems Programming Benchmark |journal=Communications of the ACM |volume=27 |issue=10 |pages=1013–30 |date=October 1984 |doi=10.1145/358274.358283 }}
{{refend}}

==External links==
* [http://www.anime.net/~goemon/benchmarks.html Dhrystone results for Unix machines.]
* [http://groups.google.com/groups?q=DMIPS&hl=en&group=comp.benchmarks&rnum=1&selm=tsengDKq856.Gy6%40netcom.com Newsgroup posting for calculation of DMIPS]
* [http://www.netlib.org/benchmark/dhry-c  C version of Dhrystone in a sh file]
* [http://homepages.cwi.nl/~steven/dry.c Self configuring and compiling version.]
* [http://www.cs.mu.oz.au/313/online/Handout.pdf Comments on Benchmark pitfalls. Set 8, Slide 11, page 95]
* [http://www.roylongbottom.org.uk/dhrystone%20results.htm Dhrystone Benchmark Results On PCs]
* [http://www.roylongbottom.org.uk/index.htm Source code and C/C++ pre-compiled versions for PCs]
* [http://www.coremark.org CoreMark]

[[Category:Computer benchmarks]]
[[Category:1984 introductions]]