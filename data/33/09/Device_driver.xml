<article title='Device_driver'><paragraph><template><target>multiple issues</target><arg name="{{lead too short|date">February 2013}}
{{refimprove|date</arg></template><template><target>Other uses</target><arg>Driver (disambiguation){{!}}Driver</arg></template><template><target>OS</target></template></paragraph><paragraph>In computing, a<space/><bold>device driver</bold><space/>(commonly referred to as a<space/><italics>driver</italics>) is a<space/><link><target>computer program</target></link><space/>that operates or controls a particular type of device that is attached to a computer.<extension extension_name='ref' name="dev1"><template><target>cite web</target><arg name="url">https://www.pc-gesund.de/it-wissen/what-is-a-device-driver</arg><arg name="title">What is a device driver?, The purpose of device drivers</arg><arg name="accessdate">November 8, 2012</arg><arg name="publisher">PC Gesund</arg></template></extension><space/>A driver provides a<space/><link><target>software interface</target></link><space/>to hardware devices, enabling operating systems and other computer programs to access hardware functions without needing to know precise details of the hardware being used.</paragraph><paragraph>A driver typically communicates with the<space/><link><target>Peripheral</target><part>device</part></link><space/>through the<space/><link><target>computer bus</target></link><space/>or communications subsystem to which the hardware connects. When a calling program invokes a<space/><link><target>subroutine</target><part>routine</part></link><space/>in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. Drivers are hardware-dependent and<space/><link><target>operating system</target><part>operating-system</part></link>-specific. They usually provide the<space/><link><target>interrupt</target></link><space/>handling required for any necessary asynchronous time-dependent hardware interface.<extension extension_name='ref'><template><target>cite book</target><arg name="url">http://books.google.com.ph/books?id</arg><arg name="title">Information Storage and Management: Storing, Managing, and Protecting Digital Information</arg><arg name="year">2010</arg><arg name="author">EMC Education Services</arg><arg name="publisher">John Wiley & Sons</arg></template></extension></paragraph><heading level='2'>Purpose</heading><paragraph>Device drivers simplify programming by acting as translator between a hardware device and the applications or<space/><link><target>operating system</target><trail>s</trail></link><space/>that use it.<extension extension_name='ref' name="dev1"></extension><space/>Programmers can write the higher-level application code independently of whatever specific hardware the end-user is using.</paragraph><paragraph>For example, a high-level application for interacting with a<space/><link><target>serial port</target></link><space/>may simply have two functions for &quot;send data&quot; and &quot;receive data&quot;. At a lower level, a device driver implementing these functions would communicate to the particular serial port controller installed on a user's computer. The commands needed to control a<space/><link><target>16550 UART</target></link><space/>are much different from the commands needed to control an<space/><link><target>FTDI</target></link><space/>serial port converter, but each hardware-specific device driver<space/><link><target>Abstraction (computer science)</target><part>abstracts</part></link><space/>these details into the same (or similar) software interface.</paragraph><heading level='2'>Development</heading><paragraph>Writing a device driver requires an in-depth understanding of how the hardware and the software works for a given<space/><link><target>Computing platform</target><part>platform</part></link><space/>function. Because drivers require low-level access to hardware functions in order to operate, drivers typically operate in a highly<space/><link><target>privilege (computing)</target><part>privilege</part><trail>d</trail></link><space/>environment and can cause system operational issues if something goes wrong. In contrast, most user-level software on modern<space/><link><target>operating system</target><trail>s</trail></link><space/>can be stopped without greatly affecting the rest of the system. Even drivers executing in<space/><link><target>user mode</target></link><space/>can crash a system if the device is erroneously programmed. These factors make it more difficult and dangerous to diagnose problems.<extension extension_name='ref'><template><target>cite book</target><arg name="url">http://books.google.com.ph/books?id</arg><arg name="title">Writing device drivers: tutorial and reference</arg><arg name="year">1995</arg><arg name="author">Burke, Timothy</arg><arg name="publisher">Digital Press</arg></template></extension></paragraph><paragraph>The task of writing drivers thus usually falls to<space/><link><target>software engineer</target><trail>s</trail></link><space/>or<space/><link><target>computer engineer</target><trail>s</trail></link><space/>who work for hardware-development companies. This is because they have better information than most outsiders about the design of their hardware. Moreover, it was traditionally considered in the hardware<space/><link><target>manufacturer</target></link>'s interest to guarantee that their clients can use their hardware in an optimum way. Typically, the<space/><link><target>logical device driver</target></link><space/>(LDD) is written by the operating system vendor, while the<space/><link><target>physical device driver</target></link><space/>(PDD) is implemented by the device vendor. But in recent years non-vendors have written numerous device drivers, mainly for use with<space/><link><target>free and open source software</target><part>free and open source</part></link><space/><link><target>operating system</target><trail>s</trail></link>. In such cases, it is important that the hardware manufacturer provides information on how the device communicates. Although this information can instead be learned by<space/><link><target>reverse engineering</target></link>, this is much more difficult with hardware than it is with software.</paragraph><paragraph><link><target>Microsoft</target></link><space/>has attempted to reduce system instability due to poorly written device drivers by creating a new framework for driver development, called<space/><link><target>Windows Driver Foundation</target></link><space/>(WDF). This includes<space/><link><target>User-Mode Driver Framework</target></link><space/>(UMDF) that encourages development of certain types of driversprimarily those that implement a<space/><link><target>message-based protocol</target></link><space/>for communicating with their devicesas user-mode drivers. If such drivers malfunction, they do not cause system instability. The<space/><link><target>Kernel-Mode Driver Framework</target></link><space/>(KMDF) model continues to allow development of kernel-mode device drivers, but attempts to provide standard implementations of functions that are known to cause problems, including cancellation of I/O operations, power management, and plug and play device support.</paragraph><paragraph><link><target>Apple Inc.</target><part>Apple</part></link><space/>has an open-source framework for developing drivers on<space/><link><target>Mac OS&amp;nbsp;X</target></link><space/>called the<space/><link><target>I/O&amp;nbsp;Kit</target></link>.</paragraph><paragraph>In<space/><link><target>Linux kernel</target><part>Linux</part></link><space/>environments, programmers can build device drivers as parts of the<space/><link><target>Linux kernel</target><part>kernel</part></link>, separately as loadable<space/><link><target>loadable kernel module</target><part>module</part><trail>s</trail></link>, or as user-mode drivers (for certain types of devices where kernel interfaces exist, such as for USB devices).<space/><link><target>Makedev</target></link><space/>includes a list of the devices in Linux: ttyS (terminal), lp (<link><target>parallel port</target></link>), hd (disk), loop, sound (these include<space/><link><target>Sound card mixer</target><part>mixer</part></link>,<space/><link><target>Music sequencer</target><part>sequencer</part></link>,<space/><link><target>Digital signal processor</target><part>dsp</part></link>, and audio)...<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://linux.about.com/od/commands/l/blcmdl8_MAKEDEV.htm
<space/></arg><arg name="title"><space/>MAKEDEV&nbsp;— Linux Command&nbsp;— Unix Command
<space/></arg><arg name="publisher"><space/>Linux.about.com
<space/></arg><arg name="date"><space/>2009-09-11
<space/></arg><arg name="accessdate"><space/>2009-09-17
</arg></template></extension></paragraph><paragraph>The<space/><link><target>Microsoft Windows</target></link><space/><link><target>.sys</target></link><space/>files and<space/><link><target>Linux</target></link><space/>.ko modules contain loadable device drivers. The advantage of loadable device drivers is that they can be loaded only when necessary and then unloaded, thus saving kernel memory.</paragraph><heading level='2'>Kernel mode vs. user mode</heading><paragraph>Device drivers, particularly on<space/><template><target>as of</target><arg><space/>2009<space/></arg><arg name="alt"><space/>modern</arg></template><space/><link><target>Microsoft Windows</target></link><space/>platforms, can run in<space/><link><target>CPU modes</target><part>kernel-mode</part></link><space/>(<link><target>Ring (computer security)</target><part>Ring 0 on x86 CPUs</part></link>) or in<space/><link><target>user space</target><part>user-mode</part></link><space/>(Ring&amp;nbsp;3 on x86 CPUs).<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://technet2.microsoft.com/windowsserver/en/library/eb1936c0-e19c-4a17-a1a8-39292e4929a41033.mspx?mfr</arg><arg name="title"><space/>User-mode vs. Kernel-mode Drivers
<space/></arg><arg name="publisher"><space/>[[Microsoft]]
<space/></arg><arg name="date"><space/>2003-03-01
<space/></arg><arg name="accessdate"><space/>2008-03-04
</arg></template></extension><space/>The primary benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory.<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://blogs.msdn.com/iliast/archive/2006/10/10/Introduction-to-the-User_2D00_Mode-Driver-Framework.aspx
<space/></arg><arg name="title"><space/>Introduction to the User-Mode Driver Framework (UMDF)
<space/></arg><arg name="date"><space/>2006-10-10
<space/></arg><arg name="accessdate"><space/>2008-03-04
<space/></arg><arg name="publisher"><space/>[[Microsoft]]
</arg></template></extension><space/>On the other hand, user/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user-mode drivers for low latency and high throughput requirements.</paragraph><paragraph>Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX shell or other GUI-based applications are part of the user space. These applications interact with hardware through kernel supported functions.</paragraph><heading level='2'>Applications</heading><paragraph>Because of the diversity of<space/><template><target>as of</target><arg><space/>2009<space/></arg><arg name="alt"><space/>modern</arg></template><space/>hardware and operating systems, drivers operate in many different environments.<extension extension_name='ref'><template><target>cite book</target><arg name="url">http://books.google.com.ph/books?id</arg><arg name="title">Understanding Computers 2009: Today and Tomorrow</arg><arg name="year">2009</arg><arg name="author">Deborah Morley</arg><arg name="publisher">Cengage Learning</arg></template></extension><space/>Drivers may<space/><link><target>interface (computer science)</target><part>interface</part></link><space/>with:</paragraph><list type='bullet'><listitem><link><target>Computer printer</target><part>Printers</part></link></listitem><listitem><link><target>Video card</target><part>Video adapters</part></link></listitem><listitem><link><target>Network interface controller</target><part>Network cards</part></link></listitem><listitem><link><target>Sound card</target><trail>s</trail></link></listitem><listitem>Local<space/><link><target>Computer bus</target><part>buses</part></link><space/>of various sortsin particular, for<space/><link><target>bus mastering</target></link><space/>on modern systems</listitem><listitem>Low-<link><target>bandwidth (computing)</target><part>bandwidth</part></link><space/><link><target>input/output</target><part>I/O</part></link><space/>buses of various sorts (for<space/><link><target>pointing device</target><trail>s</trail></link><space/>such as<space/><link><target>Computer mouse</target><part>mice</part></link>,<space/><link><target>Computer keyboard</target><part>keyboard</part><trail>s</trail></link>,<space/><link><target>Universal Serial Bus</target><part>USB</part></link>, etc.)</listitem><listitem><link><target>Computer storage</target></link><space/>devices such as<space/><link><target>Hard disk drive</target><part>hard disk</part></link>,<space/><link><target>CD-ROM</target></link>, and<space/><link><target>floppy disk</target></link><space/>buses (<link><target>Advanced Technology Attachment</target><part>ATA</part></link>,<space/><link><target>Serial ATA</target><part>SATA</part></link>,<space/><link><target>SCSI</target></link>)</listitem><listitem>Implementing support for different<space/><link><target>file system</target><trail>s</trail></link></listitem><listitem><link><target>Image scanner</target><trail>s</trail></link></listitem><listitem><link><target>Digital camera</target><trail>s</trail></link></listitem></list><paragraph>Common levels of abstraction for device drivers include:</paragraph><list type='bullet'><listitem>For hardware:<list type='bullet'><listitem>Interfacing directly</listitem><listitem>Writing to or reading from a<space/><link><target>device control register</target></link></listitem><listitem>Using some higher-level interface (e.g.<space/><link><target>Video BIOS</target></link>)</listitem><listitem>Using another lower-level device driver (e.g. file system drivers using disk drivers)</listitem><listitem>Simulating work with hardware, while doing something entirely different<template><target>Citation needed</target><arg name="date">September 2009</arg></template></listitem></list></listitem><listitem>For software:<list type='bullet'><listitem>Allowing the operating system direct access to hardware resources</listitem><listitem>Implementing only<space/><link><target>primitive (computer science)</target><part>primitive</part><trail>s</trail></link></listitem><listitem>Implementing an interface for non-driver software (e.g.,&amp;nbsp;<link><target>TWAIN</target></link>)</listitem><listitem>Implementing a language, sometimes quite high-level (e.g.,&amp;nbsp;<link><target>PostScript</target></link>)</listitem></list></listitem></list><paragraph>So choosing and installing the correct device drivers for given hardware is often a key component of computer system configuration.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.drivers.com/update/drivers-news/what-are-device-drivers-and-why-do-we-need-them/</arg><arg name="title">What are Device Drivers and why do we need them?</arg></template></extension></paragraph><heading level='2'>Virtual device drivers</heading><paragraph>Virtual device drivers represent a particular variant of device drivers. They are used to emulate a hardware device, particularly in<space/><link><target>virtual machine</target><part>virtualization</part></link><space/>environments, for example when a<space/><link><target>DOS</target></link><space/>program is run on a<space/><link><target>Microsoft Windows</target></link><space/>computer or when a guest<space/><link><target>operating system</target></link><space/>is run on, for example, a<space/><link><target>Xen</target></link><space/>host. Instead of enabling the guest operating system to dialog with hardware, virtual device drivers take the opposite role and emulate a piece of hardware, so that the guest operating system and its drivers running inside a<space/><link><target>virtual machine</target></link><space/>can have the illusion of accessing real hardware. Attempts by the guest operating system to access the hardware are routed to the virtual device driver in the host operating system as e.g.,&amp;nbsp;<link><target>function call</target><trail>s</trail></link>. The virtual device driver can also send simulated processor-level events like<space/><link><target>interrupt</target><trail>s</trail></link><space/>into the virtual machine.</paragraph><paragraph>Virtual devices may also operate in a non-virtualized environment. For example a virtual<space/><link><target>Network interface controller</target><part>network adapter</part></link><space/>is used with a<space/><link><target>virtual private network</target></link>, while a virtual<space/><link><target>Hard disk drive</target><part>disk</part></link><space/>device is used with<space/><link><target>iSCSI</target></link>. A good example for virtual device drivers can be<space/><link><target>Daemon Tools</target></link>.</paragraph><paragraph>There are several variants of virtual device drivers, such as<space/><link><target>VxD</target><trail>s</trail></link>,<space/><link><target>VLM (NetWare)</target><part>VLM</part><trail>s</trail></link>, VDDs.</paragraph><heading level='2'>Open drivers</heading><list type='bullet'><listitem>Printers:<space/><link><target>CUPS</target></link></listitem><listitem>RAIDs: CCISS<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://sourceforge.net/projects/cciss/
</arg><arg name="title"><space/>CCISS
</arg><arg name="year"><space/>2010
</arg><arg name="work"><space/>[[SourceForge]]
</arg><arg name="accessdate"><space/>2010-08-11
</arg><arg name="quote"><space/>Drivers for the HP (previously Compaq) Smart Array controllers which provide hardware RAID capability.
</arg></template></extension><space/>(Compaq Command Interface for SCSI-3 Support<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://www.redbooks.ibm.com/redbooks/pdfs/sg246852.pd
</arg><arg name="title"><space/>Abbreviations and acronyms
</arg><arg name="first"><space/>Steve
</arg><arg name="last"><space/>Russell
</arg><arg name="date"><space/>2003-10-21
</arg><arg name="work"><space/>Server Consolidation with the IBM eserver xSeries 440 and VMware ESX Serve
</arg><arg name="publisher"><space/>IBM International Technical Support Organization
</arg><arg name="page"><space/>207
</arg><arg name="isbn"><space/>0-7384-2684-9
</arg><arg name="accessdate"><space/>2011-08-14
</arg><arg name="display-authors">etal</arg></template></extension>)</listitem><listitem>Scanners:<space/><link><target>Scanner Access Now Easy</target><part>SANE</part></link></listitem><listitem>Video:<space/><link><target>Vidix</target></link>,<space/><link><target>Direct Rendering Infrastructure</target></link></listitem></list><paragraph><link><target>Solaris (operating system)</target><part>Solaris</part></link><space/>descriptions of commonly used device drivers</paragraph><list type='bullet'><listitem>fas: Fast/wide SCSI controller</listitem><listitem>hme: Fast (10/100 Mbit/s) Ethernet</listitem><listitem>isp: Differential SCSI controllers and the SunSwift card</listitem><listitem>glm: (Gigabaud Link Module<extension extension_name='ref'><template><target>cite web</target><arg name="title"><space/>US Patent 5969841 - Gigabaud link module with received power detect signal
<space/></arg><arg name="url"><space/>http://www.patentstorm.us/patents/5969841.html
<space/></arg><arg name="publisher"><space/>PatentStorm LLC
<space/></arg><arg name="accessdate"><space/>2009-09-08
<space/></arg><arg name="quote"><space/>An improved Gigabaud Link Module (GLM) is provided for performing bi-directional data transfers between a host device and a serial transfer medium.
</arg></template></extension>) UltraSCSI controllers</listitem><listitem>scsi: Small Computer Serial Interface (SCSI) devices</listitem><listitem>sf: soc+ or social Fiber Channel Arbitrated Loop (FCAL)</listitem><listitem>soc: SPARC Storage Array (SSA) controllers and the control device</listitem><listitem>social: Serial optical controllers for FCAL (soc+)</listitem></list><heading level='2'>APIs</heading><list type='bullet'><listitem><link><target>Windows Display Driver Model</target></link><space/>(WDDM) the graphic display driver architecture for<space/><link><target>Windows Vista</target></link>,<space/><link><target>Windows 7</target></link><space/>and<space/><link><target>Windows 8</target></link>.</listitem><listitem>Unified Audio Model (UAM)</listitem><listitem><link><target>Windows Driver Foundation</target></link><space/>(WDF)</listitem><listitem><link><target>Windows Driver Model</target></link><space/>(WDM)</listitem><listitem><link><target>Network Driver Interface Specification</target></link><space/>(NDIS) a standard<space/><link><target>network card</target></link><space/>driver API</listitem><listitem><link><target>Advanced Linux Sound Architecture</target></link><space/>(ALSA)<space/><template><target>as of</target><arg><space/>2009<space/></arg><arg name="lc"><space/>on</arg></template><space/>the standard Linux sound-driver interface</listitem><listitem><link><target>Scanner Access Now Easy</target></link><space/>(SANE) a public-domain interface to raster-image scanner-hardware</listitem><listitem><link><target>I/O Kit</target></link><space/>an open-source framework from<space/><link><target>Apple Computer</target><part>Apple</part></link><space/>for developing<space/><link><target>Mac OS X</target></link><space/>device drivers</listitem><listitem><link><target>Installable File System</target></link><space/>(IFS) a<space/><link><target>filesystem API</target></link><space/>for IBM OS/2 and Microsoft Windows NT</listitem><listitem><link><target>Open Data-Link Interface</target></link><space/>(ODI) a network card API similar to NDIS</listitem><listitem><link><target>Uniform Driver Interface</target></link><space/>(UDI) a cross-platform driver interface project</listitem><listitem><link><target>Dynax Driver Framework</target></link><space/>(dxd) C++ open source cross-platform driver framework for KMDF and IOKit</listitem></list><heading level='2'>Identifiers</heading><paragraph>A device on the<space/><link><target>Conventional_PCI</target><part>PCI bus</part></link><space/>or USB is identified by two IDs which consist of 4<space/><link><target>hexadecimal</target></link><space/>numbers each. The vendor ID identifies the vendor of the device. The device ID identifies a specific device from that manufacturer/vendor.</paragraph><paragraph>A PCI device has often an ID pair for the main chip of the device, and also a subsystem ID pair which identifies the vendor, which may be different from the chip manufacturer.</paragraph><heading level='2'>See also</heading><paragraph><template><target>Div col</target><arg></arg><arg>22em</arg></template></paragraph><list type='bullet'><listitem><link><target>Class driver</target></link></listitem><listitem><link><target>Device driver synthesis and verification</target></link></listitem><listitem><link><target>Driver wrapper</target></link></listitem><listitem><link><target>Free software</target></link></listitem><listitem><link><target>Firmware</target></link></listitem><listitem><link><target>Interrupt</target></link></listitem><listitem><link><target>Loadable kernel module</target></link></listitem><listitem><link><target>Makedev</target></link></listitem><listitem><link><target>Open-source hardware</target></link></listitem><listitem><link><target>Printer driver</target></link></listitem><listitem><link><target>Replicant (operating system)</target></link></listitem><listitem><link><target>udev</target></link></listitem></list><paragraph><template><target>Div col end</target></template></paragraph><heading level='2'>References</heading><paragraph><template><target>Reflist</target><arg>30em</arg></template></paragraph><heading level='2'>External links</heading><preblock><preline>*<space/><link type='external' href='http://www.microsoft.com/whdc'>Microsoft Windows Hardware Developer Central</link></preline></preblock><list type='bullet'><listitem><link type='external' href='http://myfixbase.com'>The database of Windows drivers</link></listitem><listitem><link type='external' href='http://www.filehelp.info/drivers'>FileHelp - Database of drivers</link></listitem><listitem><link type='external' href='http://www.linux-drivers.org'>Linux Hardware Compatibility Lists and Linux Drivers</link></listitem><listitem><link type='external' href='http://pages.cs.wisc.edu/~kadav/study/study.pdf'>Understanding Modern Device Drivers(Linux)</link></listitem><listitem><link type='external' href='https://help.ubuntu.com/community/BinaryDriverHowto/'>BinaryDriverHowto, Ubuntu.</link></listitem><listitem><link type='external' href='http://howtoupdatedrivershq.com/how-to-update-drivers-the-manual-way/'>How To Update Device Drivers Manual</link></listitem></list><paragraph><template><target>Operating System</target></template></paragraph><paragraph><template><target>Authority control</target></template><template><target>DEFAULTSORT:Device Driver</target></template><link><target>Category:Device drivers</target><part></part></link><link><target>Category:Linux drivers</target></link><link><target>Category:Computing terminology</target></link><link><target>Category:Windows NT kernel</target></link></paragraph></article>