<article title='Chomsky_normal_form'><paragraph>In<space/><link><target>formal language</target></link><space/>theory, a<space/><link><target>context-free grammar</target></link><space/><italics>G</italics><space/>is said to be in<space/><bold>Chomsky normal form</bold><space/>(discovered by<space/><link><target>Noam Chomsky</target></link>)<extension extension_name='ref'><template><target>cite journal</target><arg name="first">Noam<space/></arg><arg name="last">Chomsky</arg><arg name="title">On Certain Formal Properties of Grammars</arg><arg name="journal">Information and Control</arg><arg name="year">1959</arg><arg name="volume">2</arg><arg name="pages">137–167</arg><arg name="doi">10.1016/S0019-9958(59)90362-6<space/></arg><arg name="url">http://www.sciencedirect.com/science/article/pii/S0019995859903626/pdf?md5</arg></template></extension><space/>if all of its<space/><link><target>production (computer science)</target><part>production rules</part></link><space/>are of the form:<extension extension_name='ref' name="Hopcroft.Ullman.1979"><template><target>cite book</target><arg name="first1">John E.<space/></arg><arg name="last1">Hopcroft<space/></arg><arg name="first2">Jeffrey D.</arg><arg name="last2">Ullman</arg><arg name="title">Introduction to Automata Theory, Languages and Computation</arg><arg name="publisher">Addison-Wesley Publishing</arg><arg name="location">Reading, Massachusetts</arg><arg name="date">1979</arg><arg name="isbn">0-201-02988-X</arg></template></extension><template><target>rp</target><arg>92–93,106</arg></template></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>BC</italics>, &amp;nbsp; or</listitem><listitem><italics>A</italics><space/><italics>a</italics>, &amp;nbsp; or</listitem><listitem><italics>S</italics><space/>,</listitem></list><paragraph>where<space/><italics>A</italics>,<space/><italics>B</italics>, and<space/><italics>C</italics><space/>are<space/><link><target>nonterminal symbol</target><trail>s</trail></link>,<space/><italics>a</italics><space/>is a<space/><link><target>terminal symbol</target></link><space/>(a symbol that represents a constant value),<space/><italics>S</italics><space/>is the start symbol, and denotes the<space/><link><target>empty string</target></link>. Also, neither<space/><italics>B</italics><space/>nor<space/><italics>C</italics><space/>may be the<space/><link><target>Start symbol (formal languages)</target><part>start symbol</part></link>, and the third production rule can only appear if is in<space/><italics>L</italics>(<italics>G</italics>), namely, the language produced by the context-free grammar<space/><italics>G</italics>.</paragraph><paragraph>Every grammar in Chomsky normal form is<space/><link><target>Context-free grammar</target><part>context-free</part></link>, and conversely, every context-free grammar can be transformed into an equivalent one which is in Chomsky normal form and has a size no larger than the square of the original grammar's size.</paragraph><heading level='2'>Converting a grammar to Chomsky normal form</heading><paragraph>To convert a grammar to Chomsky normal form, a sequence of simple transformations is applied in a certain order; this is described in most textbooks on automata theory.<extension extension_name='ref' name="Hopcroft.Ullman.1979"></extension><template><target>rp</target><arg>87–94</arg></template><extension extension_name='ref'><template><target>cite book</target><arg name="first1">John E.</arg><arg name="last1">Hopcroft</arg><arg name="first2">Rajeev</arg><arg name="last2">Motwani</arg><arg name="first3">Jeffrey D.<space/></arg><arg name="last3">Ullman</arg><arg name="title">Introduction to Automata Theory, Languages, and Computation</arg><arg name="edition">3rd<space/></arg><arg name="publisher">Addison-Wesley</arg><arg name="date">2006</arg><arg name="isbn">0-321-45536-3</arg></template><space/>Section 7.1.5, p.272</extension><extension extension_name='ref'><template><target>cite book</target><arg name="author">Elaine Rich<space/></arg><arg name="editor"><space/></arg><arg name="title">Automata, Computability, and Complexity: Theory and Applications<space/></arg><arg name="location"><space/></arg><arg name="publisher">Prentice-Hall<space/></arg><arg name="series"><space/></arg><arg name="volume"><space/></arg><arg name="edition">1st<space/></arg><arg name="isbn">978-0132288064<space/></arg><arg name="year">2007<space/></arg></template><template><target>page needed</target><arg name="date">May 2015</arg></template></extension><extension extension_name='ref'><template><target>cite book</target><arg name="author">Ingo Wegener<space/></arg><arg name="title">Theoretische Informatik - Eine algorithmenorientierte Einführung</arg><arg name="location">Stuttgart<space/></arg><arg name="publisher">B.G. Teubner<space/></arg><arg name="series">Leitfäden und Mongraphien der Informatik<space/></arg><arg name="year">1993<space/></arg><arg name="isbn">978-3-519-02123-0</arg></template><space/>Section 6.2 &quot;Die Chomsky-Normalform fr kontextfreie Grammatiken&quot;, p.149-152</extension>The presentation here follows Hopcroft, Ullman (1979), but is adapted to use the transformation names from Lange, Lei (2009).<extension extension_name='ref' name="Lange.Leis.2009"><template><target>cite journal</target><arg name="url">http://ddi.cs.uni-potsdam.de/InformaticaDidactica/LangeLeiss2009.pdf</arg><arg name="last1">Lange</arg><arg name="first1">Martin<space/></arg><arg name="last2"><space/>Leiß</arg><arg name="first2">Hans</arg><arg name="title">To CNF or not to CNF? An Efficient Yet Presentable Version of the CYK Algorithm</arg><arg name="journal">[http://www.informatica-didactica.de/cmsmadesimple/index.php?page</arg><arg name="volume">8</arg><arg name="date">2009</arg></template></extension><extension extension_name='ref' group="note">For example, Hopcroft, Ullman (1979) merged<space/><bold>TERM</bold><space/>and<space/><bold>BIN</bold><space/>into a single transformation.</extension><space/>Each of the following transformations establishes one of the properties required for Chomsky normal form.</paragraph><heading level='3'>START: Eliminate the start symbol from right-hand sides</heading><paragraph>Introduce a new start symbol<space/><italics>S</italics><xhtml:sub>0</xhtml:sub>, and a new rule<space/></paragraph><list type='ident'><listitem><italics>S</italics><xhtml:sub>0</xhtml:sub><space/><italics>S</italics>,<space/></listitem></list><paragraph>where<space/><italics>S</italics><space/>is the previous start symbol.This doesn't change the grammar's produced language, and<space/><italics>S</italics><xhtml:sub>0</xhtml:sub><space/>won't occur on any rule's right-hand side.</paragraph><heading level='3'>TERM: Eliminate rules with nonsolitary terminals</heading><paragraph>To eliminate each rule<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>a</italics><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub></listitem></list><paragraph>with a terminal symbol<space/><italics>a</italics><space/>being not the only symbol on the right-hand side, introduce, for every such terminal, a new nonterminal symbol<space/><italics>N</italics><xhtml:sub><italics>a</italics></xhtml:sub>, and a new rule<space/></paragraph><list type='ident'><listitem><italics>N</italics><xhtml:sub><italics>a</italics></xhtml:sub><space/><italics>a</italics>.<space/></listitem></list><paragraph>Change every rule<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>a</italics><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/></listitem></list><paragraph>to<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>N</italics><xhtml:sub><italics>a</italics></xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub>.</listitem></list><paragraph>If several terminal symbols occur on the right-hand side, simultaneously replace each of them by its associated nonterminal symbol.This doesn't change the grammar's produced language.<extension extension_name='ref' name="Hopcroft.Ullman.1979"></extension><template><target>rp</target><arg>92</arg></template></paragraph><heading level='3'>BIN: Eliminate right-hand sides with more than 2 nonterminals</heading><paragraph>Replace each rule<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/><italics>X</italics><xhtml:sub>2</xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/></listitem></list><paragraph>with more than 2 nonterminals<space/><italics>X</italics><xhtml:sub>1</xhtml:sub>,...,<italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/>by rules<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/><italics>A</italics><xhtml:sub>1</xhtml:sub>,<space/></listitem><listitem><italics>A</italics><xhtml:sub>1</xhtml:sub><space/><italics>X</italics><xhtml:sub>2</xhtml:sub><space/><italics>A</italics><xhtml:sub>2</xhtml:sub>,<space/></listitem><listitem>... ,<space/></listitem><listitem><italics>A</italics><xhtml:sub><italics>n</italics>-2</xhtml:sub><space/><italics>X</italics><xhtml:sub><italics>n</italics>-1</xhtml:sub><space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub>,<space/></listitem></list><paragraph>where<space/><italics>A</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>are new nonterminal symbols.Again, this doesn't change the grammar's produced language.<extension extension_name='ref' name="Hopcroft.Ullman.1979"></extension><template><target>rp</target><arg>93</arg></template></paragraph><heading level='3'>DEL: Eliminate -rules</heading><paragraph>An -rule is a rules of the form<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/>,<space/></listitem></list><paragraph>where<space/><italics>A</italics><space/>is not the grammar's start symbol.</paragraph><paragraph>To eliminate all rules of this form, first determine the set of all nonterminals that derive .Hopcroft and Ullman (1979) call such nonterminals<space/><italics>nullable</italics>, and compute them as follows:</paragraph><list type='bullet'><listitem>If a rule<space/><italics>A</italics><space/>exists, then<space/><italics>A</italics><space/>is nullable.</listitem><listitem>If a rule<space/><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/>exists, and each<space/><italics>X</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>is nullable, then<space/><italics>A</italics><space/>is nullable, too.</listitem></list><paragraph>Obtain an intermediate grammar by replacing each rule<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/></listitem></list><paragraph>by all versions with some nullable<space/><italics>X</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>omitted.By deleting in this grammar each -rule, unless its left-hand side is the start symbol, the transformed grammar is obtained.<extension extension_name='ref' name="Hopcroft.Ullman.1979"></extension><template><target>rp</target><arg>90</arg></template></paragraph><paragraph>For example, in the following grammar, with start symbol<space/><italics>S</italics><xhtml:sub>0</xhtml:sub>,</paragraph><list type='ident'><listitem><italics>S</italics><xhtml:sub>0</xhtml:sub><space/><italics>AbB</italics><space/>|<space/><italics>C</italics></listitem><listitem><italics>B</italics><space/><italics>AA</italics><space/>|<space/><italics>AC</italics></listitem><listitem><italics>C</italics><space/><italics>b</italics><space/>|<space/><italics>c</italics></listitem><listitem><italics>A</italics><space/><italics>a</italics><space/>|<space/></listitem></list><paragraph>the nonterminal<space/><italics>A</italics>, and hence also<space/><italics>B</italics>, is nullable, while neither<space/><italics>C</italics><space/>nor<space/><italics>S</italics><xhtml:sub>0</xhtml:sub><space/>is.Hence the following intermediate grammar is obtained:<extension extension_name='ref' group="note">indicating a kept and omitted nonterminal<space/><italics>N</italics><space/>by<space/><italics><template><target>color</target><arg>#006000</arg><arg>N</arg></template></italics><space/>and<space/><italics><template><target>color</target><arg>#ffc0c0</arg><arg><s>N</s></arg></template></italics>, respectively</extension></paragraph><list type='ident'><listitem><italics>S</italics><xhtml:sub>0</xhtml:sub><space/><italics><template><target>color</target><arg>#006000</arg><arg>A</arg></template>b<template><target>color</target><arg>#006000</arg><arg>B</arg></template></italics><space/>|<space/><italics><template><target>color</target><arg>#006000</arg><arg>A</arg></template>b<template><target>color</target><arg>#ffc0c0</arg><arg><s>B</s></arg></template></italics><space/>|<space/><italics><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template>b<template><target>color</target><arg>#006000</arg><arg>B</arg></template></italics><space/>|<space/><italics><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template>b<template><target>color</target><arg>#ffc0c0</arg><arg><s>B</s></arg></template></italics><space/>&amp;nbsp; | &amp;nbsp;<space/><italics>C</italics></listitem><listitem><italics>B</italics><space/><italics><template><target>color</target><arg>#006000</arg><arg>AA</arg></template></italics><space/>|<space/><italics><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template><template><target>color</target><arg>#006000</arg><arg>A</arg></template></italics><space/>|<space/><italics><template><target>color</target><arg>#006000</arg><arg>A</arg></template><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template></italics><space/>|<space/><italics><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template></italics><space/>&amp;nbsp; | &amp;nbsp;<space/><italics><template><target>color</target><arg>#006000</arg><arg>A</arg></template>C</italics><space/>|<space/><italics><template><target>color</target><arg>#ffc0c0</arg><arg><s>A</s></arg></template>C</italics></listitem><listitem><italics>C</italics><space/><italics>b</italics><space/>|<space/><italics>c</italics></listitem><listitem><italics>A</italics><space/><italics>a</italics><space/>|<space/></listitem></list><paragraph>In this grammar, all -rules have been &quot;<link><target>inlining</target><part>inlined</part></link><space/>at the call site&quot;.<extension extension_name='ref' group="note">If the grammar had a rule<space/><italics>S</italics><xhtml:sub>0</xhtml:sub><space/>, it could not be &quot;inlined&quot;, since it had no &quot;call sites&quot;. Therefore it couldn't be deleted in the next step.</extension>In the next step, they can hence be deleted, yielding the grammar:</paragraph><list type='ident'><listitem><italics>S</italics><xhtml:sub>0</xhtml:sub><space/><italics>AbB</italics><space/>|<space/><italics>Ab</italics><space/>|<space/><italics>bB</italics><space/>|<space/><italics>b</italics><space/>&amp;nbsp; | &amp;nbsp;<space/><italics>C</italics></listitem><listitem><italics>B</italics><space/><italics>AA</italics><space/>|<space/><italics>A</italics><space/>&amp;nbsp; | &amp;nbsp;<space/><italics>AC</italics><space/>|<space/><italics>C</italics></listitem><listitem><italics>C</italics><space/><italics>b</italics><space/>|<space/><italics>c</italics></listitem><listitem><italics>A</italics><space/><italics>a</italics></listitem></list><paragraph>This grammar produces the same language as the original example grammar, viz. {<italics>ab</italics>,<italics>aba</italics>,<italics>abaa</italics>,<italics>abab</italics>,<italics>abac</italics>,<italics>abb</italics>,<italics>abc</italics>,<italics>b</italics>,<italics>bab</italics>,<italics>bac</italics>,<italics>bb</italics>,<italics>bc</italics>,<italics>c</italics>}, but apparently has no -rules.</paragraph><heading level='3'>UNIT: Eliminate unit rules</heading><paragraph>A unit rule is a rule of the form<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>B</italics>,<space/></listitem></list><paragraph>where<space/><italics>A</italics>,<space/><italics>B</italics><space/>are nonterminal symbols.To remove it, for each rule<space/></paragraph><list type='ident'><listitem><italics>B</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub>,<space/></listitem></list><paragraph>where<space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/>is a string of nonterminals and terminals, add rule<space/></paragraph><list type='ident'><listitem><italics>A</italics><space/><italics>X</italics><xhtml:sub>1</xhtml:sub><space/>...<space/><italics>X</italics><xhtml:sub><italics>n</italics></xhtml:sub><space/></listitem></list><paragraph>unless this is a unit rule which has already been removed.</paragraph><heading level='3'>Order of transformations</heading><table class="wikitable collapsible collapsed" style="float:right"><tablerow><tablehead colspan="6">Mutual preservation<xhtml:br></xhtml:br>of transformation results</tablehead></tablerow><tablerow><tablecell colspan="6">Transformation<space/><italics>X</italics><space/><template><target>color</target><arg>#004000</arg><arg>always perserves</arg></template><space/>(<template><target>Y&amp;</target></template>)<xhtml:br></xhtml:br>resp.<space/><template><target>color</target><arg>#400000</arg><arg>may destroy</arg></template><space/>(<template><target>N&amp;</target></template>) the result of<space/><italics>Y</italics>:</tablecell></tablerow><tablerow><tablecell><xhtml:sub><italics>X</italics></xhtml:sub><bold>\</bold><xhtml:sup><italics>Y</italics></xhtml:sup></tablecell><tablecell><bold>START</bold></tablecell><tablecell><bold>TERM</bold></tablecell><tablecell><bold>BIN</bold></tablecell><tablecell><bold>DEL</bold></tablecell><tablecell><bold>UNIT</bold></tablecell></tablerow><tablerow><tablecell><bold>START</bold></tablecell><tablecell></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>N&amp;</target></template></tablecell></tablerow><tablerow><tablecell><bold>TERM</bold></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell></tablecell><tablecell><template><target>N&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell></tablerow><tablerow><tablecell><bold>BIN</bold></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell></tablerow><tablerow><tablecell><bold>DEL</bold></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell></tablecell><tablecell><template><target>N&amp;</target></template></tablecell></tablerow><tablerow><tablecell><bold>UNIT</bold></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell><template><target>Y&amp;</target></template></tablecell><tablecell>(<template><target>Y&amp;</target></template>)<xhtml:sup><list type='bullet'><listitem></listitem></list></xhtml:sup></tablecell><tablecell></tablecell></tablerow><tablerow><tablecell colspan="6"><xhtml:sup><list type='bullet'><listitem></listitem></list></xhtml:sup><bold>UNIT</bold><space/>preserves the result of<space/><bold>DEL</bold><xhtml:br></xhtml:br>&amp;nbsp; if<space/><bold>START</bold><space/>had been called before.</tablecell></tablerow></table><paragraph>When choosing the order in which the above transformations are to be applied, it has to be considered that some transformations may destroy the result achieved by other ones. For example,<space/><bold>START</bold><space/>will re-introduce a unit rule if it is applied after<space/><bold>UNIT</bold>. The table shows which orderings are admitted.</paragraph><paragraph>Moreover, the worst-case bloat in grammar size<extension extension_name='ref' group="note">i.e. written length, measured in symbols</extension><space/>depends on the transformation order. Using |<italics>G</italics>| to denote the size of the original grammar<space/><italics>G</italics>, the size blow-up in the worst case may range from |<italics>G</italics>|<xhtml:sup>2</xhtml:sup><space/>to 2<xhtml:sup>2 |G|</xhtml:sup>, depending on the transformation algorithm used.<extension extension_name='ref' name="Lange.Leis.2009"></extension><template><target>rp</target><arg>7</arg></template><space/>The blow-up in grammar size depends on the order between<space/><bold>DEL</bold><space/>and<space/><bold>BIN</bold>. It may be exponential when<space/><bold>DEL</bold><space/>is done first, but is linear otherwise.<space/><bold>UNIT</bold><space/>can incur a quadratic blow-up in the size of the grammar.<extension extension_name='ref' name="Lange.Leis.2009"></extension><template><target>rp</target><arg>5</arg></template><space/>The orderings<space/><bold>START</bold>,<bold>TERM</bold>,<bold>BIN</bold>,<bold>DEL</bold>,<bold>UNIT</bold><space/>and<space/><bold>START</bold>,<bold>BIN</bold>,<bold>DEL</bold>,<bold>UNIT</bold>,<bold>TERM</bold><space/>lead to the least (i.e. quadratic) blow-up.</paragraph><heading level='2'>Example</heading><paragraph><link><target>File:Syntax tree of arithmetic expression wrt Chomsky normal form grammar.gif</target><part>thumb</part><part><link><target>Abstract syntax tree</target></link><space/>of the<space/><link><target>expression (mathematics)</target><part>arithmetic expression</part></link><space/>&quot;''a''^2+4*''b''&quot; wrt. the example grammar ('''top''') and its Chomsky normal form ('''bottom''')</part></link>The following grammar, with start symbol<space/><italics>Expr</italics>, describes a simplified version of the set of all syntactical valid arithmetic expressions in imperative programming languages like<space/><link><target>C (programming language)</target><part>C</part></link><space/>or<space/><link><target>Algol60</target></link>. Both<space/><italics>number</italics><space/>and<space/><italics>variable</italics><space/>are considered terminal symbols here for simplicity, since in a<space/><link><target>compiler front-end</target></link><space/>their internal structure is usually not considered by the<space/><link><target>parser</target></link>. The terminal symbol &quot;^&quot; denoted<space/><link><target>exponentiation</target></link><space/>in Algol60.</paragraph><list type='ident'><listitem><table><tablerow><tablecell><italics>Expr</italics></tablecell><tablecell><space/><italics>Term</italics></tablecell><tablecell><space/><italics>Expr</italics><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell><tablecell><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>Term</italics></tablecell><tablecell><space/><italics>Factor</italics></tablecell><tablecell><space/><italics>Term</italics><space/><italics>MulOp</italics><space/><italics>Factor</italics></tablecell></tablerow><tablerow><tablecell><italics>Factor</italics></tablecell><tablecell><space/><italics>Primary</italics></tablecell><tablecell><space/><italics>Factor</italics><space/>^<space/><italics>Primary</italics></tablecell></tablerow><tablerow><tablecell><italics>Primary</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/>(<space/><italics>Expr</italics><space/>)</tablecell></tablerow><tablerow><tablecell><italics>AddOp</italics></tablecell><tablecell><space/>+</tablecell><tablecell><space/>&amp;minus;</tablecell></tablerow><tablerow><tablecell><italics>MulOp</italics></tablecell><tablecell><space/>*</tablecell><tablecell><space/>/</tablecell></tablerow></table>In step &quot;START&quot; of the<space/><link><target>#Converting a grammar to Chomsky Normal Form</target><part>above</part></link><space/>conversion algorithm, just a rule<space/><italics>S</italics><xhtml:sub>0</xhtml:sub><italics>Expr</italics><space/>is added to the grammar.</listitem></list><paragraph>After step &quot;TERM&quot;, the grammar looks like this:</paragraph><list type='ident'><listitem><table><tablerow><tablecell><italics>S</italics><xhtml:sub>0</xhtml:sub></tablecell><tablecell><space/><italics>Expr</italics></tablecell></tablerow><tablerow><tablecell><italics>Expr</italics></tablecell><tablecell><space/><italics>Term</italics></tablecell><tablecell><space/><italics>Expr</italics><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell><tablecell><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>Term</italics></tablecell><tablecell><space/><italics>Factor</italics></tablecell><tablecell><space/><italics>Term</italics><space/><italics>MulOp</italics><space/><italics>Factor</italics></tablecell></tablerow><tablerow><tablecell><italics>Factor</italics></tablecell><tablecell><space/><italics>Primary</italics></tablecell><tablecell><space/><italics>Factor</italics><space/><italics>PowOp</italics><space/><italics>Primary</italics></tablecell></tablerow><tablerow><tablecell><italics>Primary</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr</italics><space/><italics>Close</italics></tablecell></tablerow><tablerow><tablecell><italics>AddOp</italics></tablecell><tablecell><space/>+</tablecell><tablecell><space/>&amp;minus;</tablecell></tablerow><tablerow><tablecell><italics>MulOp</italics></tablecell><tablecell><space/>*</tablecell><tablecell><space/>/</tablecell></tablerow><tablerow><tablecell><italics>PowOp</italics></tablecell><tablecell><space/>^</tablecell></tablerow><tablerow><tablecell><italics>Open</italics></tablecell><tablecell><space/>(</tablecell></tablerow><tablerow><tablecell><italics>Close</italics></tablecell><tablecell><space/>)</tablecell></tablerow></table>After step &quot;BIN&quot;, the following grammar is obtained:</listitem></list><list type='ident'><listitem><table><tablerow><tablecell><italics>S</italics><xhtml:sub>0</xhtml:sub></tablecell><tablecell><space/><italics>Expr</italics></tablecell></tablerow><tablerow><tablecell><italics>Expr</italics></tablecell><tablecell><space/><italics>Term</italics></tablecell><tablecell><space/><italics>Expr</italics><space/><italics>AddOp_Term</italics></tablecell><tablecell><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>Term</italics></tablecell><tablecell><space/><italics>Factor</italics></tablecell><tablecell><space/><italics>Term</italics><space/><italics>MulOp_Factor</italics></tablecell></tablerow><tablerow><tablecell><italics>Factor</italics></tablecell><tablecell><space/><italics>Primary</italics></tablecell><tablecell><space/><italics>Factor</italics><space/><italics>PowOp_Primary</italics></tablecell></tablerow><tablerow><tablecell><italics>Primary</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr_Close</italics></tablecell></tablerow><tablerow><tablecell><italics>AddOp</italics></tablecell><tablecell><space/>+</tablecell><tablecell><space/>&amp;minus;</tablecell></tablerow><tablerow><tablecell><italics>MulOp</italics></tablecell><tablecell><space/>*</tablecell><tablecell><space/>/</tablecell></tablerow><tablerow><tablecell><italics>PowOp</italics></tablecell><tablecell><space/>^</tablecell></tablerow><tablerow><tablecell><italics>Open</italics></tablecell><tablecell><space/>(</tablecell></tablerow><tablerow><tablecell><italics>Close</italics></tablecell><tablecell><space/>)</tablecell></tablerow><tablerow><tablecell><italics>AddOp_Term</italics></tablecell><tablecell colspan="3"><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>MulOp_Factor</italics></tablecell><tablecell colspan="3"><space/><italics>MulOp</italics><space/><italics>Factor</italics></tablecell></tablerow><tablerow><tablecell><italics>PowOp_Primary</italics></tablecell><tablecell colspan="3"><space/><italics>PowOp</italics><space/><italics>Primary</italics></tablecell></tablerow><tablerow><tablecell><italics>Expr_Close</italics></tablecell><tablecell colspan="3"><space/><italics>Expr</italics><space/><italics>Close</italics></tablecell></tablerow></table>Since there are no -rules, step &quot;DEL&quot; doesn't change the grammar.</listitem></list><paragraph>After step &quot;UNIT&quot;, the following grammar is obtained, which is in Chomsky normal form:</paragraph><list type='ident'><listitem><table><tablerow><tablecell><italics>S</italics><xhtml:sub>0</xhtml:sub></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr_Close</italics></tablecell><tablecell><space/><italics>Factor</italics><space/><italics>PowOp_Primary</italics></tablecell><tablecell><space/><italics>Term</italics><space/><italics>MulOp_Factor</italics></tablecell><tablecell><space/><italics>Expr</italics><space/><italics>AddOp_Term</italics></tablecell><tablecell><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>Expr</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr_Close</italics></tablecell><tablecell><space/><italics>Factor</italics><space/><italics>PowOp_Primary</italics></tablecell><tablecell><space/><italics>Term</italics><space/><italics>MulOp_Factor</italics></tablecell><tablecell><space/><italics>Expr</italics><space/><italics>AddOp_Term</italics></tablecell><tablecell><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>Term</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr_Close</italics></tablecell><tablecell><space/><italics>Factor</italics><space/><italics>PowOp_Primary</italics></tablecell><tablecell><space/><italics>Term</italics><space/><italics>MulOp_Factor</italics></tablecell></tablerow><tablerow><tablecell><italics>Factor</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr_Close</italics></tablecell><tablecell><space/><italics>Factor</italics><space/><italics>PowOp_Primary</italics></tablecell></tablerow><tablerow><tablecell><italics>Primary</italics></tablecell><tablecell><space/><italics>number</italics></tablecell><tablecell><space/><italics>variable</italics></tablecell><tablecell><space/><italics>Open</italics><space/><italics>Expr_Close</italics></tablecell></tablerow><tablerow><tablecell><italics>AddOp</italics></tablecell><tablecell><space/>+</tablecell><tablecell><space/>&amp;minus;</tablecell></tablerow><tablerow><tablecell><italics>MulOp</italics></tablecell><tablecell><space/>*</tablecell><tablecell><space/>/</tablecell></tablerow><tablerow><tablecell><italics>PowOp</italics></tablecell><tablecell><space/>^</tablecell></tablerow><tablerow><tablecell><italics>Open</italics></tablecell><tablecell><space/>(</tablecell></tablerow><tablerow><tablecell><italics>Close</italics></tablecell><tablecell><space/>)</tablecell></tablerow><tablerow><tablecell><italics>AddOp_Term</italics></tablecell><tablecell colspan="3"><space/><italics>AddOp</italics><space/><italics>Term</italics></tablecell></tablerow><tablerow><tablecell><italics>MulOp_Factor</italics></tablecell><tablecell colspan="3"><space/><italics>MulOp</italics><space/><italics>Factor</italics></tablecell></tablerow><tablerow><tablecell><italics>PowOp_Primary</italics></tablecell><tablecell colspan="3"><space/><italics>PowOp</italics><space/><italics>Primary</italics></tablecell></tablerow><tablerow><tablecell><italics>Expr_Close</italics></tablecell><tablecell colspan="3"><space/><italics>Expr</italics><space/><italics>Close</italics></tablecell></tablerow></table>The<space/><italics>N</italics><xhtml:sub><italics>a</italics></xhtml:sub><space/>introduced in step &quot;TERM&quot; are<space/><italics>PowOp</italics>,<space/><italics>Open</italics>, and<space/><italics>Close</italics>.</listitem></list><paragraph>The<space/><italics>A</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>introduced in step &quot;BIN&quot; are<space/><italics>AddOp_Term</italics>,<space/><italics>MulOp_Factor</italics>,<space/><italics>PowOp_Primary</italics>, and<space/><italics>Expr_Close</italics>.</paragraph><heading level='2'>Alternative definition</heading><heading level='3'>Chomsky reduced form</heading><paragraph>Another way<extension extension_name='ref' name="Hopcroft.Ullman.1979"></extension><template><target>rp</target><arg>92</arg></template><extension extension_name='ref'>Hopcroft et al. (2006)<template><target>page needed</target><arg name="date">November 2014</arg></template></extension><space/>to define the Chomsky normal form is:</paragraph><paragraph>A<space/><link><target>formal grammar</target></link><space/>is in<space/><bold>Chomsky reduced form</bold><space/>if all of its production rules are of the form:</paragraph><list type='ident'><listitem><extension extension_name='math'>A \rightarrow\, BC</extension><space/>or</listitem><listitem><extension extension_name='math'>A \rightarrow\, a</extension>,</listitem></list><paragraph>where<space/><extension extension_name='math'>A</extension>,<space/><extension extension_name='math'>B</extension><space/>and<space/><extension extension_name='math'>C</extension><space/>are nonterminal symbols, and<space/><extension extension_name='math'>a</extension><space/>is a<space/><link><target>terminal symbol</target></link>. When using this definition,<space/><extension extension_name='math'>B</extension><space/>or<space/><extension extension_name='math'>C</extension><space/>may be the start symbol. Only those context-free grammars which do not generate the<space/><link><target>empty string</target></link><space/>can be transformed into Chomsky reduced form.</paragraph><heading level='3'>Floyd normal form</heading><paragraph>In a paper where he proposed a term<space/><link><target>Backus-Naur Form</target></link><space/>(BNF),<space/><link><target>Donald E. Knuth</target></link><space/>implied a BNF &quot;syntax in which all definitions have such a form may be said to be in &quot;Floyd Normal Form&quot;,&quot;</paragraph><list type='ident'><listitem><extension extension_name='math'>\langle A \rangle ::= \, \langle B \rangle \mid \langle C \rangle</extension><space/>or</listitem><listitem><extension extension_name='math'>\langle A \rangle ::= \, \langle B \rangle \langle C \rangle</extension><space/>or</listitem><listitem><extension extension_name='math'>\langle A \rangle ::=\, a</extension>,</listitem></list><paragraph>where<space/><extension extension_name='math'>\langle A \rangle</extension>,<space/><extension extension_name='math'>\langle B \rangle</extension><space/>and<space/><extension extension_name='math'>\langle C \rangle</extension><space/>are nonterminal symbols, and<space/><extension extension_name='math'>a</extension><space/>is a<space/><link><target>terminal symbol</target></link>,because<space/><link><target>Robert W. Floyd</target></link><space/>found any BNF syntax can be converted to the above one in 1961.<extension extension_name='ref' name="knuth1964"><template><target>cite journal</target><arg name="last">Knuth</arg><arg name="first">Donald E.</arg><arg name="date">December 1964</arg><arg name="title">Backus Normal Form vs. Backus Naur Form</arg><arg name="journal">Communications of the ACM</arg><arg name="volume">7</arg><arg name="issue">12</arg><arg name="pages">735–736</arg><arg name="month"></arg><arg name="doi">10.1145/355588.365140</arg></template></extension><space/>But he withdrew this term, &quot;since doubtless many people have independently used this simple fact in their own work, and the point is only incidental to the main considerations of Floyd's note.&quot;<extension extension_name='ref' name="knuth1964"></extension></paragraph><heading level='2'>Application</heading><paragraph>Besides its theoretical significance, CNF conversion is used in some algorithms as a preprocessing step, e.g., the<space/><link><target>CYK algorithm</target></link>, a<space/><link><target>bottom-up parsing</target></link><space/>for context-free grammars, and its variant probabilistic CKY.<extension extension_name='ref'><template><target>cite book</target><arg name="first1"><space/>Daniel
</arg><arg name="last1">Jurafsky
<space/></arg><arg name="first2"><space/>James H. 
</arg><arg name="last2">Martin
<space/></arg><arg name="year"><space/>2008
<space/></arg><arg name="title"><space/>Speech and Language Processing
<space/></arg><arg name="edition"><space/>2nd
<space/></arg><arg name="publisher"><space/>Pearson Prentice Hall
<space/></arg><arg name="isbn"><space/>978-0-13-187321-6
<space/></arg><arg name="page">465
<space/></arg></template></extension></paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Backus-Naur form</target></link></listitem><listitem><link><target>CYK algorithm</target></link></listitem><listitem><link><target>Greibach normal form</target></link></listitem><listitem><link><target>Kuroda normal form</target></link></listitem><listitem><link><target>Pumping lemma for context-free languages</target></link><space/>&amp;mdash; its proof relies on the Chomsky normal form</listitem></list><heading level='2'>Notes</heading><paragraph><template><target>reflist</target><arg name="group">note</arg></template></paragraph><heading level='2'>References</heading><paragraph><extension extension_name='references'></extension></paragraph><heading level='2'>Further reading</heading><list type='bullet'><listitem>Cole, Richard.<space/><italics>Converting CFGs to CNF (Chomsky Normal Form)</italics>, October 17, 2007.<space/><link type='external' href='http://cs.nyu.edu/courses/fall07/V22.0453-001/cnf.pdf'>(pdf)</link><space/>&amp;mdash; uses the order TERM, BIN, START, DEL, UNIT.</listitem><listitem><template><target>cite book</target><arg name="author"><space/>John Martin
<space/></arg><arg name="year"><space/>2003
<space/></arg><arg name="title"><space/>Introduction to Languages and the Theory of Computation 
<space/></arg><arg name="publisher"><space/>McGraw Hill
<space/></arg><arg name="isbn"><space/>0-07-232200-4
<space/></arg></template><space/><italics>(Pages 237240 of section 6.6: simplified forms and normal forms.)</italics></listitem><listitem><template><target>cite book</target><arg name="authorlink"><space/>Michael Sipser
<space/></arg><arg name="author"><space/>Michael Sipser
<space/></arg><arg name="year"><space/>1997
<space/></arg><arg name="title"><space/>Introduction to the Theory of Computation 
<space/></arg><arg name="publisher"><space/>PWS Publishing
<space/></arg><arg name="isbn"><space/>0-534-94728-X
<space/></arg></template><space/><italics>(Pages 98101 of section 2.1: context-free grammars. Page 156.)</italics></listitem><listitem>Sipser, Michael.<space/><italics>Introduction to the Theory of Computation,</italics><space/>2nd edition.</listitem></list><paragraph><link><target>Category:Formal languages</target></link><link><target>Category:Noam Chomsky</target></link></paragraph></article>