In [[formal language]] theory, a [[context-free grammar]] ''G'' is said to be in '''Chomsky normal form''' (discovered by [[Noam Chomsky]])<ref>{{cite journal| first=Noam |last=Chomsky| title=On Certain Formal Properties of Grammars| journal=Information and Control| year=1959| volume=2| pages=137–167| doi=10.1016/S0019-9958(59)90362-6 |url=http://www.sciencedirect.com/science/article/pii/S0019995859903626/pdf?md5=9d466f851651bd592afa5ee561b7a0b0&pid=1-s2.0-S0019995859903626-main.pdf}}</ref> if all of its [[production (computer science)|production rules]] are of the form:<ref name="Hopcroft.Ullman.1979">{{cite book|first1=John E. |last1=Hopcroft |first2=Jeffrey D.|last2=Ullman|title=Introduction to Automata Theory, Languages and Computation|publisher=Addison-Wesley Publishing|location=Reading, Massachusetts|date=1979|isbn=0-201-02988-X}}</ref>{{rp|92–93,106}}
: ''A'' → ''BC'', &nbsp; or
: ''A'' → ''a'', &nbsp; or
: ''S'' → ε,
where ''A'', ''B'', and ''C'' are [[nonterminal symbol]]s, ''a'' is a [[terminal symbol]] (a symbol that represents a constant value), ''S'' is the start symbol, and ε denotes the [[empty string]].  Also, neither ''B'' nor ''C'' may be the [[Start symbol (formal languages)|start symbol]], and the third production rule can only appear if ε is in ''L''(''G''), namely, the language produced by the context-free grammar ''G''.

Every grammar in Chomsky normal form is [[Context-free grammar|context-free]], and conversely, every context-free grammar can be transformed into an equivalent one which is in Chomsky normal form and has a size no larger than the square of the original grammar's size.

==Converting a grammar to Chomsky normal form==

To convert a grammar to Chomsky normal form, a sequence of simple transformations is applied in a certain order; this is described in most textbooks on automata theory.<ref name="Hopcroft.Ullman.1979"/>{{rp|87–94}}<ref>{{cite book|first1=John E.|last1=Hopcroft|first2=Rajeev|last2=Motwani|first3=Jeffrey D. |last3=Ullman|title=Introduction to Automata Theory, Languages, and Computation|edition=3rd |publisher=Addison-Wesley|date=2006|isbn=0-321-45536-3}} Section 7.1.5, p.272</ref><ref>{{cite book | author=Elaine Rich | editor= | title=Automata, Computability, and Complexity:  Theory and Applications | location= | publisher=Prentice-Hall | series= | volume= | edition=1st | isbn=978-0132288064 | year=2007 }}{{page needed|date=May 2015}}</ref><ref>{{cite book | author=Ingo Wegener | title=Theoretische Informatik - Eine algorithmenorientierte Einführung| location=Stuttgart | publisher=B.G. Teubner | series=Leitfäden und Mongraphien der Informatik | year=1993 | isbn=978-3-519-02123-0}} Section 6.2 "Die Chomsky-Normalform für kontextfreie Grammatiken", p.149-152</ref>
The presentation here follows Hopcroft, Ullman (1979), but is adapted to use the transformation names from Lange, Leiß (2009).<ref name="Lange.Leis.2009">{{cite journal |url=http://ddi.cs.uni-potsdam.de/InformaticaDidactica/LangeLeiss2009.pdf|last1=Lange|first1=Martin |last2= Leiß|first2=Hans|title=To CNF or not to CNF? An Efficient Yet Presentable Version of the CYK Algorithm|journal=[http://www.informatica-didactica.de/cmsmadesimple/index.php?page=home Informatica Didactica] |volume=8|date=2009}}</ref><ref group=note>For example, Hopcroft, Ullman (1979) merged '''TERM''' and '''BIN''' into a single transformation.</ref> Each of the following transformations establishes one of the properties required for Chomsky normal form.

===START: Eliminate the start symbol from right-hand sides===

Introduce a new start symbol ''S''<sub>0</sub>, and a new rule 
:''S''<sub>0</sub> → ''S'', 
where ''S'' is the previous start symbol.
This doesn't change the grammar's produced language, and ''S''<sub>0</sub> won't occur on any rule's right-hand side.

===TERM: Eliminate rules with nonsolitary terminals===

To eliminate each rule 
:''A'' → ''X''<sub>1</sub> ... ''a'' ... ''X''<sub>''n''</sub>
with a terminal symbol ''a'' being not the only symbol on the right-hand side, introduce, for every such terminal, a new nonterminal symbol ''N''<sub>''a''</sub>, and a new rule 
:''N''<sub>''a''</sub> → ''a''. 
Change every rule 
:''A'' → ''X''<sub>1</sub> ... ''a'' ... ''X''<sub>''n''</sub> 
to 
:''A'' → ''X''<sub>1</sub> ... ''N''<sub>''a''</sub> ... ''X''<sub>''n''</sub>.
If several terminal symbols occur on the right-hand side, simultaneously replace each of them by its associated nonterminal symbol.
This doesn't change the grammar's produced language.<ref name="Hopcroft.Ullman.1979"/>{{rp|92}}

===BIN: Eliminate right-hand sides with more than 2 nonterminals===

Replace each rule 
:''A'' → ''X''<sub>1</sub> ''X''<sub>2</sub> ... ''X''<sub>''n''</sub> 
with more than 2 nonterminals ''X''<sub>1</sub>,...,''X''<sub>''n''</sub> by rules 
:''A'' → ''X''<sub>1</sub> ''A''<sub>1</sub>, 
:''A''<sub>1</sub> → ''X''<sub>2</sub> ''A''<sub>2</sub>, 
:... , 
:''A''<sub>''n''-2</sub> → ''X''<sub>''n''-1</sub> ''X''<sub>''n''</sub>, 
where ''A''<sub>''i''</sub> are new nonterminal symbols.
Again, this doesn't change the grammar's produced language.<ref name="Hopcroft.Ullman.1979"/>{{rp|93}}

===DEL: Eliminate ε-rules===

An ε-rule is a rules of the form 
:''A'' → ε, 
where ''A'' is not the grammar's start symbol.

To eliminate all rules of this form, first determine the set of all nonterminals that derive ε.
Hopcroft and Ullman (1979) call such nonterminals ''nullable'', and compute them as follows:
* If a rule ''A'' → ε exists, then ''A'' is nullable.
* If a rule ''A'' → ''X''<sub>1</sub> ... ''X''<sub>''n''</sub> exists, and each ''X''<sub>''i''</sub> is nullable, then ''A'' is nullable, too.

Obtain an intermediate grammar by replacing each rule 
:''A'' → ''X''<sub>1</sub> ... ''X''<sub>''n''</sub> 
by all versions with some nullable ''X''<sub>''i''</sub> omitted.
By deleting in this grammar each ε-rule, unless its left-hand side is the start symbol, the transformed grammar is obtained.<ref name="Hopcroft.Ullman.1979"/>{{rp|90}}

For example, in the following grammar, with start symbol ''S''<sub>0</sub>,
: ''S''<sub>0</sub> → ''AbB'' | ''C''
: ''B'' → ''AA'' | ''AC''
: ''C'' → ''b'' | ''c''
: ''A'' → ''a'' | ε
the nonterminal ''A'', and hence also ''B'', is nullable, while neither ''C'' nor ''S''<sub>0</sub> is.
Hence the following intermediate grammar is obtained:<ref group=note>indicating a kept and omitted nonterminal ''N'' by ''{{color|#006000|N}}'' and ''{{color|#ffc0c0|<s>N</s>}}'', respectively</ref>
: ''S''<sub>0</sub> → ''{{color|#006000|A}}b{{color|#006000|B}}'' | ''{{color|#006000|A}}b{{color|#ffc0c0|<s>B</s>}}'' | ''{{color|#ffc0c0|<s>A</s>}}b{{color|#006000|B}}'' | ''{{color|#ffc0c0|<s>A</s>}}b{{color|#ffc0c0|<s>B</s>}}'' &nbsp; | &nbsp; ''C''
: ''B'' → ''{{color|#006000|AA}}'' | ''{{color|#ffc0c0|<s>A</s>}}{{color|#006000|A}}'' | ''{{color|#006000|A}}{{color|#ffc0c0|<s>A</s>}}'' | ''{{color|#ffc0c0|<s>A</s>}}ε{{color|#ffc0c0|<s>A</s>}}'' &nbsp; | &nbsp; ''{{color|#006000|A}}C'' | ''{{color|#ffc0c0|<s>A</s>}}C''
: ''C'' → ''b'' | ''c''
: ''A'' → ''a'' | ε
In this grammar, all ε-rules have been "[[inlining|inlined]] at the call site".<ref group=note>If the grammar had a rule ''S''<sub>0</sub> → ε, it could not be "inlined", since it had no "call sites". Therefore it couldn't be deleted in the next step.</ref>
In the next step, they can hence be deleted, yielding the grammar:
: ''S''<sub>0</sub> → ''AbB'' | ''Ab'' | ''bB'' | ''b'' &nbsp; | &nbsp; ''C''
: ''B'' → ''AA'' | ''A'' &nbsp; | &nbsp; ''AC'' | ''C''
: ''C'' → ''b'' | ''c''
: ''A'' → ''a''
This grammar produces the same language as the original example grammar, viz. {''ab'',''aba'',''abaa'',''abab'',''abac'',''abb'',''abc'',''b'',''bab'',''bac'',''bb'',''bc'',''c''}, but apparently has no ε-rules.

===UNIT: Eliminate unit rules===

A unit rule is a rule of the form 
:''A'' → ''B'', 
where ''A'', ''B'' are nonterminal symbols.
To remove it, for each rule 
:''B'' →  ''X''<sub>1</sub> ... ''X''<sub>''n''</sub>, 
where  ''X''<sub>1</sub> ... ''X''<sub>''n''</sub> is a string of nonterminals and terminals, add rule 
:''A'' →  ''X''<sub>1</sub> ... ''X''<sub>''n''</sub> 
unless this is a unit rule which has already been removed.

===Order of transformations===

{| class="wikitable collapsible collapsed" style="float:right"
|-
! colspan=6 | Mutual preservation<BR>of transformation results
|-
| colspan=6 | Transformation ''X'' {{color|#004000|always perserves}} ({{Y&}})<BR>resp. {{color|#400000|may destroy}} ({{N&}}) the result of ''Y'':
|-
| <sub>''X''</sub>'''\'''<sup>''Y''</sup>
|           '''START''' ||'''TERM'''||'''BIN'''||'''DEL'''||'''UNIT'''
|-
| '''START''' ||        || {{Y&}}   || {{Y&}}  || {{Y&}}  || {{N&}} 
|-
| '''TERM'''  || {{Y&}} ||          || {{N&}}  || {{Y&}}  || {{Y&}} 
|-
| '''BIN'''   || {{Y&}} || {{Y&}}   ||         || {{Y&}}  || {{Y&}} 
|-
| '''DEL'''   || {{Y&}} || {{Y&}}   || {{Y&}}  ||         || {{N&}} 
|-
| '''UNIT'''  || {{Y&}} || {{Y&}}   || {{Y&}}  ||({{Y&}})<sup>*</sup>||  
|-
| colspan=6 | <sup>*</sup>'''UNIT''' preserves the result of '''DEL'''<BR>&nbsp; if '''START''' had been called before.
|}

When choosing the order in which the above transformations are to be applied, it has to be considered that some transformations may destroy the result achieved by other ones. For example, '''START''' will re-introduce a unit rule if it is applied after '''UNIT'''. The table shows which orderings are admitted.

Moreover, the worst-case bloat in grammar size<ref group=note>i.e. written length, measured in symbols</ref> depends on the transformation order. Using |''G''| to denote the size of the original grammar ''G'', the size blow-up in the worst case may range from |''G''|<sup>2</sup> to 2<sup>2 |G|</sup>, depending on the transformation algorithm used.<ref name="Lange.Leis.2009"/>{{rp|7}} The blow-up in grammar size depends on the order between '''DEL''' and '''BIN'''. It may be exponential when '''DEL''' is done first, but is linear otherwise. '''UNIT''' can incur a quadratic blow-up in the size of the grammar.<ref name="Lange.Leis.2009"/>{{rp|5}} The orderings '''START''','''TERM''','''BIN''','''DEL''','''UNIT''' and '''START''','''BIN''','''DEL''','''UNIT''','''TERM''' lead to the least (i.e. quadratic) blow-up.

==Example==

[[File:Syntax tree of arithmetic expression wrt Chomsky normal form grammar.gif|thumb|[[Abstract syntax tree]] of the [[expression (mathematics)|arithmetic expression]] "''a''^2+4*''b''" wrt. the example grammar ('''top''') and its Chomsky normal form ('''bottom''')]]
The following grammar, with start symbol ''Expr'', describes a simplified version of the set of all syntactical valid arithmetic expressions in imperative programming languages like [[C (programming language)|C]] or [[Algol60]]. Both ''number'' and ''variable'' are considered terminal symbols here for simplicity, since in a [[compiler front-end]] their internal structure is usually not considered by the [[parser]]. The terminal symbol "^" denoted [[exponentiation]] in Algol60.

:{|
|-
| ''Expr'' 
| → ''Term'' 
| | |  ''Expr'' ''AddOp'' ''Term''
| | | ''AddOp'' ''Term''  
|-
| ''Term'' 
| → ''Factor''  
| | |  ''Term'' ''MulOp'' ''Factor''
|-
| ''Factor'' 
| → ''Primary''  
| | |  ''Factor'' ^ ''Primary''
|-
| ''Primary'' 
| → ''number''  
| | |  ''variable''  
| | |  ( ''Expr'' )
|-
| ''AddOp''
| → +
| | | &minus;
|-
| ''MulOp''
| → *
| | | /
|}

In step "START" of the [[#Converting a grammar to Chomsky Normal Form|above]] conversion algorithm, just a rule ''S''<sub>0</sub>→''Expr'' is added to the grammar.
After step "TERM", the grammar looks like this:

:{|
|-
| ''S''<sub>0</sub>
| → ''Expr'' 
|-
| ''Expr'' 
| → ''Term'' 
| | |  ''Expr'' ''AddOp'' ''Term''
| | | ''AddOp'' ''Term''  
|-
| ''Term'' 
| → ''Factor''  
| | |  ''Term'' ''MulOp'' ''Factor''
|-
| ''Factor'' 
| → ''Primary''  
| | |  ''Factor'' ''PowOp'' ''Primary''
|-
| ''Primary'' 
| → ''number''  
| | |  ''variable''  
| | |  ''Open'' ''Expr'' ''Close''
|-
| ''AddOp''
| → +
| | | &minus;
|-
| ''MulOp''
| → *
| | | /
|-
| ''PowOp''
| → ^
|-
| ''Open''
| → (
|-
| ''Close''
| → )
|}

After step "BIN", the following grammar is obtained:

:{|
|-
| ''S''<sub>0</sub>
| → ''Expr'' 
|-
| ''Expr'' 
| → ''Term'' 
| | |  ''Expr'' ''AddOp_Term''
| | | ''AddOp'' ''Term''  
|-
| ''Term'' 
| → ''Factor''  
| | |  ''Term'' ''MulOp_Factor''
|-
| ''Factor'' 
| → ''Primary''  
| | |  ''Factor'' ''PowOp_Primary''
|-
| ''Primary'' 
| → ''number''  
| | |  ''variable''  
| | |  ''Open'' ''Expr_Close''
|-
| ''AddOp''
| → +
| | | &minus;
|-
| ''MulOp''
| → *
| | | /
|-
| ''PowOp''
| → ^
|-
| ''Open''
| → (
|-
| ''Close''
| → )
|-
| ''AddOp_Term''
| colspan=3 | → ''AddOp'' ''Term''
|-
| ''MulOp_Factor''
| colspan=3 | → ''MulOp'' ''Factor''
|-
| ''PowOp_Primary''
| colspan=3 | → ''PowOp'' ''Primary''
|-
| ''Expr_Close''
| colspan=3 | → ''Expr'' ''Close''
|}

Since there are no ε-rules, step "DEL" doesn't change the grammar.
After step "UNIT", the following grammar is obtained, which is in Chomsky normal form:

:{|
|-
| ''S''<sub>0</sub>
| → ''number'' 
| | |  ''variable'' 
| | |  ''Open'' ''Expr_Close''
| | |  ''Factor'' ''PowOp_Primary''
| | |  ''Term'' ''MulOp_Factor''
| | |  ''Expr'' ''AddOp_Term''
| | | ''AddOp'' ''Term''  
|-
| ''Expr'' 
| → ''number'' 
| | |  ''variable'' 
| | |  ''Open'' ''Expr_Close''
| | |  ''Factor'' ''PowOp_Primary''
| | |  ''Term'' ''MulOp_Factor''
| | |  ''Expr'' ''AddOp_Term''
| | | ''AddOp'' ''Term''  
|-
| ''Term'' 
| → ''number'' 
| | |  ''variable'' 
| | |  ''Open'' ''Expr_Close''
| | |  ''Factor'' ''PowOp_Primary''
| | |  ''Term'' ''MulOp_Factor''
|-
| ''Factor'' 
| → ''number'' 
| | |  ''variable'' 
| | |  ''Open'' ''Expr_Close''
| | |  ''Factor'' ''PowOp_Primary''
|-
| ''Primary'' 
| → ''number''  
| | |  ''variable''  
| | |  ''Open'' ''Expr_Close''
|-
| ''AddOp''
| → +
| | | &minus;
|-
| ''MulOp''
| → *
| | | /
|-
| ''PowOp''
| → ^
|-
| ''Open''
| → (
|-
| ''Close''
| → )
|-
| ''AddOp_Term''
| colspan=3 | → ''AddOp'' ''Term''
|-
| ''MulOp_Factor''
| colspan=3 | → ''MulOp'' ''Factor''
|-
| ''PowOp_Primary''
| colspan=3 | → ''PowOp'' ''Primary''
|-
| ''Expr_Close''
| colspan=3 | → ''Expr'' ''Close''
|}

The ''N''<sub>''a''</sub> introduced in step "TERM" are ''PowOp'', ''Open'', and ''Close''.
The ''A''<sub>''i''</sub> introduced in step "BIN" are ''AddOp_Term'', ''MulOp_Factor'', ''PowOp_Primary'', and ''Expr_Close''.

==Alternative definition==

=== Chomsky reduced form ===
Another way<ref name="Hopcroft.Ullman.1979"/>{{rp|92}}<ref>Hopcroft et al. (2006){{page needed|date=November 2014}}</ref> to define the Chomsky normal form is:

A [[formal grammar]] is in '''Chomsky reduced form''' if all of its production rules are of the form:
: <math>A \rightarrow\, BC</math> or
: <math>A \rightarrow\, a</math>,
where <math>A</math>, <math>B</math> and <math>C</math> are nonterminal symbols, and <math>a</math> is a [[terminal symbol]].  When using this definition, <math>B</math> or <math>C</math> may be the start symbol.  Only those context-free grammars which do not generate the [[empty string]] can be transformed into Chomsky reduced form.

=== Floyd normal form ===
In a paper where he proposed a term [[Backus-Naur Form]] (BNF), [[Donald E. Knuth]] implied a BNF "syntax in which all definitions have such a form may be said to be in "Floyd Normal Form","
: <math>\langle A \rangle ::= \, \langle B \rangle \mid \langle C \rangle</math> or
: <math>\langle A \rangle ::= \, \langle B \rangle \langle C \rangle</math> or
: <math>\langle A \rangle ::=\, a</math>,
where <math>\langle A \rangle</math>, <math>\langle B \rangle</math> and <math>\langle C \rangle</math> are nonterminal symbols, and <math>a</math> is a [[terminal symbol]],
because [[Robert W. Floyd]] found any BNF syntax can be converted to the above one in 1961.<ref name="knuth1964">{{cite journal|last=Knuth|first=Donald E.|date=December 1964|title=Backus Normal Form vs. Backus Naur Form|journal=Communications of the ACM|volume=7|issue=12|pages=735–736|month=|doi=10.1145/355588.365140}}</ref> But he withdrew this term, "since doubtless many people have independently used this simple fact in their own work, and the point is only incidental to the main considerations of Floyd's note."<ref name="knuth1964" />

== Application ==
Besides its theoretical significance, CNF conversion is used in some algorithms as a preprocessing step, e.g., the [[CYK algorithm]], a [[bottom-up parsing]] for context-free grammars, and its variant probabilistic CKY.<ref>{{cite book
 | first1 = Daniel
| last1=Jurafsky
 | first2 = James H. 
| last2=Martin
 | year = 2008
 | title = Speech and Language Processing
 | edition = 2nd
 | publisher = Pearson Prentice Hall
 | isbn = 978-0-13-187321-6
 | page=465
 }}</ref>

== See also ==
*[[Backus-Naur form]]
*[[CYK algorithm]]
*[[Greibach normal form]]
*[[Kuroda normal form]]
*[[Pumping lemma for context-free languages]] &mdash; its proof relies on the Chomsky normal form

==Notes==
{{reflist|group=note}}

== References ==
<references />

==Further reading==
* Cole, Richard.  ''Converting CFGs to CNF (Chomsky Normal Form)'', October 17, 2007. [http://cs.nyu.edu/courses/fall07/V22.0453-001/cnf.pdf (pdf)] &mdash; uses the order TERM, BIN, START, DEL, UNIT.
* {{cite book
 | author = John Martin
 | year = 2003
 | title = Introduction to Languages and the Theory of Computation 
 | publisher = McGraw Hill
 | isbn = 0-07-232200-4
 }} ''(Pages 237–240 of section 6.6: simplified forms and normal forms.)''
* {{cite book
 | authorlink = Michael Sipser
 | author = Michael Sipser
 | year = 1997
 | title = Introduction to the Theory of Computation 
 | publisher = PWS Publishing
 | isbn = 0-534-94728-X
 }} ''(Pages 98–101 of section 2.1: context-free grammars. Page 156.)''
* Sipser, Michael. ''Introduction to the Theory of Computation,'' 2nd edition.

[[Category:Formal languages]]
[[Category:Noam Chomsky]]