<article title='Binary_search_tree'><paragraph><template><target>Infobox data structure</target><arg name="name">Binary search tree
</arg><arg name="type">tree
</arg><arg name="invented_by">P.F. Windley, [[Andrew Donald Booth|A.D. Booth]], A.J.T. Colin, and T.N. Hibbard
</arg><arg name="invented_year">1960
</arg><arg>
<space/></arg><arg name="space_avg">O(n)
</arg><arg name="space_worst">O(n)
</arg><arg name="search_avg">O(log n)
</arg><arg name="search_worst">O(n)
</arg><arg name="insert_avg">O(log n)
</arg><arg name="insert_worst">O(n)
</arg><arg name="delete_avg">O(log n)
</arg><arg name="delete_worst">O(n)
</arg></template></paragraph><paragraph><link><target>File:Binary search tree.svg</target><part>right</part><part>200px</part><part>thumb</part><part>A binary search tree of size 9 and depth 3, with 8 at the root. The leaves are not drawn.</part></link></paragraph><paragraph>In<space/><link><target>computer science</target></link>,<space/><bold>binary search trees</bold><space/>(<bold>BST</bold>), sometimes called<space/><bold>ordered</bold><space/>or<space/><bold>sorted binary trees</bold>, are a particular type of<space/><link><target>Collection (abstract data type)</target><part>containers</part></link>:<space/><link><target>data structure</target><trail>s</trail></link><space/>that store &quot;items&quot; (such as numbers, names etc.) in<space/><link><target>computer memory</target><part>memory</part></link>. They allow fast lookup, addition and removal of items, and can be used to implement either<space/><link><target>Set (abstract data type)</target><part>dynamic sets</part></link><space/>of items, or<space/><link><target>lookup table</target><trail>s</trail></link><space/>that allow finding an item by its<space/><italics>key</italics><space/>(e.g., finding the phone number of a person by name).</paragraph><paragraph>Binary search trees keep their keys in sorted order, so that lookup and other operations can use the principle of<space/><link><target>binary search</target></link>: when looking for a key in a tree (or a place to insert a new key), they traverse the tree from root to leaf, making comparisons to keys stored in the nodes of the tree and deciding, based on the comparison, to continue searching in the left or right subtrees. On average, this means that each comparison allows the operations to skip about half of the tree, so that each lookup, insertion or deletion takes<space/><link><target>time complexity</target><part>time proportional to</part></link><space/>the<space/><link><target>logarithm</target></link><space/>of the number of items stored in the tree. This is much better than the<space/><link><target>linear time</target></link><space/>required to find items by key in an (unsorted) array, but slower than the corresponding operations on<space/><link><target>hash table</target><trail>s</trail></link>.</paragraph><paragraph>They are a special case of the more general<space/><link><target>B-tree</target></link><space/>with order equal to two.</paragraph><heading level='2'>Definition</heading><paragraph>A binary search tree is a<space/><link><target>rooted tree</target><part>rooted</part></link><space/><link><target>binary tree</target></link>, whose internal nodes each store a key (and optionally, an associated value) and each have two distinguished sub-trees, commonly denoted<space/><italics>left</italics><space/>and<space/><italics>right</italics>. The tree additionally satisfies the binary search tree property, which states that the key in each node must be greater than all keys stored in the left sub-tree, and smaller than all keys in right sub-tree.<extension extension_name='ref'><template><target>Introduction to Algorithms</target><arg>3</arg><arg name="pages">287</arg></template></extension><space/>(The leaves (final nodes) of the tree contain no key and have no structure to distinguish them from one another. Leaves are commonly represented by a special<space/><template><target>mono</target><arg>leaf</arg></template><space/>or<space/><template><target>mono</target><arg>nil</arg></template><space/>symbol, a<space/><template><target>mono</target><arg>NULL</arg></template><space/>pointer, etc.)</paragraph><paragraph>Generally, the information represented by each node is a record rather than a single data element. However, for sequencing purposes, nodes are compared according to their keys rather than any part of their associated records.</paragraph><paragraph>The major advantage of binary search trees over other data structures is that the related<space/><link><target>sorting algorithm</target><trail>s</trail></link><space/>and<space/><link><target>search algorithm</target><trail>s</trail></link><space/>such as<space/><link><target>in-order traversal</target></link><space/>can be very efficient; they are also easy to code.</paragraph><paragraph>Binary search trees are a fundamental data structure used to construct more abstract data structures such as<space/><link><target>set (computer science)</target><part>sets</part></link>,<space/><link><target>set (computer science)#Multiset</target><part>multisets</part></link>, and<space/><link><target>associative array</target><trail>s</trail></link>. Some of their disadvantages are as follows:</paragraph><list type='bullet'><listitem>The shape of the binary search tree totally depends on the order of insertions, and it can be degenerated.</listitem><listitem>When inserting or searching for an element in binary search tree, the key of each visited node has to be compared with the key of the element to be inserted or found, i.e., it takes a long time to search an element in a binary search tree.</listitem><listitem>The keys in the binary search tree may be long and the run time may increase.</listitem><listitem>After a long intermixed sequence of random insertion and deletion, the expected height of the tree approaches square root of the number of keys,<space/><template><target>math</target><arg>√''n''</arg></template>, which grows much faster than<space/><template><target>math</target><arg>log ''n''</arg></template>.</listitem></list><heading level='2'>Operations</heading><paragraph>Binary search trees support three main operations: insertion of keys, deletion of keys, and lookup (checking whether a key is present). Each requires a<space/><italics>comparator</italics>, a<space/><link><target>subroutine</target></link><space/>that computes the total order (linear order) on any two keys. This comparator can be explicitly or implicitly defined, depending on the language in which the binary search tree was implemented. Comparators are usually<space/><italics>less-than (</italics>&amp;lt;<italics>) or greater-than (&gt;) functions:</italics><space/>for instance,<space/><italics>a</italics><space/>&amp;lt;<space/><italics>b or a &gt; b</italics>, where<space/><italics>a</italics><space/>and<space/><italics>b</italics><space/>are keys of two nodes.</paragraph><heading level='3'>Searching</heading><paragraph>Searching a binary search tree for a specific key can be a<space/><link><target>recursion (computer science)</target><part>recursive</part></link><space/>or an<space/><link><target>iteration#Computing</target><part>iterative</part></link><space/>process.</paragraph><paragraph>We begin by examining the<space/><link><target>tree (data structure)#root nodes</target><part>root node</part></link>. If the tree is<space/><italics>null</italics>, the key we are searching for does not exist in the tree. Otherwise, if the key equals that of the root, the search is successful and we return the node. If the key is less than that of the root, we search the left subtree. Similarly, if the key is greater than that of the root, we search the right subtree. This process is repeated until the key is found or the remaining subtree is<space/><italics>null</italics>. If the searched key is not found before a<space/><italics>null</italics><space/>subtree is reached, then the item must not be present in the tree. This is easily expressed as a recursive algorithm:</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def search_recursively(key, node):</paragraph><preblock><preline><space/><space/><space/>if node is None or node.key == key:</preline><preline><space/><space/><space/><space/><space/><space/><space/>return node</preline><preline><space/><space/><space/>elif key &lt; node.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/>return search_recursively(key, node.left)</preline><preline><space/><space/><space/>else: # key &gt; node.key</preline><preline><space/><space/><space/><space/><space/><space/><space/>return search_recursively(key, node.right)</preline><preline><space/><space/><space/>return None</preline></preblock></extension></paragraph><paragraph>The same algorithm can be implemented iteratively:</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def search_iteratively(key, node):<space/></paragraph><preblock><preline><space/><space/><space/>current_node = node</preline><preline><space/><space/><space/>while current_node is not None:</preline><preline><space/><space/><space/><space/><space/><space/><space/>if key == current_node.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>return current_node</preline><preline><space/><space/><space/><space/><space/><space/><space/>elif key &lt; current_node.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>current_node = current_node.left</preline><preline><space/><space/><space/><space/><space/><space/><space/>else: # key &gt; current_node.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>current_node = current_node.right</preline><preline><space/><space/><space/>return None</preline></preblock></extension></paragraph><paragraph>Because in the worst case this algorithm must search from the root of the tree to the leaf farthest from the root, the search operation takes time proportional to the tree's<space/><italics>height</italics><space/>(see<space/><link><target>Tree (data structure)#Terminology</target><part>tree terminology</part></link>). On average, binary search trees with<space/><italics>n</italics><space/>nodes have<space/><template><target>math</target><arg>[[big O notation|''O'']](log ''n'')</arg></template><space/>height.<template><target>efn</target><arg name="The notion of an average BST is made precise as follows. Let a random BST be onee built using only insertions out of a sequence of unique elements in random order (all permutations equally likely); then the [[expected value|expected]] height of the tree is {{math|''O''(log ''n'')}}. If deletions are allows as well as insertions, "little is known about the average height of a binary search tree".<ref>{{Introduction to Algorithms|3|pages">300}}</ref></arg></template><space/>However, in the worst case, binary search trees can have O(<italics>n</italics>) height, when the unbalanced tree resembles a<space/><link><target>linked list</target></link><space/>(<link><target>binary Tree#Types of binary trees</target><part>degenerate tree</part></link>).</paragraph><heading level='3'>Insertion</heading><paragraph>Insertion begins as a search would begin; if the key is not equal to that of the root, we search the left or right subtrees as before. Eventually, we will reach an external node and add the new key-value pair (here encoded as a record 'newNode') as its right or left child, depending on the node's key. In other words, we examine the root and recursively insert the new node to the left subtree if its key is less than that of the root, or the right subtree if its key is greater than or equal to the root.</paragraph><paragraph>Here's how a typical binary search tree insertion might be performed in a binary tree in<space/><link><target>C++</target></link>:</paragraph><paragraph><extension extension_name='source' lang="cpp"><paragraph>void insert(Node*&amp; root, int data) {</paragraph><preblock><preline><space/>if (!root)<space/></preline><preline><space/><space/><space/>root = new Node(data);</preline><preline><space/>else if (data &lt; root-&gt;data)</preline><preline><space/><space/><space/>insert(root-&gt;left, data);</preline><preline><space/>else // data &gt;= root-&gt;data</preline><preline><space/><space/><space/>insert(root-&gt;right, data);</preline></preblock><paragraph>}</paragraph></extension></paragraph><paragraph>The above<space/><italics>destructive</italics><space/>procedural variant modifies the tree in place. It uses only constant heap space (and the iterative version uses constant stack space as well), but the prior version of the tree is lost. Alternatively, as in the following<space/><link><target>Python (programming language)</target><part>Python</part></link><space/>example, we can reconstruct all ancestors of the inserted node; any reference to the original tree root remains valid, making the tree a<space/><link><target>persistent data structure</target></link>:</paragraph><paragraph><extension extension_name='source' lang="python"><preblock><preline>def binary_tree_insert(node, key, value):</preline><preline><space/><space/><space/><space/>if node is None:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>return TreeNode(None, key, value, None)</preline><preline><space/><space/><space/><space/>if key == node.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>return TreeNode(node.left, key, value, node.right)</preline><preline><space/><space/><space/><space/>if key &lt; node.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>return TreeNode(binary_tree_insert(node.left, key, value), node.key, node.value, node.right)</preline><preline><space/><space/><space/><space/>else:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>return TreeNode(node.left, node.key, node.value, binary_tree_insert(node.right, key, value))</preline></preblock></extension></paragraph><paragraph>The part that is rebuilt uses O(log<space/><italics>n</italics>) space in the average case and O(<italics>n</italics>) in the worst case (see<space/><link><target>big-O notation</target></link>).</paragraph><paragraph>In either version, this operation requires time proportional to the height of the tree in the worst case, which is O(log<space/><italics>n</italics>) time in the average case over all trees, but O(<italics>n</italics>) time in the worst case.</paragraph><paragraph>Another way to explain insertion is that in order to insert a new node in the tree, its key is first compared with that of the root. If its key is less than the root's, it is then compared with the key of the root's left child. If its key is greater, it is compared with the root's right child. This process continues, until the new node is compared with a leaf node, and then it is added as this node's right or left child, depending on its key: if the key is less than the leaf's key, then it is inserted as the leaf's left child, otherwise as the leaf's right child.</paragraph><paragraph>There are other ways of inserting nodes into a binary tree, but this is the only way of inserting nodes at the leaves and at the same time preserving the BST structure.</paragraph><heading level='3'>Deletion</heading><paragraph>There are three possible cases to consider:</paragraph><list type='bullet'><listitem>Deleting a node with no children: simply remove the node from the tree.</listitem><listitem>Deleting a node with one child: remove the node and replace it with its child.</listitem><listitem>Deleting a node with two children: call the node to be deleted<space/><italics>N</italics>. Do not delete<space/><italics>N</italics>. Instead, choose either its<space/><link><target>tree traversal</target><part>in-order</part></link><space/>successor node or its in-order predecessor node,<space/><italics>R</italics>. Copy the value of<space/><italics>R</italics><space/>to<space/><italics>N</italics>, then recursively call delete on<space/><italics>R</italics><space/>until reaching one of the first two cases. If you choose in-order successor of a node, as right sub tree is not NIL (Our present case is node has 2 children), then its in-order successor is node with least value in its right sub tree, which will have at a maximum of 1 sub tree, so deleting it would fall in one of first 2 cases.</listitem></list><paragraph>Broadly speaking, nodes with children are harder to delete. As with all binary trees, a node's in-order successor is its right subtree's left-most child, and a node's in-order predecessor is the left subtree's right-most child. In either case, this node will have zero or one children. Delete it according to one of the two simpler cases above.<link><target>File:binary search tree delete.svg</target><part>thumb</part><part>640px</part><part>center</part><part>Deleting a node with two children from a binary search tree. First the rightmost node in the left subtree, the inorder predecessor '''6''', is identified. Its value is copied into the node being deleted. The inorder predecessor can then be easily deleted because it has at most one child. The same method works symmetrically using the inorder successor labelled '''9'''.</part></link></paragraph><paragraph>Consistently using the in-order successor or the in-order predecessor for every instance of the two-child case can lead to an<space/><link><target>self-balancing binary search tree</target><part>unbalanced</part></link><space/>tree, so some implementations select one or the other at different times.</paragraph><paragraph>Runtime analysis: Although this operation does not always traverse the tree down to a leaf, this is always a possibility; thus in the worst case it requires time proportional to the height of the tree. It does not require more even when the node has two children, since it still follows a single path and does not visit any node twice.</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def find_min(self): # Gets minimum node in a subtree</paragraph><preblock><preline><space/><space/><space/>current_node = self</preline><preline><space/><space/><space/>while current_node.left_child:</preline><preline><space/><space/><space/><space/><space/><space/><space/>current_node = current_node.left_child</preline><preline><space/><space/><space/>return current_node</preline></preblock><paragraph>def replace_node_in_parent(self, new_value=None):</paragraph><preblock><preline><space/><space/><space/>if self.parent:</preline><preline><space/><space/><space/><space/><space/><space/><space/>if self == self.parent.left_child:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>self.parent.left_child = new_value</preline><preline><space/><space/><space/><space/><space/><space/><space/>else:</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>self.parent.right_child = new_value</preline><preline><space/><space/><space/>if new_value:</preline><preline><space/><space/><space/><space/><space/><space/><space/>new_value.parent = self.parent</preline></preblock><paragraph>def binary_tree_delete(self, key):</paragraph><preblock><preline><space/><space/><space/>if key &lt; self.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/>self.left_child.binary_tree_delete(key)</preline><preline><space/><space/><space/>elif key &gt; self.key:</preline><preline><space/><space/><space/><space/><space/><space/><space/>self.right_child.binary_tree_delete(key)</preline><preline><space/><space/><space/>else: # delete the key here</preline><preline><space/><space/><space/><space/><space/><space/><space/>if self.left_child and self.right_child: # if both children are present</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>successor = self.right_child.find_min()</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>self.key = successor.key</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>successor.binary_tree_delete(successor.key)</preline><preline><space/><space/><space/><space/><space/><space/><space/>elif self.left_child: # if the node has only a *left* child</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>self.replace_node_in_parent(self.left_child)</preline><preline><space/><space/><space/><space/><space/><space/><space/>elif self.right_child: # if the node has only a *right* child</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>self.replace_node_in_parent(self.right_child)</preline><preline><space/><space/><space/><space/><space/><space/><space/>else: # this node has no children</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>self.replace_node_in_parent(None)</preline></preblock></extension></paragraph><heading level='3'>Traversal</heading><paragraph><template><target>main</target><arg>Tree traversal</arg></template>Once the binary search tree has been created, its elements can be retrieved<space/><link><target>in-order traversal</target><part>in-order</part></link><space/>by<space/><link><target>recursion</target><part>recursively</part></link><space/>traversing the left subtree of the root node, accessing the node itself, then recursively traversing the right subtree of the node, continuing this pattern with each node in the tree as it's recursively accessed. As with all binary trees, one may conduct a<space/><link><target>pre-order traversal</target></link><space/>or a<space/><link><target>post-order traversal</target></link>, but neither are likely to be useful for binary search trees. An in-order traversal of a binary search tree will always result in a sorted list of node items (numbers, strings or other comparable items).</paragraph><paragraph>The code for in-order traversal in Python is given below. It will call<space/><bold>callback</bold><space/>for every node in the tree.</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def traverse_binary_tree(node, callback):</paragraph><preblock><preline><space/><space/><space/>if node is None:</preline><preline><space/><space/><space/><space/><space/><space/><space/>return</preline><preline><space/><space/><space/>traverse_binary_tree(node.leftChild, callback)</preline><preline><space/><space/><space/>callback(node.value)</preline><preline><space/><space/><space/>traverse_binary_tree(node.rightChild, callback)</preline></preblock></extension></paragraph><paragraph>Traversal requires<space/><link><target>big O notation#Related asymptotic notations</target><part>O(''n'')</part></link><space/>time, since it must visit every node. This algorithm is also O(<italics>n</italics>), so it is<space/><link><target>asymptotically optimal</target></link>.</paragraph><heading level='3'>Sort</heading><paragraph><template><target>main</target><arg>Tree sort</arg></template>A binary search tree can be used to implement a simple<space/><link><target>sorting algorithm</target></link>. Similar to<space/><link><target>heapsort</target></link>, we insert all the values we wish to sort into a new ordered data structurein this case a binary search treeand then traverse it in order.</paragraph><paragraph>The worst-case time of<space/><xhtml:code>build_binary_tree</xhtml:code><space/>is<space/><extension extension_name='math'>O(n^2)</extension>if you feed it a sorted list of values, it chains them into a<space/><link><target>linked list</target></link><space/>with no left subtrees. For example,<space/><xhtml:code>build_binary_tree([1, 2, 3, 4, 5])</xhtml:code><space/>yields the tree<space/><xhtml:code>(1 (2 (3 (4 (5)))))</xhtml:code>.</paragraph><paragraph>There are several schemes for overcoming this flaw with simple binary trees; the most common is the<space/><link><target>self-balancing binary search tree</target></link>. If this same procedure is done using such a tree, the overall worst-case time is O(<italics>n</italics>log<space/><italics>n</italics>), which is<space/><link><target>asymptotically optimal</target></link><space/>for a<space/><link><target>comparison sort</target></link>. In practice, the poor<space/><link><target>CPU cache</target><part>cache</part></link><space/>performance and added overhead in time and space for a tree-based sort (particularly for node<space/><link><target>dynamic memory allocation</target><part>allocation</part></link>) make it inferior to other asymptotically optimal sorts such as<space/><link><target>heapsort</target></link><space/>for static list sorting. On the other hand, it is one of the most efficient methods of<space/><italics>incremental sorting</italics>, adding items to a list over time while keeping the list sorted at all times.</paragraph><heading level='3'>Verification</heading><paragraph>Sometimes we already have a binary tree, and we need to determine whether it is a BST. This problem has a simple recursive solution.</paragraph><paragraph>The BST propertyevery node on the right subtree has to be larger than the current node and every node on the left subtree has to be smaller than (or equal to - should not be the case as only unique values should be in the tree - this also poses the question as to if such nodes should be left or right of this parent) the current nodeis the key to figuring out whether a tree is a BST or not. The<space/><link><target>greedy algorithm</target></link><space/>simply traverse the tree, at every node check whether the node contains a value larger than the value at the left child and smaller than the value on the right child does not work for all cases. Consider the following tree:</paragraph><preblock><preline><space/><space/><space/><space/><space/>20</preline><preline><space/><space/><space/><space/>/ \</preline><preline><space/><space/>10 30</preline><preline><space/><space/><space/><space/><space/><space/><space/>/ \</preline><preline><space/><space/><space/><space/><space/><space/>5 40</preline></preblock><paragraph>In the tree above, each node meets the condition that the node contains a value larger than its left child and smaller than its right child hold, and yet it is not a BST: the value 5 is on the right subtree of the node containing 20, a violation of the BST property.</paragraph><paragraph>Instead of making a decision based solely on the values of a node and its children, we also need information flowing down from the parent as well. In the case of the tree above, if we could remember about the node containing the value 20, we would see that the node with value 5 is violating the BST property contract.</paragraph><paragraph>So the condition we need to check at each node is:<space/></paragraph><list type='bullet'><listitem>if the node is the left child of its parent, then it must be smaller than (or equal to) the parent and it must pass down the value from its parent to its right subtree to make sure none of the nodes in that subtree is greater than the parent</listitem><listitem>if the node is the right child of its parent, then it must be larger than the parent and it must pass down the value from its parent to its left subtree to make sure none of the nodes in that subtree is lesser than the parent.</listitem></list><paragraph>A recursive solution in C++ can explain this further:<extension extension_name='source' lang="c"><paragraph>struct TreeNode {</paragraph><preblock><preline><space/><space/><space/>int data;</preline><preline><space/><space/><space/>TreeNode *left;</preline><preline><space/><space/><space/>TreeNode *right;</preline></preblock><paragraph>};</paragraph><paragraph>bool isBST(TreeNode *node, int minData, int maxData) {</paragraph><preblock><preline><space/><space/><space/>if(node == NULL) return true;</preline><preline><space/><space/><space/>if(node-&gt;data &lt; minData || node-&gt;data &gt; maxData) return false;</preline><preline><space/><space/><space/></preline><preline><space/><space/><space/>return isBST(node-&gt;left, minData, node-&gt;data) &amp;&amp; isBST(node-&gt;right, node-&gt;data, maxData);</preline></preblock><paragraph>}</paragraph></extension></paragraph><paragraph>The initial call to this function can be something like this:</paragraph><paragraph><extension extension_name='source' lang="c"><paragraph>if(isBST(root, INT_MIN, INT_MAX)) {</paragraph><preblock><preline><space/><space/><space/>puts(&quot;This is a BST.&quot;);</preline></preblock><paragraph>} else {</paragraph><preblock><preline><space/><space/><space/>puts(&quot;This is NOT a BST!&quot;);</preline></preblock><paragraph>}</paragraph></extension></paragraph><paragraph>Essentially we keep creating a valid range (starting from [MIN_VALUE, MAX_VALUE]) and keep shrinking it down for each node as we go down recursively.</paragraph><heading level='3'>Priority queue operations</heading><paragraph>Binary search trees can serve as<space/><link><target>priority queue</target><trail>s</trail></link>: structures that allow insertion of arbitrary key as well as lookup and deletion of the minimum (or maximum) key. Insertion works as previously explained.<space/><italics>Find-min</italics><space/>walks the tree, following left pointers as far as it can without hitting a leaf:</paragraph><preblock><preline><italics>// Precondition: T is not a leaf</italics></preline><preline><bold>function</bold><space/>find-min(T):</preline><preline><space/><space/><space/><space/><bold>while</bold><space/>hasLeft(T):</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>T left(T)</preline><preline><space/><space/><space/><space/><bold>return</bold><space/>key(T)</preline></preblock><paragraph><italics>Find-max</italics><space/>is analogous: follow right pointers as far as possible.<space/><italics>Delete-min</italics><space/>(<italics>max</italics>) can simply look up the minimum (maximum), then delete it. This way, insertion and deletion both take logarithmic time, just as they do in a<space/><link><target>binary heap</target></link>, but unlike a binary heap and most other priority queue implementations, a single tree can support all of<space/><italics>find-min</italics>,<space/><italics>find-max</italics>,<space/><italics>delete-min</italics><space/>and<space/><italics>delete-max</italics><space/>at the same time, making binary search trees suitable as<space/><link><target>double-ended priority queue</target><trail>s</trail></link>.<extension extension_name='ref' name="mehlhorn"><template><target>cite book</target><arg name="last1">Mehlhorn<space/></arg><arg name="first1">Kurt<space/></arg><arg name="author1-link">Kurt Mehlhorn</arg><arg name="first2">Peter<space/></arg><arg name="last2">Sanders</arg><arg name="author2-link">Peter Sanders (computer scientist)<space/></arg><arg name="title">Algorithms and Data Structures: The Basic Toolbox<space/></arg><arg name="publisher">Springer<space/></arg><arg name="year">2008</arg></template></extension><template><target>rp</target><arg>156</arg></template></paragraph><heading level='2'>Types</heading><paragraph>There are many types of binary search trees.<space/><link><target>AVL tree</target><trail>s</trail></link><space/>and<space/><link><target>red-black tree</target><trail>s</trail></link><space/>are both forms of<space/><link><target>self-balancing binary search tree</target><trail>s</trail></link>. A<space/><link><target>splay tree</target></link><space/>is a binary search tree that automatically moves frequently accessed elements nearer to the root. In a<space/><link><target>treap</target></link><space/>(<italics>tree<space/><link><target>heap (data structure)</target><part>heap</part></link></italics>), each node also holds a (randomly chosen) priority and the parent node has higher priority than its children.<space/><link><target>Tango tree</target><trail>s</trail></link><space/>are trees optimized for fast searches.</paragraph><paragraph>Two other titles describing binary search trees are that of a<space/><italics>complete</italics><space/>and<space/><italics>degenerate</italics><space/>tree.</paragraph><paragraph>A complete binary tree is a binary tree, which is completely filled, with the possible exception of the bottom level, which is filled from left to right. In complete binary tree, all nodes are far left as possible. It is a tree with n levels, where for each level d &lt;= n - 1, the number of existing nodes at level d is equal to 2<xhtml:sup>d</xhtml:sup>. This means all possible nodes exist at these levels. An additional requirement for a complete binary tree is that for the nth level, while every node does not have to exist, the nodes that do exist must fill from left to right.</paragraph><paragraph>A degenerate tree is a tree where for each parent node, there is only one associated child node. It is unbalanced and, in the worst case, performance degrades to that of a linked list. If your added node function does not handle re-balancing, then you can easily construct a degenerate tree by feeding it with data that is already sorted. What this means is that in a performance measurement, the tree will essentially behave like a linked list data structure.</paragraph><heading level='3'>Performance comparisons</heading><paragraph>D. A. Heger (2004)<extension extension_name='ref'><template><target>Citation</target><arg name="title">A Disquisition on The Performance Behavior of Binary Search Tree Data Structures<space/></arg><arg name="first1">Dominique A.<space/></arg><arg name="last1">Heger<space/></arg><arg name="year">2004<space/></arg><arg name="journal">European Journal for the Informatics Professional<space/></arg><arg name="volume">5<space/></arg><arg name="url">http://www.cepis.org/upgrade/files/full-2004-V.pdf<space/></arg><arg name="issue">5<space/></arg><arg name="pages">67–75</arg></template></extension><space/>presented a performance comparison of binary search trees.<space/><link><target>Treap</target></link><space/>was found to have the best average performance, while<space/><link><target>red-black tree</target></link><space/>was found to have the smallest amount of performance variations.</paragraph><heading level='3'>Optimal binary search trees</heading><paragraph><template><target>Main</target><arg>Optimal binary search tree</arg></template><link><target>File:BinaryTreeRotations.svg</target><part>thumb</part><part>300px</part><part>Tree rotations are very common internal operations in binary trees to keep perfect, or near-to-perfect, internal balance in the tree.</part></link>If we do not plan on modifying a search tree, and we know exactly how often each item will be accessed, we can construct<extension extension_name='ref'><template><target>cite web</target><arg name="last">Gonnet</arg><arg name="first">Gaston</arg><arg name="title">Optimal Binary Search Trees</arg><arg name="url">http://linneus20.ethz.ch:8080/4_7_1.html</arg><arg name="work">Scientific Computation</arg><arg name="publisher">ETH Zürich</arg><arg name="accessdate">1 December 2013</arg></template></extension><space/>an<space/><italics>optimal binary search tree</italics>, which is a search tree where the average cost of looking up an item (the<space/><italics>expected search cost</italics>) is minimized.</paragraph><paragraph>Even if we only have estimates of the search costs, such a system can considerably speed up lookups on average. For example, if you have a BST of English words used in a<space/><link><target>spell checker</target></link>, you might balance the tree based on word frequency in<space/><link><target>text corpus</target><part>text corpora</part></link>, placing words like<space/><italics>the</italics><space/>near the root and words like<space/><italics>agerasia</italics><space/>near the leaves. Such a tree might be compared with<space/><link><target>Huffman tree</target><trail>s</trail></link>, which similarly seek to place frequently used items near the root in order to produce a dense information encoding; however, Huffman trees store data elements only in leaves, and these elements need not be ordered.</paragraph><paragraph>If we do not know the sequence in which the elements in the tree will be accessed in advance, we can use<space/><link><target>splay tree</target><trail>s</trail></link><space/>which are asymptotically as good as any static search tree we can construct for any particular sequence of lookup operations.</paragraph><paragraph><italics>Alphabetic trees</italics><space/>are Huffman trees with the additional constraint on order, or, equivalently, search trees with the modification that all elements are stored in the leaves. Faster algorithms exist for<space/><italics>optimal alphabetic binary trees</italics><space/>(OABTs).</paragraph><paragraph><template><target>clear</target></template></paragraph><heading level='2'>See also</heading><paragraph><template><target>colbegin</target><arg>2</arg></template></paragraph><list type='bullet'><listitem><link><target>Search tree</target></link></listitem><listitem><link><target>Binary search algorithm</target></link></listitem><listitem><link><target>Randomized binary search tree</target></link></listitem><listitem><link><target>Tango tree</target><trail>s</trail></link></listitem><listitem><link><target>Self-balancing binary search tree</target></link></listitem><listitem><link><target>Geometry of binary search trees</target></link></listitem><listitem><link><target>Red-black tree</target></link></listitem><listitem><link><target>AVL trees</target></link></listitem><listitem><link><target>DayStoutWarren algorithm</target></link></listitem></list><paragraph><template><target>colend</target></template></paragraph><heading level='2'>Notes</heading><paragraph><template><target>notelist</target></template></paragraph><heading level='2'>References</heading><paragraph><template><target>Reflist</target></template></paragraph><heading level='2'>Further reading</heading><list type='bullet'><listitem><template><target>DADS</target><arg>Binary Search Tree</arg><arg>binarySearchTree</arg></template></listitem><listitem><template><target>cite book</target><arg name="last1">Cormen</arg><arg name="first1">Thomas H.<space/></arg><arg name="authorlink1">Thomas H. Cormen</arg><arg name="last2">Leiserson</arg><arg name="first2">Charles E.<space/></arg><arg name="authorlink2">Charles E. Leiserson</arg><arg name="last3">Rivest</arg><arg name="first3">Ronald L.<space/></arg><arg name="authorlink3">Ronald L. Rivest</arg><arg name="authorlink4">Clifford Stein</arg><arg name="first4">Clifford<space/></arg><arg name="last4">Stein</arg><arg name="title">[[Introduction to Algorithms]]</arg><arg name="edition">2nd</arg><arg name="year">2001</arg><arg name="publisher">MIT Press & McGraw-Hill</arg><arg name="isbn">0-262-03293-7</arg><arg name="pages">253–272, 356–363</arg><arg name="chapter">12: Binary search trees, 15.5: Optimal binary search trees</arg></template></listitem><listitem><template><target>cite web</target><arg name="url">http://nova.umuc.edu/~jarc/idsv/lesson1.html</arg><arg name="title">Binary Tree Traversals</arg><arg name="last">Jarc</arg><arg name="first">Duane J.</arg><arg name="date">3 December 2005</arg><arg name="work">Interactive Data Structure Visualizations</arg><arg name="publisher">[[University of Maryland]]</arg></template></listitem><listitem><template><target>cite book</target><arg name="last">Knuth</arg><arg name="first">Donald</arg><arg name="authorlink">Donald Knuth</arg><arg name="title">[[The Art of Computer Programming]]</arg><arg name="edition">3rd</arg><arg name="volume">3: "Sorting and Searching"</arg><arg name="year">1997</arg><arg name="publisher">Addison-Wesley</arg><arg name="isbn">0-201-89685-0</arg><arg name="pages">426–458</arg><arg name="chapter">6.2.2: Binary Tree Searching</arg></template></listitem><listitem><template><target>cite web</target><arg name="url">http://employees.oneonta.edu/zhangs/PowerPointPlatform/resources/samples/binarysearchtree.ppt</arg><arg name="title">Binary Search Tree</arg><arg name="last">Long</arg><arg name="first">Sean</arg><arg name="work">Data Structures and Algorithms Visualization-A PowerPoint Slides Based Approach</arg><arg name="publisher">[[SUNY Oneonta]]</arg><arg name="format">[[Microsoft PowerPoint|PPT]]</arg></template></listitem><listitem><template><target>cite web</target><arg name="url">http://cslibrary.stanford.edu/110/BinaryTrees.html</arg><arg name="title">Binary Trees</arg><arg name="last">Parlante</arg><arg name="first">Nick</arg><arg name="year">2001</arg><arg name="work">CS Education Library</arg><arg name="publisher">[[Stanford University]]</arg></template></listitem></list><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://en.literateprograms.org/Category:Binary_search_tree'>Literate implementations of binary search trees in various languages</link><space/>on LiteratePrograms</listitem><listitem><link type='external' href='http://btv.melezinek.cz'>Binary Tree Visualizer</link><space/>(JavaScript animation of various BT-based data structures)</listitem><listitem><template><target>cite web</target><arg name="url">http://people.ksp.sk/~kuko/bak/</arg><arg name="title">Binary Search Trees</arg><arg name="last">Kovac</arg><arg name="first">Kubo</arg><arg name="publisher">Korešpondenčný seminár z programovania</arg><arg name="format">[[Java applet]]</arg></template></listitem><listitem><template><target>cite web</target><arg name="url">http://jdserver.homelinux.org/wiki/Binary_Search_Tree</arg><arg name="title">Binary Search Tree</arg><arg name="last">Madru</arg><arg name="first">Justin</arg><arg name="date">18 August 2009</arg><arg name="work">JDServer</arg></template><space/>C++ implementation.</listitem><listitem><link type='external' href='http://code.activestate.com/recipes/286239/'>Binary Search Tree Example in Python</link></listitem><listitem><template><target>cite web</target><arg name="url">http://msdn.microsoft.com/en-us/library/1sf8shae%28v</arg><arg name="title">References to Pointers (C++)</arg><arg name="year">2005</arg><arg name="work">[[MSDN]]</arg><arg name="publisher">[[Microsoft]]</arg></template><space/>Gives an example binary tree implementation.</listitem></list><paragraph><template><target>CS-Trees</target></template><template><target>Data structures</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Binary search tree</target></template><link><target>Category:Articles with example C++ code</target></link><link><target>Category:Articles with example Python code</target></link><link><target>Category:Binary trees</target></link><link><target>Category:Data types</target></link><link><target>Category:Search trees</target></link></paragraph></article>