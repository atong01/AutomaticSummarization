<article title='Code_coverage'><paragraph>In<space/><link><target>computer science</target></link>,<space/><bold>code coverage</bold><space/>is a measure used to describe the degree to which the<space/><link><target>source code</target></link><space/>of a<space/><link><target>computer program</target><part>program</part></link><space/>is tested by a particular<space/><link><target>test suite</target></link>. A program with high code coverage has been more thoroughly tested and has a lower chance of containing<space/><link><target>software bug</target><trail>s</trail></link><space/>than a program with low code coverage. Many different metrics can be used to calculate code coverage; some of the most basic are the percent of program<space/><link><target>subroutine</target><trail>s</trail></link><space/>and the percent of program<space/><link><target>statement (computer science)</target><part>statements</part></link><space/>called during execution of the test suite.</paragraph><paragraph>Code coverage was among the first methods invented for systematic<space/><link><target>software testing</target></link>. The first published reference was by Miller and Maloney in<space/><italics><link><target>Communications of the ACM</target></link></italics><space/>in 1963.<extension extension_name='ref'><template><target>cite journal</target><arg name="author"><space/>Joan C. Miller, Clifford J. Maloney
<space/></arg><arg name="title"><space/>Systematic mistake analysis of digital computer programs
<space/></arg><arg name="journal"><space/>[[Communications of the ACM]]
<space/></arg><arg name="volume"><space/>6
<space/></arg><arg name="issue"><space/>2
<space/></arg><arg name="date">February 1963
<space/></arg><arg name="publisher"><space/>[[Association for Computing Machinery|ACM]]
<space/></arg><arg name="location"><space/>New York, NY, USA
<space/></arg><arg name="issn"><space/>0001-0782
<space/></arg><arg name="pages"><space/>58&ndash;63
<space/></arg><arg name="doi"><space/>10.1145/366246.366248
</arg></template></extension></paragraph><heading level='2'>Coverage criteria</heading><paragraph>To measure what percentage of code has been exercised by a<space/><link><target>test suite</target></link>, one or more<space/><italics>coverage criteria</italics><space/>are used. Coverage criteria is usually defined as a rule or requirement, which test suite needs to satisfy.<extension extension_name='ref'><template><target>cite book</target><arg name="author">Paul Ammann, Jeff Offutt<space/></arg><arg name="title">Introduction to Software Testing<space/></arg><arg name="publisher">Cambridge University Press</arg><arg name="year">2013</arg></template></extension></paragraph><heading level='3'>Basic coverage criteria</heading><paragraph>There are a number of coverage criteria, the main ones being:<extension extension_name='ref'><template><target>cite book</target><arg name="author">Glenford J. Myers<space/></arg><arg name="title">The Art of Software Testing, 2nd edition<space/></arg><arg name="publisher">Wiley<space/></arg><arg name="year">2004</arg><arg name="isbn">0-471-46912-2</arg></template></extension></paragraph><list type='bullet'><listitem><bold>Function coverage</bold><space/>- Has each function (or<space/><link><target>subroutine</target></link>) in the program been called?</listitem><listitem><bold>Statement coverage</bold><space/>- Has each<space/><link><target>statement (computer science)</target><part>statement</part></link><space/>in the program been executed?</listitem><listitem><bold>Branch coverage</bold><space/>- Has each branch (also called<space/><link><target>DD-path</target></link>) of each control structure (such as in<space/><link><target>Conditional (programming)</target><part>''if'' and ''case'' statements</part></link>) been executed? For example, given an<space/><italics>if</italics><space/>statement, have both the true and false branches been executed? Another way of saying this is, has every<space/><link><target>Graph theory</target><part>edge</part></link><space/>in the program been executed?</listitem><listitem><bold>Condition coverage</bold><space/>(or predicate coverage) - Has each Boolean sub-expression evaluated both to true and false?</listitem></list><paragraph>For example, consider the following C function:<extension extension_name='source' lang="cpp"><paragraph>int foo (int x, int y){</paragraph><preblock><preline><space/><space/><space/>int z = 0;</preline><preline><space/><space/><space/>if ((x&gt;0) &amp;&amp; (y&gt;0))</preline><preline><space/><space/><space/>{</preline><preline><space/><space/><space/><space/><space/><space/><space/>z = x;</preline><preline><space/><space/><space/>}</preline><preline><space/><space/><space/>return z;</preline></preblock><paragraph>}</paragraph></extension></paragraph><paragraph>Assume this function is a part of some bigger program and this program was run with some test suite.<space/></paragraph><list type='bullet'><listitem>If during this execution function 'foo' was called at least once, then<space/><italics>function coverage</italics><space/>for this function is satisfied.</listitem><listitem><italics>Statement coverage</italics><space/>for this function will be satisfied if it was called e.g. as<space/><xhtml:code>foo(1,1)</xhtml:code>, as in this case, every line in the function is executed including<space/><xhtml:code>z = x;</xhtml:code>.</listitem><listitem>Tests calling<space/><xhtml:code>foo(1,1)</xhtml:code><space/>and<space/><xhtml:code>foo(0,1)</xhtml:code><space/>will satisfy<space/><italics>branch coverage</italics><space/>because, in the first case, the 2<space/><xhtml:code>if</xhtml:code><space/>conditions are met and<space/><xhtml:code>z = x;</xhtml:code><space/>is executed, while in the second case, the first condition<space/><xhtml:code>(x&gt;0)</xhtml:code><space/>is not satisfied, which prevents executing<space/><xhtml:code>z = x;</xhtml:code>.<space/></listitem><listitem><italics>Condition coverage</italics><space/>can be satisfied with tests that call<space/><xhtml:code>foo(1,1)</xhtml:code>,<space/><xhtml:code>foo(1,0)</xhtml:code><space/>and<space/><xhtml:code>foo(0,0)</xhtml:code>. These are necessary because in the first two cases,<space/><xhtml:code>(x&gt;0)</xhtml:code><space/>evaluates to<space/><xhtml:code>true</xhtml:code>, while in the third, it evaluates<space/><xhtml:code>false</xhtml:code>. At the same time, the first case makes<space/><xhtml:code>(y&gt;0)</xhtml:code><space/><xhtml:code>true</xhtml:code>, while the second and third make it<space/><xhtml:code>false</xhtml:code>.</listitem></list><paragraph>Condition coverage does not necessarily imply branch coverage. For example, consider the following fragment of code:<extension extension_name='source' lang="pascal">if a and b then</extension>Condition coverage can be satisfied by two tests:</paragraph><list type='bullet'><listitem><xhtml:code>a=true</xhtml:code>,<space/><xhtml:code>b=false</xhtml:code></listitem><listitem><xhtml:code>a=false</xhtml:code>,<space/><xhtml:code>b=true</xhtml:code></listitem></list><paragraph>However, this set of tests does not satisfy branch coverage since neither case will meet the<space/><xhtml:code>if</xhtml:code><space/>condition.</paragraph><paragraph><link><target>Fault injection</target></link><space/>may be necessary to ensure that all conditions and branches of<space/><link><target>exception handling</target></link><space/>code have adequate coverage during testing.</paragraph><heading level='3'>Modified condition/decision coverage</heading><paragraph><template><target>Main</target><arg>Modified Condition/Decision Coverage</arg></template>A combination of function coverage and branch coverage is sometimes also called<bold>decision coverage</bold>. This criterion requires that every point of entry and exit in the program have been invoked at least once, and every decision in the program have taken on all possible outcomes at least once. In this context the decision is a boolean expression composed of conditions and zero or more boolean operators. This definition is not the same as branch coverage,<extension extension_name='ref' name="Position Paper CAST10">Position Paper CAST-10 (June 2002).<space/><italics><link type='external' href='http://www.faa.gov/aircraft/air_cert/design_approvals/air_software/cast/cast_papers/media/cast-10.pdf'>What is a Decision in Application of Modified Condition/Decision Coverage (MC/DC) and Decision Coverage (DC)?</link></italics></extension><space/>however, some do use the term<space/><italics>decision coverage</italics><space/>as a synonym for<space/><italics>branch coverage</italics>.<extension extension_name='ref' name="mathworks">MathWorks. ''<link type='external' href='http://www.mathworks.com/help/slvnv/ug/types-of-model-coverage.html'>Types of Model Coverage.''</link></extension></paragraph><paragraph><bold>Condition/decision coverage</bold><space/>requires that both decision and condition coverage been satisfied. However, for<space/><link><target>safety-critical</target></link><space/>applications (e.g., for avionics software) it is often required that<space/><bold>modified condition/decision coverage (MC/DC)</bold><space/>be satisfied. This criterion extends condition/decision criteria with requirements that each condition should affect the decision outcome independently. For example, consider the following code:<extension extension_name='source' lang="pascal">if (a or b) and c then</extension>The condition/decision criteria will be satisfied by the following set of tests:</paragraph><list type='bullet'><listitem>a=true, b=true, c=true</listitem><listitem>a=false, b=false, c=false</listitem></list><paragraph>However, the above tests set will not satisfy modified condition/decision coverage, since in the first test, the value of 'b' and in the second test the value of 'c' would not influence the output. So, the following test set is needed to satisfy MC/DC:</paragraph><list type='bullet'><listitem>a=<bold>false</bold>, b=<bold>false</bold>, c=true</listitem><listitem>a=<bold>true</bold>, b=false, c=<bold>true</bold></listitem><listitem>a=false, b=<bold>true</bold>, c=<bold>true</bold></listitem><listitem>a=false, b=true, c=<bold>false</bold></listitem></list><heading level='3'>Multiple condition coverage</heading><paragraph>This criterion requires that all combinations of conditions inside each decision are tested. For example, the code fragment from the previous section will require eight tests:</paragraph><list type='bullet'><listitem>a=false, b=false, c=false</listitem><listitem>a=false, b=false, c=true</listitem><listitem>a=false, b=true, c=false</listitem><listitem>a=false, b=true, c=true</listitem><listitem>a=true, b=false, c=false</listitem><listitem>a=true, b=false, c=true</listitem><listitem>a=true, b=true, c=false</listitem><listitem>a=true, b=true, c=true</listitem></list><heading level='3'>Parameter value coverage</heading><paragraph><bold>Parameter value coverage</bold><space/>(PVC) requires that in a method taking parameters, all the common values for such parameters been considered. The idea is that all common possible values for a parameter are tested.<extension extension_name='ref'><link type='external' href='http://www.rhyous.com/2012/05/08/unit-testing-with-parameter-value-coverage-pvc/'>Unit Testing with Parameter Value Coverage (PVC)</link></extension><space/>For example, common values for a string are: 1) null, 2) empty, 3) whitespace (space, tabs, newline), 4) valid string, 5) invalid string, 6) single-byte string, 7) double-byte string. It may also be appropriate to use very long strings. Failure to test each possible parameter value may leave a bug. Testing only one of these could result in 100% code coverage as each line is covered, but as only one of seven options are tested, there is only 14.2% PVC.</paragraph><heading level='3'>Other coverage criteria</heading><paragraph>There are further coverage criteria, which are used less often:</paragraph><list type='bullet'><listitem><bold><link><target>Linear Code Sequence and Jump</target></link><space/>(LCSAJ) coverage</bold><space/>a.k.a.<space/><bold>JJ-Path coverage</bold><space/>- has every LCSAJ/JJ-path been executed?<extension extension_name='ref' name="On the relationship between two control-flow coverage criteria: all JJ-paths and MCDC">M. R. Woodward, M. A. Hennell, &quot;On the relationship between two control-flow coverage criteria: all JJ-paths and MCDC&quot;, Information and Software Technology 48 (2006) pp. 433-440</extension></listitem><listitem><bold>Path coverage</bold><space/>- Has every possible route through a given part of the code been executed?</listitem><listitem><bold>Entry/exit coverage</bold><space/>- Has every possible call and return of the function been executed?</listitem><listitem><bold>Loop coverage</bold><space/>- Has every possible loop been executed zero times, once, and more than once?</listitem><listitem><bold>State coverage</bold><space/>- Has each state in a<space/><link><target>finite-state machine</target></link><space/>been reached and explored?</listitem></list><paragraph><link><target>Safety-critical</target></link><space/>applications are often required to demonstrate that testing achieves 100% of some form of code coverage.</paragraph><paragraph>Some of the coverage criteria above are connected. For instance, path coverage implies decision, statement and entry/exit coverage. Decision coverage implies statement coverage, because every statement is part of a branch.</paragraph><paragraph>Full path coverage, of the type described above, is usually impractical or impossible. Any module with a succession of<space/><extension extension_name='math'>n</extension><space/>decisions in it can have up to<space/><extension extension_name='math'>2^n</extension><space/>paths within it; loop constructs can result in an infinite number of paths. Many paths may also be infeasible, in that there is no input to the program under test that can cause that particular path to be executed. However, a general-purpose algorithm for identifying infeasible paths has been proven to be impossible (such an algorithm could be used to solve the<space/><link><target>halting problem</target></link>).<extension extension_name='ref'>Dorf, Richard C.:<space/><italics>Computers, Software Engineering, and Digital Devices</italics>, Chapter 12, pg. 15. CRC Press, 2006. ISBN 0-8493-7340-9, ISBN 978-0-8493-7340-4; via<space/><link type='external' href='http://books.google.com/books?id=jykvlTCoksMC&amp;amp;pg=PT386&amp;amp;lpg=PT386&amp;amp;dq=%22infeasible+path%22+%22halting+problem%22&amp;amp;source=web&amp;amp;ots=WUWz3qMPRv&amp;amp;sig=dSAjrLHBSZJcKWZfGa_IxYlfSNA&amp;amp;hl=en&amp;amp;sa=X&amp;amp;oi=book_result&amp;amp;resnum=1&amp;amp;ct=result'>Google Book Search</link></extension><space/><link><target>Basis path testing</target></link><space/>is for instance a method of achieving complete branch coverage without achieving complete path coverage.<extension extension_name='ref' name="SrikantShankar2002"><template><target>cite book</target><arg name="author1">Y.N. Srikant</arg><arg name="author2">Priti Shankar</arg><arg name="title">The Compiler Design Handbook: Optimizations and Machine Code Generation</arg><arg name="year">2002</arg><arg name="publisher">CRC Press</arg><arg name="isbn">978-1-4200-4057-9</arg><arg name="page">249</arg></template></extension></paragraph><paragraph>Methods for practical path coverage testing instead attempt to identify classes of code paths that differ only in the number of loop executions, and to achieve &quot;basis path&quot; coverage the tester must cover all the path classes.<template><target>citation needed</target><arg name="date">July 2014</arg></template><template><target>clarify</target><arg name="date">July 2014</arg></template></paragraph><paragraph><template><target>refimprove</target><arg>section</arg><arg name="date">February 2015</arg></template></paragraph><heading level='2'>In practice</heading><paragraph>The target software is built with special options or libraries and/or run under a special environment such that every function that is exercised (executed) in the program(s) is mapped back to the function points in the source code. This process allows developers and quality assurance personnel to look for parts of a system that are rarely or never accessed under normal conditions (error handling and the like) and helps reassure test engineers that the most important conditions (function points) have been tested. The resulting output is then analyzed to see what areas of code have not been exercised and the tests are updated to include these areas as necessary. Combined with other code coverage methods, the aim is to develop a rigorous, yet manageable, set of regression tests.</paragraph><paragraph>In implementing code coverage policies within a software development environment, one must consider the following:</paragraph><list type='bullet'><listitem>What are coverage requirements for the end product certification and if so what level of code coverage is required? The typical level of rigor progression is as follows: Statement, Branch/Decision,<space/><link><target>Modified Condition/Decision Coverage</target></link>(MC/DC), LCSAJ (<link><target>Linear Code Sequence and Jump</target></link>)</listitem><listitem>Will code coverage be measured against tests that verify requirements levied on the system under test (<link><target>DO-178B</target></link>)?</listitem><listitem>Is the object code generated directly traceable to source code statements? Certain certifications, (i.e. DO-178B Level A) require coverage at the assembly level if this is not the case: &quot;Then, additional verification should be performed on the object code to establish the correctness of such generated code sequences&quot; (<link><target>DO-178B</target></link>) para-6.4.4.2.<extension extension_name='ref' name="DO-178B"></extension></listitem></list><paragraph>Test engineers can look at code coverage test results to help them devise test cases and input or configuration sets that will increase the code coverage over vital functions. Two common forms of code coverage used by testers are statement (or line) coverage and branch (or edge) coverage. Line coverage reports on the execution footprint of testing in terms of which lines of code were executed to complete the test. Edge coverage reports which branches or code decision points were executed to complete the test. They both report a coverage metric, measured as a percentage. The meaning of this depends on what form(s) of code coverage have been used, as 67% branch coverage is more comprehensive than 67% statement coverage.</paragraph><paragraph>Generally, code coverage tools incur computation and logging in addition to the actual program thereby slowing down the application, so typically this analysis is not done in production. As one might expect, there are classes of software that cannot be feasibly subjected to these coverage tests, though a degree of coverage mapping can be approximated through analysis rather than direct testing.</paragraph><paragraph>There are also some sorts of defects which are affected by such tools. In particular, some<space/><link><target>race condition</target><trail>s</trail></link><space/>or similar<space/><link><target>Real-time computing</target><part>real time</part></link><space/>sensitive operations can be masked when run under code coverage environments; and conversely, and reliably, some of these defects may become easier to find as a result of the additional overhead of the testing code.</paragraph><heading level='2'>Usage in industry</heading><paragraph>Code coverage is one consideration in the safety certification of avionics equipment. The guidelines by which avionics gear is certified by the<space/><link><target>Federal Aviation Administration</target></link><space/>(FAA) is documented in<space/><link><target>DO-178B</target></link><extension extension_name='ref' name="DO-178B">RTCA/<link><target>DO-178B</target></link>,<space/><italics>Software Considerations in Airborne Systems and Equipment Certification, Radio Technical Commission for Aeronautics,</italics><space/>December 1, 1992</extension><space/>and the recently released<space/><link><target>DO-178C</target></link>.<extension extension_name='ref' name="DO-178C">RTCA/<link><target>DO-178C</target></link>,<space/><italics>Software Considerations in Airborne Systems and Equipment Certification, Radio Technical Commission for Aeronautics,</italics><space/>January, 2012.</extension></paragraph><paragraph>Code coverage is also a requirement in part 6 of the automotive safety standard<space/><link><target>ISO 26262</target></link><space/><italics>Road Vehicles - Functional Safety</italics>.<extension extension_name='ref' name="ISO26262part6"><template><target>cite book</target><arg name="title">ISO 26262-6:2011(en) Road vehicles -- Functional safety -- Part 6: Product development at the software level<space/></arg><arg name="publisher">International Standardization Organization<space/></arg><arg name="url">http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber</arg></template></extension></paragraph><heading level='2'>See also</heading><paragraph><template><target>portal</target><arg>Software Testing</arg></template></paragraph><list type='bullet'><listitem><link><target>Cyclomatic complexity</target></link></listitem><listitem><link><target>Intelligent verification</target></link></listitem><listitem><link><target>Linear Code Sequence and Jump</target></link></listitem><listitem><link><target>Modified Condition/Decision Coverage</target></link></listitem><listitem><link><target>Mutation testing</target></link></listitem><listitem><link><target>Regression testing</target></link></listitem><listitem><link><target>Software metric</target></link></listitem><listitem><link><target>Static code analysis</target></link></listitem><listitem><link><target>White box testing</target></link></listitem><listitem><link><target>Java Code Coverage Tools</target></link></listitem></list><heading level='2'>References</heading><paragraph><template><target>reflist</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Code Coverage</target></template><link><target>Category:Software testing</target></link><link><target>Category:Software metrics</target></link><link><target>Category:Software testing tools</target></link></paragraph></article>