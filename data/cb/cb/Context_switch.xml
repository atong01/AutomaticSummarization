<article title='Context_switch'><paragraph><template><target>more footnotes</target><arg name="date">November 2009</arg></template></paragraph><paragraph>In computing, a<space/><bold>context switch</bold><space/>is the process of storing and restoring the<space/><link><target>State (computer science)</target><part>state</part></link><space/>(more specifically, the execution<space/><link><target>Context (computing)</target><part>context</part></link>) of a<space/><link><target>Process (computing)</target><part>process</part></link><space/>or<space/><link><target>Thread (computing)</target><part>thread</part></link><space/>so that execution can be resumed from the same point at a later time. This enables multiple processes to share a single<space/><link><target>Central processing unit</target><part>CPU</part></link><space/>and is an essential feature of a<space/><link><target>computer multitasking</target><part>multitasking</part></link><space/><link><target>operating system</target></link>.</paragraph><paragraph>The precise meaning of &quot;context switch&quot; varies significantly in usage, most often to mean &quot;thread switch or process switch&quot; or &quot;process switch only&quot;,<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://www.eecs.harvard.edu/~margo/cs161/notes/context-switching.pdf
<space/></arg><arg name="title"><space/>Switching and Crossing
<space/></arg><arg name="date"><space/>February 11, 2014<space/></arg><arg name="accessdate"><space/>November 6, 2014
<space/></arg><arg name="author"><space/>Margo Seltzer<space/></arg><arg name="website"><space/>eecs.harvard.edu
<space/></arg><arg name="format"><space/>PDF
</arg></template></extension><space/>either of which may be referred to as a &quot;<link><target>Task (computing)</target><part>task</part></link><space/>switch&quot;. More finely, one can distinguish<space/><italics><link><target>thread (computing)</target><part>thread</part></link><space/>switch</italics><space/>(switching between two threads within a given process),<space/><italics>process switch</italics><space/>(switching between two processes),<space/><italics>mode switch</italics><space/>(<italics>domain crossing</italics>: switching between user mode and kernel mode within a given thread),<space/><italics><link><target>Processor register</target><part>register</part></link><space/>switch</italics>, a<space/><italics><link><target>stack frame</target></link><space/>switch</italics>, and<space/><italics>address space switch</italics><space/>(<italics>memory map switch</italics>: changing virtual memory to physical memory map). The computational cost of context switches varies significantly depending on what precisely it entails, from little more than a<space/><link><target>subroutine</target></link><space/>call for light-weight user processes, to very expensive, though typically much less than that of saving or restoring a<space/><link><target>process image</target></link>.</paragraph><heading level='2'>Cost</heading><paragraph>Context switches are usually computationally intensive, and much of the design of operating systems is to optimize the use of context switches. Switching from one process to another requires a certain amount of time for doing the administration<template><target>snd</target></template><space/>saving and loading registers and memory maps, updating various tables and lists etc. What is actually involved in a context switch varies between these senses and between processors and operating systems. For example, in the<space/><link><target>Linux kernel</target></link><space/>context switching involves switching registers, stack pointer, and<space/><link><target>program counter</target></link>, but is independent of address space switching, though in a process switch an address space switch also happens.<extension extension_name='ref'><italics>IA-64 Linux Kernel: Design and Implementation</italics>,<space/><link type='external' href='http://www.informit.com/articles/article.aspx?p=29961&amp;amp;seqNum=7'>4.7 Switching Address Spaces</link></extension><extension extension_name='ref'><italics>Operating Systems</italics>, 5.6 The Context Switch,<space/><link type='external' href='https://books.google.com/books?id=orZ0CLxEMXEC&amp;amp;pg=PA118'>p. 118</link></extension><space/>Further still, analogous context switching happens between<space/><link><target>user thread</target><trail>s</trail></link>, notably<space/><link><target>green thread</target><trail>s</trail></link>, and is often very light-weight, saving and restoring minimal context. In extreme cases, such as switching between goroutines in<space/><link><target>Go (programming language)</target><part>Go</part></link>, a context switch is equivalent to a<space/><link><target>coroutine</target></link><space/>yield, which is only marginally more expensive than a<space/><link><target>subroutine</target></link><space/>call.</paragraph><heading level='2'>When to switch?</heading><paragraph>There are three potential triggers for a context switch:</paragraph><heading level='3'>Multitasking</heading><paragraph>Most commonly, within some<space/><link><target>Scheduling (computing)</target><part>scheduling</part></link><space/>scheme, one process must be switched out of the CPU so another process can run.This context switch can be triggered by the process making itself unrunnable, such as by waiting for an<space/><link><target>Input/output</target><part>I/O</part></link><space/>or<space/><link><target>Synchronization (computer science)</target><part>synchronization</part></link><space/>operation to complete. On a<space/><link><target>pre-emptive multitasking</target></link><space/>system, the scheduler may also switch out processes which are still runnable. To prevent other processes from being starved of CPU time, preemptive schedulers often configure a timer interrupt to fire when a process exceeds its<space/><link><target>time slice</target></link>. This interrupt ensures that the scheduler will gain control to perform a context switch.</paragraph><heading level='3'>Interrupt handling</heading><paragraph>Modern architectures are<space/><link><target>interrupt</target></link><space/>driven. This means that if the CPU requests data from a disk, for example, it does not need to<space/><link><target>busy-wait</target></link><space/>until the read is over; it can issue the request and continue with some other execution. When the read is over, the CPU can be<space/><italics>interrupted</italics><space/>and presented with the read. For interrupts, a program called an<space/><italics><link><target>interrupt handler</target></link></italics><space/>is installed, and it is the interrupt handler that handles the interrupt from the disk.</paragraph><paragraph>When an interrupt occurs, the hardware automatically switches a part of the context (at least enough to allow the handler to return to the interrupted code). The handler may save additional context, depending on details of the particular hardware and software designs. Often only a minimal part of the context is changed in order to minimize the amount of time spent handling the interrupt.The<space/><link><target>kernel (computing)</target><part>kernel</part></link><space/>does not spawn or schedule a special process to handle interrupts, but instead the handler executes in the (often partial) context established at the beginning of interrupt handling. Once interrupt servicing is complete, the context in effect before the interrupt occurred is restored so that the interrupted process can resume execution in its proper state.</paragraph><heading level='3'>User and kernel mode switching</heading><paragraph>When a transition between<space/><link><target>user mode</target></link><space/>and<space/><link><target>kernel mode</target></link><space/>is required in an operating system, a context switch is not necessary; a mode transition is<space/><italics>not</italics><space/>by itself a context switch. However, depending on the operating system, a context switch may also take place at this time.</paragraph><heading level='2'>Steps</heading><paragraph>In a switch, the state of the first process (assuming that the first process is the process in execution and is to be switched) must be saved somehow, so that, when the scheduler gets back to the execution of the first process, it can restore this state and continue.</paragraph><paragraph>The state of the process includes all the registers that the process may be using, especially the<space/><link><target>program counter</target></link>, plus any other operating system specific data that may be necessary. This data is usually stored in a data structure called a<space/><link><target>process control block</target></link><space/>(PCB), or switchframe.<space/></paragraph><paragraph>In order to switch processes, the PCB for the first process must be created and saved. The PCBs are sometimes stored upon a per-process<space/><link><target>Stack (data structure)</target><part>stack</part></link><space/>in kernel memory (as opposed to the user-mode<space/><link><target>call stack</target></link>), or there may be some specific operating system defined data structure for this information.</paragraph><paragraph>Since the operating system has effectively suspended the execution of the first process, it can now load the PCB and context of the second process. In doing so, the program counter from the PCB is loaded, and thus execution can continue in the new process. New processes are chosen from a queue or queues (often referred as ready queue). Process and thread priority can influence which process continues execution, with processes of the highest priority checked first for ready threads to execute.</paragraph><heading level='2'><template><target>Anchor</target><arg>LATENCY</arg></template>Performance</heading><paragraph>Context switching itself has a cost in performance, due to running the<space/><link><target>scheduling (computing)</target><part>task scheduler</part></link>,<space/><link><target>Translation lookaside buffer</target><part>TLB</part></link><space/>flushes, and indirectly due to sharing the<space/><link><target>CPU cache</target></link><space/>between multiple tasks.<extension extension_name='ref'><template><target>cite paper</target><arg name="author">Chuanpeng Li, Chen Ding, Kai Shen<space/></arg><arg name="title">Quantifying The Cost of Context Switch<space/></arg><arg name="url">http://www.cs.rochester.edu/u/cli/research/switch.pdf<space/></arg></template></extension><space/>Switching between threads of a single process can be faster than between two separate processes, because threads share the same<space/><link><target>virtual memory</target></link><space/>maps, so a TLB flush is not necessary.<extension extension_name='ref'><template><target>cite news</target><arg name="author">Ulrich Drepper<space/></arg><arg name="date">{{date|2014-10-09}}<space/></arg><arg name="title">Memory part 3: Virtual Memory<space/></arg><arg name="publisher">[[LWN.net]]<space/></arg><arg name="url">https://lwn.net/Articles/253361/<space/></arg></template></extension></paragraph><heading level='3'>Hardware vs. software</heading><paragraph>Context switching can be performed primarily by software or hardware. Some processors, like the<space/><link><target>Intel 80386</target></link><space/>and its successors,<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.linfo.org/context_switch.html<space/></arg><arg name="title">Context Switch definition<space/></arg><arg name="publisher">Linfo.org<space/></arg><arg name="date"><space/></arg><arg name="accessdate">2013-09-08</arg></template></extension><space/>have hardware support for context switches, by making use of a special data segment designated the<space/><link><target>task state segment</target></link><space/>or TSS. A task switch can be explicitly triggered with a CALL or JMP instruction targeted at a TSS descriptor in the<space/><link><target>global descriptor table</target></link>. It can occur implicitly when an interrupt or exception is triggered if there's a<space/><link><target>task gate</target></link><space/>in the<space/><link><target>interrupt descriptor table</target></link>. When a task switch occurs the<space/><link><target>Central processing unit</target><part>CPU</part></link><space/>can automatically load the new state from the TSS.</paragraph><paragraph>As with other tasks performed in hardware, one would expect this to be rather fast; however, mainstream operating systems, including<space/><link><target>Microsoft Windows</target><part>Windows</part></link><space/>and<space/><link><target>Linux</target></link>,<extension extension_name='ref'><template><target>cite book</target><arg name="url">http://books.google.com/?id</arg><arg name="title">Understanding the Linux Kernel, Third Edition</arg><arg name="last1">Bovet</arg><arg name="first1">Daniel Pierre</arg><arg name="last2">Cesati</arg><arg name="first2">Marco</arg><arg name="publisher">[[O'Reilly Media]]</arg><arg name="year">2006</arg><arg name="page">104</arg><arg name="accessdate">2009-11-23</arg><arg name="isbn">978-0-596-00565-8</arg></template></extension><space/>do not use this feature. This is mainly due to two reasons:</paragraph><list type='bullet'><listitem>Hardware context switching does not save all the registers (only general purpose registers, not<space/><link><target>floating point</target></link><space/>registers although the TS bit is automatically turned on in the CR0<space/><link><target>control register</target></link>, resulting in a fault when executing floating point instructions and giving the OS the opportunity to save and restore the floating point state as needed).</listitem><listitem>Associated performance issues, e.g., software context switching can be selective and store only those registers that need storing, whereas hardware context switching stores nearly all registers whether they are required or not.</listitem></list><heading level='2'>References</heading><paragraph><template><target>reflist</target></template></paragraph><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://wiki.osdev.org/Context_Switching'>Context Switching</link><space/>- at OSDev.org</listitem><listitem><link type='external' href='http://www.linfo.org/context_switch.html'>Context Switch Definition</link><space/>- by The Linux Information Project (LINFO)</listitem><listitem><link type='external' href='http://msdn.microsoft.com/en-us/library/ms682105(VS.85).aspx'>Context Switches</link><space/>- from the Microsoft Developer Network (MSDN)</listitem><listitem><link type='external' href='http://www.freebsd.org/doc/en/books/arch-handbook/smp-design.html'>General Architecture and Design -Interrupt Handling</link><space/>at FreeBSD.org</listitem></list><paragraph><template><target>Operating System</target></template><template><target>DEFAULTSORT:Context Switch</target></template><link><target>Category:Process (computing)</target></link></paragraph></article>