<article title='Cyclone_%28programming_language%29'><paragraph><template><target>Infobox programming language</target><arg name="name"><space/>Cyclone
<space/></arg><arg name="logo">
<space/></arg><arg name="caption">
<space/></arg><arg name="file ext">
<space/></arg><arg name="paradigm">
<space/></arg><arg name="released"><space/>{{start date|2006}}
<space/></arg><arg name="designer"><space/>AT&T Labs
<space/></arg><arg name="developer">
<space/></arg><arg name="latest release version"><space/>1.0
<space/></arg><arg name="latest release date"><space/>{{start date and age|2006|05|08}}
<space/></arg><arg name="latest preview version">
<space/></arg><arg name="latest preview date"><space/>
<space/></arg><arg name="typing">
<space/></arg><arg name="implementations">
<space/></arg><arg name="dialects">
<space/></arg><arg name="influenced by"><space/>[[C (programming language)|C]]
<space/></arg><arg name="influenced">
<space/></arg><arg name="programming language">
<space/></arg><arg name="operating system">
<space/></arg><arg name="license">
<space/></arg><arg name="website"><space/>{{URL|http://cyclone.thelanguage.org}}
<space/></arg><arg name="wikibooks">
</arg></template>The<space/><bold>Cyclone</bold><space/><link><target>programming language</target></link><space/>is intended to be a safe dialect of the<space/><link><target>C (programming language)</target><part>C language</part></link>. Cyclone is designed to avoid<space/><link><target>buffer overflow</target><trail>s</trail></link><space/>and other vulnerabilities that are endemic in C programs, without losing the power and convenience of C as a tool for<space/><link><target>system programming</target></link>.</paragraph><paragraph>Cyclone development was started as a joint project of AT&amp;T Labs Research and<space/><link><target>Greg Morrisett</target></link>'s group at Cornell in 2001. Version 1.0 was released on May 8, 2006.</paragraph><heading level='2'>Language features</heading><paragraph>Cyclone attempts to avoid some of the common pitfalls of<space/><link><target>C (programming language)</target><part>C</part></link>, while still maintaining its look and performance. To this end, Cyclone places the following limits on programs:</paragraph><list type='bullet'><listitem><xhtml:code><link><target>Null pointer</target><part>NULL</part></link></xhtml:code><space/>checks are inserted to prevent<space/><link><target>segmentation fault</target><trail>s</trail></link></listitem><listitem><link><target>Pointer arithmetic</target></link><space/>is limited</listitem><listitem>Pointers must be initialized before use (this is enforced by<space/><link><target>definite assignment analysis</target></link>)</listitem><listitem><link><target>Dangling pointer</target><trail>s</trail></link><space/>are prevented through region analysis and limits on<space/><link><target>Malloc</target><part><xhtml:code>free()</xhtml:code></part></link></listitem><listitem>Only &quot;safe&quot; casts and unions are allowed</listitem><listitem><link><target>Control flow</target><part><xhtml:code>goto</xhtml:code></part></link><space/>into scopes is disallowed</listitem><listitem><link><target>Control flow</target><part><xhtml:code>switch</xhtml:code></part></link><space/>labels in different scopes are disallowed</listitem><listitem>Pointer-returning functions must execute<space/><xhtml:code>return</xhtml:code></listitem><listitem><link><target>Setjmp/longjmp</target><part><xhtml:code>setjmp</xhtml:code></part></link><space/>and<space/><link><target>Setjmp/longjmp</target><part><xhtml:code>longjmp</xhtml:code></part></link><space/>are not supported</listitem></list><paragraph>To maintain the tool set that C programmers are used to, Cyclone provides the following extensions:</paragraph><list type='bullet'><listitem><bold>Never-<xhtml:code>NULL</xhtml:code><space/>pointers</bold><space/>do not require<space/><xhtml:code>NULL</xhtml:code><space/>checks</listitem><listitem><bold>&quot;Fat&quot; pointers</bold><space/>support pointer arithmetic with run-time<space/><link><target>bounds checking</target></link></listitem><listitem><bold>Growable regions</bold><space/>support a form of safe manual memory management</listitem><listitem><bold><link><target>Garbage collection (computer science)</target><part>Garbage collection</part></link></bold><space/>for heap-allocated values</listitem><listitem><bold><link><target>Tagged union</target><trail>s</trail></link></bold><space/>support type-varying arguments</listitem><listitem><bold>Injections</bold><space/>help automate the use of tagged unions for programmers</listitem><listitem><bold><link><target>Polymorphism (computer science)</target><part>Polymorphism</part></link></bold><space/>replaces some uses of<space/><link><target>void pointer</target><part><xhtml:code>void *</xhtml:code></part></link></listitem><listitem><bold>varargs</bold><space/>are implemented as fat pointers</listitem><listitem><bold><link><target>Exception handling</target><part>Exceptions</part></link></bold><space/>replace some uses of<space/><xhtml:code>setjmp</xhtml:code><space/>and<space/><xhtml:code>longjmp</xhtml:code></listitem></list><paragraph>For a better high-level introduction to Cyclone, the reasoning behind Cyclone and the source of these lists, see<space/><link type='external' href='http://www.cs.umd.edu/projects/cyclone/papers/cyclone-safety.pdf'>this paper</link>.</paragraph><paragraph>Cyclone looks, in general, much like<space/><link><target>C (programming language)</target><part>C</part></link>, but it should be viewed as a C-like language.</paragraph><heading level='3'>Pointer/reference types</heading><paragraph>Cyclone implements three kinds of<space/><link><target>reference (computer science)</target><part>reference</part></link><space/>(following C terminology these are called pointers):</paragraph><list type='bullet'><listitem><xhtml:code><list type='bullet'><listitem></listitem></list></xhtml:code><space/>(the normal type)</listitem><listitem><xhtml:code>@</xhtml:code><space/>(the never-<xhtml:code>NULL</xhtml:code><space/>pointer), and</listitem><listitem><xhtml:code>?</xhtml:code><space/>(the only type with<space/><link><target>pointer arithmetic</target></link><space/>allowed, &quot;fat&quot; pointers).</listitem></list><paragraph>The purpose of introducing these new pointer types is to avoid common problems when using pointers. Take for instance a function, called<space/><xhtml:code>foo</xhtml:code><space/>that takes a pointer to an int:<extension extension_name='source' lang="C"><preblock><preline>int foo(int *);</preline></preblock></extension>Although the person who wrote the function<space/><xhtml:code>foo</xhtml:code><space/>could have inserted<space/><xhtml:code>NULL</xhtml:code><space/>checks, let us assume that for performance reasons they did not. Calling<space/><xhtml:code>foo(NULL);</xhtml:code><space/>will result in<space/><link><target>undefined behavior</target></link><space/>(typically, although not necessarily, a<space/><link><target>SIGSEGV</target></link><space/><link><target>Unix signal</target><part>signal</part></link><space/>being sent to the application). To avoid such problems, Cyclone introduces the<space/><xhtml:code>@</xhtml:code><space/>pointer type, which can never be<space/><xhtml:code>NULL</xhtml:code>. Thus, the &quot;safe&quot; version of<space/><xhtml:code>foo</xhtml:code><space/>would be:<extension extension_name='source' lang="C"><preblock><preline>int foo(int @);</preline></preblock></extension>This tells the Cyclone compiler that the argument to<space/><xhtml:code>foo</xhtml:code><space/>should never be<space/><xhtml:code>NULL</xhtml:code>, avoiding the aforementioned undefined behavior. The simple change of<space/><xhtml:code><list type='bullet'><listitem></listitem></list></xhtml:code><space/>to<space/><xhtml:code>@</xhtml:code><space/>saves the programmer from having to write<space/><xhtml:code>NULL</xhtml:code><space/>checks and the operating system from having to trap<space/><xhtml:code>NULL</xhtml:code><space/>pointer dereferences. This extra limit, however, can be a rather large stumbling block for most C programmers, who are used to being able to manipulate their pointers directly with arithmetic. Although this is desirable, it can lead to<space/><link><target>buffer overflow</target><trail>s</trail></link><space/>and other &quot;off-by-one&quot;-style mistakes. To avoid this, the<space/><xhtml:code>?</xhtml:code><space/>pointer type is delimited by a known bound, the size of the array. Although this adds overhead due to the extra information stored about the pointer, it improves safety and security. Take for instance a simple (and nave)<space/><xhtml:code>strlen</xhtml:code><space/>function, written in C:<extension extension_name='source' lang="C"><preblock><preline>int strlen(const char *s)</preline><preline>{</preline><preline><space/><space/><space/><space/>int iter = 0;</preline><preline><space/><space/><space/><space/>if (s == NULL)</preline><preline><space/><space/><space/><space/><space/><space/><space/>return 0;</preline><preline><space/><space/><space/><space/>while (s[iter] != '\0') {</preline><preline><space/><space/><space/><space/><space/><space/><space/>iter++;</preline><preline><space/><space/><space/><space/>}</preline><preline><space/><space/><space/><space/>return iter;</preline><preline>}</preline></preblock></extension>This function assumes that the string being passed in is terminated by NULL (<xhtml:code>'\0'</xhtml:code>). However, what would happen if<space/><xhtml:code>char&amp;nbsp;buf[]&amp;nbsp;=&amp;nbsp;{'h','e','l','l','o','!'};</xhtml:code><space/>were passed to this string? This is perfectly legal in C, yet would cause<space/><xhtml:code>strlen</xhtml:code><space/>to iterate through memory not necessarily associated with the string<space/><xhtml:code>s</xhtml:code>. There are functions, such as<space/><xhtml:code>strnlen</xhtml:code><space/>which can be used to avoid such problems, but these functions are not standard with every implementation of<space/><link><target>ANSI C</target></link>. The Cyclone version of<space/><xhtml:code>strlen</xhtml:code><space/>is not so different from the C version:<extension extension_name='source' lang="C"><preblock><preline>int strlen(const char ? s)</preline><preline>{</preline><preline><space/><space/><space/>int iter, n = s.size;</preline><preline><space/><space/><space/>if (s == NULL)</preline><preline><space/><space/><space/><space/><space/><space/>return 0;</preline><preline><space/><space/><space/>for (iter = 0; iter &lt; n; iter++, s++) {</preline><preline><space/><space/><space/><space/><space/><space/>if (*s == '\0')</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/>return iter;</preline><preline><space/><space/><space/>}</preline><preline><space/><space/><space/>return n;</preline><preline>}</preline></preblock></extension>Here,<space/><xhtml:code>strlen</xhtml:code><space/>bounds itself by the length of the array passed to it, thus not going over the actual length. Each of the kinds of pointer type can be safely cast to each of the others, and arrays and strings are automatically cast to<space/><xhtml:code>?</xhtml:code><space/>by the compiler. (Casting from<space/><xhtml:code>?</xhtml:code><space/>to<space/><xhtml:code><list type='bullet'><listitem></listitem></list></xhtml:code><space/>invokes a<space/><link><target>bounds checking</target><part>bounds check</part></link>, and casting from<space/><xhtml:code>?</xhtml:code><space/>to<space/><xhtml:code>@</xhtml:code><space/>invokes both a<space/><xhtml:code>NULL</xhtml:code><space/>check and a bounds check. Casting from<space/><xhtml:code><list type='bullet'><listitem></listitem></list></xhtml:code><space/>or<space/><xhtml:code>?</xhtml:code><space/>results in no checks whatsoever; the resulting<space/><xhtml:code>?</xhtml:code><space/>pointer has a size of 1.)</paragraph><heading level='3'>Dangling pointers and region analysis</heading><paragraph>Consider the following code, in C:<extension extension_name='source' lang="C"><preblock><preline>char *itoa(int i)</preline><preline>{</preline><preline><space/><space/><space/>char buf[20];</preline><preline><space/><space/><space/>sprintf(buf,&quot;%d&quot;,i);</preline><preline><space/><space/><space/>return buf;</preline><preline>}</preline></preblock></extension>This returns an object that is allocated on the stack of the function<space/><xhtml:code>itoa</xhtml:code>, which is not available after the function returns. While<space/><link><target>GNU Compiler Collection</target><part>gcc</part></link><space/>and other compilers will warn about such code, the following will typically compile without warnings:<extension extension_name='source' lang="C"><preblock><preline>char *itoa(int i)</preline><preline>{</preline><preline><space/><space/><space/>char buf[20], *z;</preline><preline><space/><space/><space/>sprintf(buf,&quot;%d&quot;,i);</preline><preline><space/><space/><space/>z = buf;</preline><preline><space/><space/><space/>return z;</preline><preline>}</preline></preblock></extension>Cyclone does regional analysis of each segment of code, preventing dangling pointers, such as the one returned from this version of<space/><xhtml:code>itoa</xhtml:code>. All of the local variables in a given scope are considered to be part of the same region, separate from the heap or any other local region. Thus, when analyzing<space/><xhtml:code>itoa</xhtml:code>, the compiler would see that<space/><xhtml:code>z</xhtml:code><space/>is a pointer into the local stack, and would report an error.</paragraph><heading level='3'>Manual memory management</heading><paragraph><template><target>Empty section</target><arg name="date">January 2011</arg></template></paragraph><heading level='2'>Examples</heading><paragraph>The best example to start with is the classic<space/><link><target>Hello world</target></link><space/>program:<extension extension_name='source' lang="C"><preblock><preline>#include &lt;stdio.h&gt;</preline><preline>#include &lt;core.h&gt;</preline><preline>using Core;</preline><preline>int main(int argc, string_t ? args)</preline><preline>{</preline><preline><space/><space/><space/>if (argc &lt;= 1) {</preline><preline><space/><space/><space/><space/><space/><space/>printf(&quot;Usage: hello-cyclone &lt;name&gt;\n&quot;);</preline><preline><space/><space/><space/><space/><space/><space/>return 1;</preline><preline><space/><space/><space/>}</preline><preline><space/><space/><space/>printf(&quot;Hello from Cyclone, %s\n&quot;, args[1]);</preline><preline><space/><space/><space/>return 0;</preline><preline>}</preline></preblock></extension></paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>C (programming language)</target><part>C</part></link></listitem><listitem><link><target>ML (programming language)</target><part>ML</part></link></listitem><listitem><link><target>Rust (programming language)</target><part>Rust</part></link></listitem></list><heading level='2'>References</heading><paragraph><template><target>no footnotes</target><arg name="date">August 2015</arg></template></paragraph><list type='bullet'><listitem><link type='external' href='http://cyclone.thelanguage.org/wiki/User%20Manual'>Cyclone User Manual</link></listitem><listitem><link type='external' href='http://www.cs.umd.edu/~mwh/papers/cyclone-cuj.pdf'>Cyclone: a Type-safe Dialect of C</link><space/>by Dan Grossman, Michael Hicks, Trevor Jim, and Greg Morrisett - published January 2005</listitem></list><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://cyclone.thelanguage.org/'>Cyclone Homepage</link></listitem><listitem><link type='external' href='http://www.eecs.harvard.edu/~greg/cyclone/old_cyclone.html'>Old web site</link><space/>since official web site is not available.</listitem><listitem><link type='external' href='http://math.ifi.uzh.ch/fedora/5/i386/SRPMS.gemi/cyclone-1.0-1.src.rpm'>Cyclone 1.0 source code RPM</link></listitem><listitem><link type='external' href='http://cyclone.thelanguage.org/wiki/Download'>Cyclone - Source code repositories</link></listitem><listitem><link type='external' href='http://cyclone.thelanguage.org/wiki/Frequently%20Asked%20Questions'>Cyclone - FAQ</link></listitem><listitem><link type='external' href='http://cyclone.thelanguage.org/wiki/Cyclone%20for%20C%20Programmers'>Cyclone for C programmers</link></listitem></list><paragraph>Presentations:</paragraph><list type='bullet'><listitem><link type='external' href='http://www.cs.kent.ac.uk/people/staff/rej/morrisett-4.2.03.ppt'>Cyclone: A Type-Safe Dialect of C</link></listitem><listitem><link type='external' href='http://www.cs.washington.edu/homes/djg/slides/grossman_cyclone_jpl_05.ppt'>Cyclone: A Memory-Safe C-Level Programming Language</link></listitem></list><paragraph><template><target>CProLang</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Cyclone (Programming Language)</target></template><link><target>Category:C programming language family</target></link></paragraph></article>