<article title='Double-ended_queue'><paragraph><template><target>redirect-distinguish2</target><arg>Deque</arg><arg>dequeueing, a [[queue (abstract data type)|queue]] operation</arg></template><template><target>Distinguish</target><arg>Double-ended priority queue</arg></template>In<space/><link><target>computer science</target></link>, a<space/><bold>double-ended queue</bold><space/>(<bold>dequeue</bold>, often abbreviated to<space/><bold>deque</bold>, pronounced<space/><italics>deck</italics>) is an<space/><link><target>abstract data type</target></link><space/>that generalizes a<space/><link><target>queue (data structure)</target><part>queue</part></link>, for which elements can be added to or removed from either the front (head) or back (tail).<extension extension_name='ref'><link><target>Donald Knuth</target></link>.<space/><italics><link><target>The Art of Computer Programming</target></link></italics>, Volume 1:<space/><italics>Fundamental Algorithms</italics>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89683-4. Section 2.2.1: Stacks, Queues, and Deques, pp. 238&amp;ndash;243.</extension><space/>It is also often called a<space/><bold>head-tail linked list</bold>, though properly this refers to a specific<space/><link><target>data structure</target></link><space/><link><target>#Implementations</target><part>implementation</part></link><space/>(see below).</paragraph><heading level='2'>Naming conventions</heading><paragraph><italics>Deque</italics><space/>is sometimes written<space/><italics>dequeue</italics>, but this use is generally deprecated in technical literature or technical writing because<space/><italics>dequeue</italics><space/>is also a verb meaning &quot;to remove from a queue&quot;. Nevertheless, several<space/><link><target>Library (computing)</target><part>libraries</part></link><space/>and some writers, such as<space/><link><target>Alfred Aho</target><part>Aho</part></link>,<space/><link><target>John Hopcroft</target><part>Hopcroft</part></link>, and<space/><link><target>Jeffrey Ullman</target><part>Ullman</part></link><space/>in their textbook<space/><italics>Data Structures and Algorithms</italics>, spell it<space/><italics>dequeue</italics>.<space/><link><target>John C. Mitchell</target><part>John Mitchell</part></link>, author of<space/><italics>Concepts in Programming Languages,</italics><space/>also uses this terminology.</paragraph><heading level='2'>Distinctions and sub-types</heading><paragraph>This differs from the queue abstract data type or First-In-First-Out List (<link><target>FIFO (computing and electronics)</target><part>FIFO</part></link>), where elements can only be added to one end and removed from the other. This general data class has some possible sub-types:</paragraph><list type='bullet'><listitem>An input-restricted deque is one where deletion can be made from both ends, but insertion can be made at one end only.</listitem></list><list type='bullet'><listitem>An output-restricted deque is one where insertion can be made at both ends, but deletion can be made from one end only.</listitem></list><paragraph>Both the basic and most common list types in computing,<space/><link><target>queue (data structure)</target><part>queue</part><trail>s</trail></link><space/>and<space/><link><target>stack (data structure)</target><part>stack</part><trail>s</trail></link><space/>can be considered specializations of deques, and can be implemented using deques.</paragraph><heading level='2'>Operations</heading><paragraph>The basic operations on a deque are<space/><italics>enqueue</italics><space/>and<space/><italics>dequeue</italics><space/>on either end. Also generally implemented are<space/><italics><link><target>Peek (data type operation)</target><part>peek</part></link></italics><space/>operations, which return the value at that end without dequeuing it.</paragraph><paragraph>Names vary between languages; major implementations include:</paragraph><table class="wikitable"><tablerow><tablehead>operation</tablehead><tablehead>common name(s)</tablehead><tablehead><link><target>Ada (programming language)</target><part>Ada</part></link></tablehead><tablehead><link><target>C++</target></link></tablehead><tablehead><link><target>Java (programming language)</target><part>Java</part></link></tablehead><tablehead><link><target>Perl</target></link></tablehead><tablehead><link><target>PHP</target></link></tablehead><tablehead><link><target>Python (programming language)</target><part>Python</part></link></tablehead><tablehead><link><target>Ruby (programming language)</target><part>Ruby</part></link></tablehead><tablehead><link><target>JavaScript</target></link></tablehead></tablerow><tablerow><tablecell>insert element at back</tablecell><tablecell>inject, snoc</tablecell><tablecell><xhtml:code>Append</xhtml:code></tablecell><tablecell><xhtml:code>push_back</xhtml:code></tablecell><tablecell><xhtml:code>offerLast</xhtml:code></tablecell><tablecell><xhtml:code>push</xhtml:code></tablecell><tablecell><xhtml:code>array_push</xhtml:code></tablecell><tablecell><xhtml:code>append</xhtml:code></tablecell><tablecell><xhtml:code>push</xhtml:code></tablecell><tablecell><xhtml:code>push</xhtml:code></tablecell></tablerow><tablerow><tablecell>insert element at front</tablecell><tablecell>push, cons</tablecell><tablecell><xhtml:code>Prepend</xhtml:code></tablecell><tablecell><xhtml:code>push_front</xhtml:code></tablecell><tablecell><xhtml:code>offerFirst</xhtml:code></tablecell><tablecell><xhtml:code>unshift</xhtml:code></tablecell><tablecell><xhtml:code>array_unshift</xhtml:code></tablecell><tablecell><xhtml:code>appendleft</xhtml:code></tablecell><tablecell><xhtml:code>unshift</xhtml:code></tablecell><tablecell><xhtml:code>unshift</xhtml:code></tablecell></tablerow><tablerow><tablecell>remove last element</tablecell><tablecell>eject</tablecell><tablecell><xhtml:code>Delete_Last</xhtml:code></tablecell><tablecell><xhtml:code>pop_back</xhtml:code></tablecell><tablecell><xhtml:code>pollLast</xhtml:code></tablecell><tablecell><xhtml:code>pop</xhtml:code></tablecell><tablecell><xhtml:code>array_pop</xhtml:code></tablecell><tablecell><xhtml:code>pop</xhtml:code></tablecell><tablecell><xhtml:code>pop</xhtml:code></tablecell><tablecell><xhtml:code>pop</xhtml:code></tablecell></tablerow><tablerow><tablecell>remove first element</tablecell><tablecell>pop</tablecell><tablecell><xhtml:code>Delete_First</xhtml:code></tablecell><tablecell><xhtml:code>pop_front</xhtml:code></tablecell><tablecell><xhtml:code>pollFirst</xhtml:code></tablecell><tablecell><xhtml:code>shift</xhtml:code></tablecell><tablecell><xhtml:code>array_shift</xhtml:code></tablecell><tablecell><xhtml:code>popleft</xhtml:code></tablecell><tablecell><xhtml:code>shift</xhtml:code></tablecell><tablecell><xhtml:code>shift</xhtml:code></tablecell></tablerow><tablerow><tablecell>examine last element</tablecell><tablecell></tablecell><tablecell><xhtml:code>Last_Element</xhtml:code></tablecell><tablecell><xhtml:code>back</xhtml:code></tablecell><tablecell><xhtml:code>peekLast</xhtml:code></tablecell><tablecell><xhtml:code>$array[-1]</xhtml:code></tablecell><tablecell><xhtml:code>end</xhtml:code></tablecell><tablecell><xhtml:code>&lt;obj&gt;[-1]</xhtml:code></tablecell><tablecell><xhtml:code>last</xhtml:code></tablecell><tablecell><xhtml:code>&lt;obj&gt;[&lt;obj&gt;.length - 1]</xhtml:code></tablecell></tablerow><tablerow><tablecell>examine first element</tablecell><tablecell></tablecell><tablecell><xhtml:code>First_Element</xhtml:code></tablecell><tablecell><xhtml:code>front</xhtml:code></tablecell><tablecell><xhtml:code>peekFirst</xhtml:code></tablecell><tablecell><xhtml:code>$array[0]</xhtml:code></tablecell><tablecell><xhtml:code>reset</xhtml:code></tablecell><tablecell><xhtml:code>&lt;obj&gt;[0]</xhtml:code></tablecell><tablecell><xhtml:code>first</xhtml:code></tablecell><tablecell><xhtml:code>&lt;obj&gt;[0]</xhtml:code></tablecell></tablerow></table><heading level='2'>Implementations</heading><paragraph>There are at least two common ways to efficiently implement a deque: with a modified<space/><link><target>dynamic array</target></link><space/>or with a<space/><link><target>doubly linked list</target></link>.</paragraph><paragraph>The dynamic array approach uses a variant of a<space/><link><target>dynamic array</target></link><space/>that can grow from both ends, sometimes called<space/><bold>array deques</bold>. These array deques have all the properties of a dynamic array, such as constant-time<space/><link><target>random access</target></link>, good<space/><link><target>locality of reference</target></link>, and inefficient insertion/removal in the middle, with the addition of amortized constant-time insertion/removal at both ends, instead of just one end. Three common implementations include:</paragraph><list type='bullet'><listitem>Storing deque contents in a<space/><link><target>circular buffer</target></link>, and only resizing when the buffer becomes full. This decreases the frequency of resizings.</listitem><listitem>Allocating deque contents from the center of the underlying array, and resizing the underlying array when either end is reached. This approach may require more frequent resizings and waste more space, particularly when elements are only inserted at one end.</listitem><listitem>Storing contents in multiple smaller arrays, allocating additional arrays at the beginning or end as needed. Indexing is implemented by keeping a dynamic array containing pointers to each of the smaller arrays.</listitem></list><heading level='2'>Language support</heading><paragraph><link><target>Ada (programming language)</target><part>Ada</part></link>'s containers provides the generic packages<space/><xhtml:tt>Ada.Containers.Vectors</xhtml:tt><space/>and<space/><xhtml:tt>Ada.Containers.Doubly_Linked_Lists</xhtml:tt>, for the dynamic array and linked list implementations, respectively.</paragraph><paragraph>C++'s<space/><link><target>Standard Template Library</target></link><space/>provides the class templates<space/><xhtml:tt>std::deque</xhtml:tt><space/>and<space/><xhtml:tt>std::list</xhtml:tt>, for the multiple array and linked list implementations, respectively.</paragraph><paragraph>As of Java 6, Java's Collections Framework provides a new<space/><template><target>Javadoc:SE</target><arg>java/util</arg><arg>Deque</arg></template><space/>interface that provides the functionality of insertion and removal at both ends. It is implemented by classes such as<space/><template><target>Javadoc:SE</target><arg>java/util</arg><arg>ArrayDeque</arg></template><space/>(also new in Java 6) and<space/><template><target>Javadoc:SE</target><arg>java/util</arg><arg>LinkedList</arg></template>, providing the dynamic array and linked list implementations, respectively. However, the<space/><xhtml:tt>ArrayDeque</xhtml:tt>, contrary to its name, does not support random access.</paragraph><paragraph>Python 2.4 introduced the<space/><xhtml:code>collections</xhtml:code><space/>module with support for<space/><link type='external' href='https://docs.python.org/2.7/library/collections.html#deque-objects'>deque objects</link>. It is implemented using a doubly linked list of fixed-length subarrays.<space/></paragraph><paragraph>As of PHP 5.3, PHP's SPL extension contains the 'SplDoublyLinkedList' class that can be used to implement Deque datastructures. Previously to make a Deque structure the array functions array_shift/unshift/pop/push had to be used instead.</paragraph><paragraph><link><target>Glasgow Haskell Compiler</target><part>GHC</part></link>'s<space/><link type='external' href='http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html'>Data.Sequence</link><space/>module implements an efficient, functional deque structure in<space/><link><target>Haskell (programming language)</target><part>Haskell</part></link>. The implementation uses<space/><link><target>23 tree</target><part>23 finger trees</part></link><space/>annotated with sizes. There are other (fast) possibilities to implement purely functional (thus also<space/><link><target>persistent data structure</target><part>persistent</part></link>) double queues (most using heavily<space/><link><target>lazy evaluation</target></link>).<extension extension_name='ref'>http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf C. Okasaki, &quot;Purely Functional Data Structures&quot;, September 1996</extension><extension extension_name='ref'>Adam L. Buchsbaum and Robert E. Tarjan. Confluently persistent deques via data structural bootstrapping. Journal of Algorithms, 18(3):513547, May 1995. (pp. 58, 101, 125)</extension><space/>Kaplan and Tarjan were the first to implement optimal confluently persistent catenable deques.<extension extension_name='ref'>Haim Kaplan and Robert E. Tarjan. Purely functional representations of catenable sorted lists. In ACM Symposium on Theory of Computing, pages 202211, May 1996. (pp. 4, 82, 84, 124)</extension><space/>Their implementation was strictly purely functional in the sense that it did not use lazy evaluation. Okasaki simplified the data structure by using lazy evaluation with a bootstrapped data structure and degrading the performance bounds from worst-case to amortized. Kaplan, Okasaki, and Tarjan produced a simpler, non-bootstrapped, amortized version that can be implemented either using lazy evaluation or more efficiently using mutation in a broader but still restricted fashion. Mihaesau and Tarjan created a simpler (but still highly complex) strictly purely functional implementation of catenable deques, and also a much simpler implementation of strictly purely functional non-catenable deques, both of which have optimal worst-case bounds.</paragraph><heading level='2'>Complexity</heading><list type='bullet'><listitem>In a doubly linked list implementation and assuming no allocation/deallocation overhead, the<space/><link><target>Computational complexity theory</target><part>time complexity</part></link><space/>of all deque operations is<space/><link><target>Big O notation</target><part>O(1)</part></link>. Additionally, the time complexity of insertion or deletion in the middle, given an iterator, is O(1); however, the time complexity of random access by index is O(n).</listitem><listitem>In a growing array, the<space/><link><target>Amortized analysis</target><part>amortized</part></link><space/>time complexity of all deque operations is<space/><link><target>Big O notation</target><part>O(1)</part></link>. Additionally, the time complexity of random access by index is O(1); but the time complexity of insertion or deletion in the middle is<space/><link><target>Big O notation</target><part>O(n)</part></link>.</listitem></list><heading level='2'>Applications</heading><paragraph>One example where a deque can be used is the<space/><italics>A-Steal</italics><space/><link><target>Scheduling algorithm</target><part>job scheduling algorithm</part></link>.<extension extension_name='ref'><template><target>cite book</target><arg name="author">Eitan Frachtenberg, Uwe Schwiegelshohn<space/></arg><arg name="title">Job Scheduling Strategies for Parallel Processing: 12th International Workshop, JSSPP 2006
</arg><arg name="publisher">Springer</arg><arg name="year">2007</arg><arg name="isbn">3-540-71034-5</arg></template><space/>See p.22.</extension><space/>This algorithm implements task scheduling for several processors. A separate deque with threads to be executed is maintained for each processor. To execute the next thread, the processor gets the first element from the deque (using the &quot;remove first element&quot; deque operation). If the current thread<space/><link><target>Fork (operating system)</target><part>forks</part></link>, it is put back to the front of the deque (&quot;insert element at front&quot;) and a new thread is executed. When one of the processors finishes execution of its own threads (i.e. its deque is empty), it can &quot;steal&quot; a thread from another processor: it gets the last element from the deque of another processor (&quot;remove last element&quot;) and executes it. The steal-job scheduling algorithm is used by Intel's Threading Building Blocks (TBB) library for parallel programming.</paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Queue (data structure)</target><part>Queue</part></link></listitem><listitem><link><target>Priority queue</target></link></listitem></list><heading level='2'>References</heading><paragraph><template><target>reflist</target></template></paragraph><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://www.sgi.com/tech/stl/Deque.html'>SGI STL Documentation: deque&lt;T, Alloc&gt;</link></listitem><listitem><link type='external' href='http://www.codeproject.com/KB/stl/vector_vs_deque.aspx'>Code Project: An In-Depth Study of the STL Deque Container</link></listitem><listitem><link type='external' href='http://www.martinbroadhurst.com/articles/deque.html'>Deque implementation in C</link></listitem><listitem><link type='external' href='http://www.ludvikjerabek.com/downloads.html'>VBScript implementation of stack, queue, deque, and Red-Black Tree</link></listitem><listitem><link type='external' href='https://code.google.com/p/deques/source/browse/'>Multiple implementations of non-catenable deques in Haskell</link></listitem></list><paragraph><template><target>Data structures</target></template></paragraph><paragraph><link><target>Category:Abstract data types</target></link></paragraph></article>