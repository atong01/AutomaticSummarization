<article title='Accumulator_%28computing%29'><paragraph><link><target>File:Early SSA accounting operations.jpg</target><part>thumb</part><part>Accumulators on a<space/><link><target>tabulating machine</target></link><space/>circa 1936. Each of the four registers can store a 10-digit decimal number.</part></link>In a<space/><link><target>computer</target></link>'s central processing unit (<link><target>central processing unit</target><part>CPU</part></link>), an<space/><bold>accumulator</bold><space/>is a<space/><link><target>processor register</target><part>register</part></link><space/>in which<space/><link><target>:wikt:intermediate</target><part>intermediate</part></link><space/><link><target>arithmetic logic unit</target><part>arithmetic and logic</part></link><space/>results are stored.<space/></paragraph><paragraph>Without a register like an accumulator, it would be necessary to write the result of each calculation (addition, multiplication,<space/><link><target>Bitwise operation#bit shifts</target><part>shift</part></link>, etc.) to<space/><link><target>primary storage</target><part>main memory</part></link>, perhaps only to be read right back again for use in the next<space/><link><target>operation (computer science)</target><part>operation</part></link>. Access to main memory is slower than access to a register like the accumulator because the technology used for the large main memory is slower (but cheaper) than that used for a register. Early electronic computer systems were often split into two groups, those with accumulators and those without.</paragraph><paragraph>Modern computer systems often have multiple general purpose registers that operate as accumulators, and the term is no longer as common as it once was. However, a number of special-purpose processors still use a single accumulator for their work, in order to simplify their design.</paragraph><heading level='2'>Basic concept</heading><paragraph>Mathematical operations often take place in a stepwise fashion, using the results from one operation as the input to the next. For instance, a manual calculation of a worker's weekly payroll might look something like:</paragraph><preblock><preline><space/>look up the number of hours worked from the employee's time card</preline><preline><space/>look up the pay rate for that employee from a table</preline><preline><space/>multiply the hours by the pay rate to get their basic weekly pay</preline><preline><space/>multiply their basic pay by a fixed percentage to account for income tax</preline><preline><space/>subtract that number from their basic pay to get their weekly pay after tax</preline><preline><space/>multiply that result by another fixed percentage to account for retirement plans</preline><preline><space/>subtract that number from their basic pay to get their weekly pay after all deductions</preline></preblock><paragraph>A computer program carrying out the same task would follow the same basic sequence of operations, although the values being looked up would all be stored in computer memory. In early computers the number of hours would likely be held on a<space/><link><target>punch card</target></link><space/>and the pay rate in some other form of memory, perhaps a<space/><link><target>magnetic drum</target></link>. Once the multiplication is complete, the result needs to be placed somewhere. On a &quot;drum machine&quot; this would likely be back to the drum, an operation that takes considerable time. And then the very next operation has to read that value back in, which introduces another considerable delay.</paragraph><paragraph>Accumulators dramatically improve performance in systems like these by providing a scratchpad area where the results of one operation can be fed to the next one for little or no performance penalty. In the example above, the basic weekly pay would be calculated and placed in the accumulator, which could then immediately be used by the income tax calculation. This removes one save and one read operation from the sequence, operations that generally took tens to hundreds of times as long as the multiplication itself.</paragraph><heading level='2'>Accumulator machines</heading><paragraph>An<space/><bold>accumulator machine</bold>, also called a<space/><link><target>Instruction_set_architecture#Number_of_operands</target><part>1-operand machine</part></link>, or a CPU with<space/><italics>accumulator-based architecture</italics>, is a kind of CPU where, although it may have several registers, the CPU mostly stores the results of calculations in one special register, typically called &quot;the accumulator&quot;. Almost all early computers were accumulator machines with only the high-performance &quot;<link><target>supercomputer</target><trail>s</trail></link>&quot; having multiple registers. Then as<space/><link><target>mainframe computer</target><part>mainframe</part></link><space/>systems gave way to<space/><link><target>microcomputer</target><trail>s</trail></link>, accumulator architectures were again popular with the<space/><link><target>MOS 6502</target></link><space/>being a notable example. Many 8-bit<space/><link><target>microcontroller</target><trail>s</trail></link><space/>that are still popular as of 2014, such as the<space/><link><target>PICmicro</target></link><space/>and<space/><link><target>8051</target></link>, are accumulator-based machines.</paragraph><paragraph>Modern CPUs are typically 2-operand or 3-operand machines. The additional operands specify which one of many<space/><link><target>general purpose register</target><trail>s</trail></link><space/>(also called &quot;general purpose accumulators&quot;<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.freescale.com/webapp/sps/site/overview.jsp?code</arg><arg name="title">HC16 Overview<space/></arg><arg name="publisher">Freescale.com<space/></arg><arg name="date"><space/></arg><arg name="accessdate">2008-09-22<space/></arg><arg name="deadurl">yes<space/></arg><arg name="archiveurl">https://web.archive.org/20070928031937/http://www.freescale.com/webapp/sps/site/overview.jsp?code</arg><arg name="archivedate">28 September 2007<space/></arg></template></extension>) are used as the source and destination for calculations. These CPUs are not considered &quot;accumulator machines&quot;.</paragraph><paragraph>The characteristic which distinguishes one register as being the accumulator of a<space/><link><target>computer architecture</target></link><space/>is that the accumulator (if the architecture were to have one) would be used as an<space/><italics>implicit</italics><space/><link><target>operand</target></link><space/>for arithmetic<space/><link><target>instruction (computer science)</target><part>instruction</part><trail>s</trail></link>. For instance, a CPU might have an instruction like:<space/><xhtml:code>ADD<space/><italics><link><target>memory address</target><part>memaddress</part></link></italics></xhtml:code><space/>that adds the value read from memory location<space/><italics>memaddress</italics><space/>to the value in the accumulator, placing the result back in the accumulator. The accumulator is not identified in the instruction by a register number; it is<space/><link><target>addressing_mode#Implicit</target><part>implicit</part></link><space/>in the instruction and no other register can be specified in the instruction. Some architectures use a particular register as an accumulator in some instructions, but other instructions use register numbers for explicit operand specification.</paragraph><heading level='2'>History of the computer accumulator</heading><paragraph>Any system that uses a single &quot;memory&quot; to store the result of multiple operations can be considered an accumulator.<space/><link><target>J. Presper Eckert</target></link><space/>refers to even the earliest<space/><link><target>adding machine</target><trail>s</trail></link><space/>of<space/><link><target>Gottfried Leibnitz</target></link><space/>and<space/><link><target>Blaise Pascal</target></link><space/>as accumulator-based systems.<extension extension_name='ref'>J. Presper Eckert, &quot;A Survey of Digital Computer Memory Systems&quot;, IEEE Annals of the History of Computing, 1988, pp. 15-28.</extension></paragraph><paragraph>Historical convention dedicates a register to &quot;the accumulator&quot;, an &quot;arithmetic organ&quot; that literally accumulates its number during a sequence of arithmetic operations:</paragraph><list type='ident'><listitem>&quot;The first part of our arithmetic organ ... should be a parallel storage organ which can receive a number and add it to the one already in it, which is also able to clear its contents and which can store what it contains. We will call such an organ an Accumulator. It is quite conventional in principle in past and present computing machines of the most varied types, e.g. desk multipliers, standard IBM counters, more modern relay machines, the ENIAC&quot; (Goldstine and von Neumann, 1946; p. 98 in Bell and Newell 1971).</listitem></list><paragraph>Just a few of the instructions are, for example (with some modern interpretation):</paragraph><list type='bullet'><listitem>Clear accumulator and add number from memory location X</listitem><listitem>Clear accumulator and subtract number from memory location X</listitem><listitem>Add number copied from memory location X to the contents of the accumulator</listitem><listitem>Subtract number copied from memory location X from the contents of the accumulator</listitem><listitem>Clear accumulator and shift contents of register into accumulator</listitem></list><paragraph>No convention exists regarding the names for operations from registers to accumulator and from accumulator to registers. Tradition (e.g.<space/><link><target>Donald Knuth</target></link>'s (1973) hypothetical<space/><link><target>MIX</target></link><space/>computer), for example, uses two instructions called<space/><italics>load accumulator</italics><space/>from register/memory (e.g. &quot;LDA r&quot;) and<space/><italics>store accumulator</italics><space/>to register/memory (e.g. &quot;STA r&quot;). Knuth's model has many other instructions as well.</paragraph><heading level='2'>Notable accumulator-based computers</heading><paragraph><link><target>File:IBM 701console.jpg</target><part>thumb</part><part>Front panel of an<space/><link><target>IBM 701</target></link><space/>computer with lights displaying the accumulator and other registers</part></link>Most of IBM's early binary &quot;scientific&quot; computers, beginning with the vacuum tube<space/><link><target>IBM 701</target></link><space/>in 1952, used a single 36-bit accumulator, along with a separate multiplier/quotient register to handle operations with longer results. The<space/><link><target>IBM 650</target></link>, a decimal machine, had one 10 digit accumulator; the<space/><link><target>IBM 7070</target></link>, a later, transistorized decimal machine had three accumulators.</paragraph><paragraph>The 12-bit<space/><link><target>PDP-8</target></link><space/>was one of the first minicomputers to use accumulators, and inspired many later machines.<extension extension_name='ref'><paragraph><link><target>Digital Equipment Corporation</target></link>,<space/><link><target>Maynard, Massachusetts</target></link><space/>(1961) &quot;<link type='external' href='http://bitsavers.trailing-edge.com/pdf/dec/pdp1/F15B_PDP1_Handbook_1961.pdf'>PROGRAMMED DATA PROCESSOR-1 MANUAL</link>&quot;, page 7: PDP-1 system block diagram accessdate=2014-07-03. The PDP-1 was an 18-bit processor, and was a predecessor of<space/><link><target>PDP-8</target></link></paragraph><list type='bullet'><listitem><link><target>TX-0</target></link><space/>was the transistorized predecessor of<space/><link><target>PDP-1</target></link></listitem><listitem><link><target>Whirlwind I</target></link><space/>was the vacuum tube predecessor of Tx-0</listitem></list></extension><space/>The PDP-8 had but one accumulator. The<space/><link><target>HP 2100</target></link><space/>and<space/><link><target>Data General Nova</target></link><space/>had 2 and 4 accumulators. The Nova was created when this follow-on to the PDP-8 was rejected in favor of what would become the<space/><link><target>PDP-11</target></link>. The Nova provided four accumulators, AC0-AC3, although AC2 and AC3 could also be used to provide offset addresses, tending towards more generality of usage for the registers. The<space/><link><target>PDP-11</target></link><space/>introduced a more contemporary model of general registers, numbered R0-R7 or more, adopted by most later CISC and RISC machines.</paragraph><preblock><preline></preline></preblock><paragraph>Early 4-bit and 8-bit microprocessors such as the<space/><link><target>4004</target></link>,<space/><link><target>8008</target></link><space/>and numerous others, typically had single accumulators. The<space/><link><target>8051</target></link><space/>microcontroller has two, a primary accumulator and a secondary accumulator, where the second is used by instructions only when multiplying (MUL AB) or dividing (DIV AB); the former splits the 16-bit result between the two 8-bit accumulators, whereas the latter stores the quotient on the primary accumulator A and the remainder in the secondary accumulator B. As a direct descendent of the 8008, the<space/><link><target>8080</target></link>, and the<space/><link><target>Intel 8086</target><part>8086</part></link>, the modern ubiquitous<space/><link><target>Intel x86</target></link><space/>processors still uses the primary accumulator EAX and the secondary accumulator EDX for multiplication and division of large numbers. For instance, MUL ECX will multiply the 32-bit registers ECX and EAX and split the 64-bit result between EAX and EDX. However, MUL and DIV are special cases, other arithmetic-logical instructions (ADD, SUB, CMP, AND, OR, XOR, TEST) may specify any of the eight registers EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI as the accumulator (i.e. left operand and destination); this is also supported for multiply if the upper half of the result is not required. x86 is thus a fairly general register architecture, despite being based on an accumulator model.<extension extension_name='ref'><template><target>cite book</target><arg name="last"><space/>Irvine<space/></arg><arg name="first"><space/>Kip R.<space/></arg><arg name="title"><space/>Assembly Language for Intel-Based Computers<space/></arg><arg name="year"><space/>2007<space/></arg><arg name="edition"><space/>5th<space/></arg><arg name="publisher">Pearson Prentice Hall<space/></arg><arg name="isbn">0-13-238310-1<space/></arg><arg name="pages">633, 622</arg></template></extension><space/>The 64-bit extension of x86,<space/><link><target>x86-64</target></link>, has been further generalized to 16 instead of 8 general registers.</paragraph><heading level='2'>References</heading><paragraph><extension extension_name='references'></extension></paragraph><list type='bullet'><listitem>Goldstine, Herman H., and von Neumann, John, &quot;Planning and Coding of the Problems for an Electronic Computing Instrument&quot;, Rep. 1947,<space/><link><target>Institute for Advanced Study</target></link>, Princeton. Reprinted on pp.&amp;nbsp;92119 in Bell, C. Gordon and Newell, Allen (1971),<space/><italics>Computer Structures: Readings and Examples</italics>, McGraw-Hill Book Company, New York. ISBN 0-07-004357-4}. A veritable treasure-trove of detailed descriptions of ancient machines including photos.</listitem></list><paragraph><template><target>FOLDOC</target></template></paragraph><paragraph><template><target>Authority control</target></template><template><target>DEFAULTSORT:Accumulator (Computing)</target></template><link><target>Category:Central processing unit</target></link><link><target>Category:Digital registers</target></link></paragraph></article>