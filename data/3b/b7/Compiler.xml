<article title='Compiler'><paragraph><template><target>About</target><arg>the computing term</arg><arg>the anime</arg><arg>Compiler (anime)</arg></template><template><target>Redirect2</target><arg>Compile</arg><arg>compiling</arg><arg>the software company</arg><arg>Compile (publisher)</arg><arg>other uses</arg><arg>Compilation (disambiguation){{!}}Compilation</arg></template><template><target>multiple issues</target><arg name="{{citation style|date">January 2014}}
{{more footnotes|date</arg></template><template><target>Program execution</target></template><template><target>Use dmy dates</target><arg name="date">July 2012</arg></template></paragraph><paragraph><link><target>File:Compiler.svg</target><part>right</part><part>thumb</part><part>300px</part><part>A diagram of the operation of a typical multi-language, multi-target compiler</part></link></paragraph><paragraph>A<space/><bold>compiler</bold><space/>is a<space/><link><target>computer program</target></link><space/>(or a set of programs) that transforms<space/><link><target>source code</target></link><space/>written in a<space/><link><target>programming language</target></link><space/>(the source language) into another computer language (the target language), with the latter often having a binary form known as<space/><link><target>object code</target></link>.<extension extension_name='ref'><template><target>cite news</target><arg name="title">Definition of:compiler</arg><arg name="url">http://www.pcmag.com/encyclopedia/term/40105/compiler<space/></arg><arg name="work">PC Magazine</arg></template></extension><space/>The most common reason for converting a source code is to create an<space/><link><target>executable</target></link><space/>program.</paragraph><paragraph>The name &quot;compiler&quot; is primarily used for programs that translate source code from a<space/><link><target>high-level programming language</target></link><space/>to a lower level language (e.g.,<space/><link><target>assembly language</target></link><space/>or<space/><link><target>machine code</target></link>). If the compiled program can run on a computer whose<space/><link><target>CPU</target></link><space/>or<space/><link><target>operating system</target></link><space/>is different from the one on which the compiler runs, the compiler is known as a<space/><link><target>cross-compiler</target></link>. More generally, compilers are a specific type of<space/><link><target>Translator (computing)</target><part>translator</part></link>.</paragraph><paragraph>A program that translates from a low level language to a higher level one is a<space/><link><target>decompiler</target></link>. A program that translates between high-level languages is usually called a<space/><link><target>source-to-source compiler</target></link><space/>or transpiler. A language<space/><link><target>rewriting</target><part>rewriter</part></link><space/>is usually a program that translates the form of expressions without a change of language. The term<space/><link><target>compiler-compiler</target></link><space/>is sometimes used to refer to a<space/><link><target>parser generator</target></link>, a tool often used to help create the<space/><link><target>lexical analysis</target><part>lexer</part></link><space/>and<space/><link><target>parser</target></link>.</paragraph><paragraph>A compiler is likely to perform many or all of the following operations:<space/><link><target>lexical analysis</target></link>,<space/><link><target>preprocessing</target></link>,<space/><link><target>parsing</target></link>,<space/><link><target>Semantic analysis (compilers)</target><part>semantic analysis</part></link><space/>(<link><target>syntax-directed translation</target></link>),<space/><link><target>code generation (compiler)</target><part>code generation</part></link>, and<space/><link><target>code optimization</target></link>. Program faults caused by incorrect compiler behavior can be very difficult to track down and work around; therefore, compiler implementors invest significant effort to ensure<space/><link><target>compiler correctness</target></link>.</paragraph><heading level='2'>History</heading><paragraph><template><target>Main</target><arg>History of compiler construction</arg></template></paragraph><paragraph>Software for early computers was primarily written in assembly language. Although the first high level language is nearly as old as the first computer, the limited<space/><link><target>main memory</target><part>memory</part></link><space/>capacity of early computers led to substantial technical challenges when the first compilers were designed.<template><target>discuss</target><arg>Vague comments about "first" in lede</arg></template></paragraph><paragraph>The first high-level programming language (<link><target>Plankalkl</target></link>) was proposed by<space/><link><target>Konrad Zuse</target></link><space/>in 1943. The first compiler was written by<space/><link><target>Grace Hopper</target></link>, in 1952, for the<space/><link><target>A-0 programming language</target></link>; the A-0 functioned more as a loader or linker than the modern notion of a compiler. The first<space/><link><target>autocode</target></link><space/>and its compiler were developed by<space/><link><target>Alick Glennie</target></link><space/>in 1952 for the Mark 1 computer at the University of Manchester and is considered by some to be the first compiled programming language. The<space/><link><target>FORTRAN</target></link><space/>team led by<space/><link><target>John Backus</target></link><space/>at<space/><link><target>IBM</target></link><space/>is generally credited as having introduced the first complete compiler in 1957.<space/><link><target>COBOL</target></link><space/>was an early language to be compiled on multiple architectures, in 1960.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.interesting-people.org/archives/interesting-people/199706/msg00011.html<space/></arg><arg name="title">IP: The World's First COBOL Compilers<space/></arg><arg name="date">12 June 1997<space/></arg><arg name="publisher">interesting-people.org</arg></template></extension></paragraph><paragraph>In many application domains the idea of using a higher level language quickly caught on. Because of the expanding functionality supported by newer<space/><link><target>programming language</target><trail>s</trail></link><space/>and the increasing complexity of computer architectures, compilers have become more complex.</paragraph><paragraph>Early compilers were written in assembly language. The first<space/><italics><link><target>self-hosting</target></link></italics><space/>compiler capable of compiling its own source code in a high-level language was created in 1962 for<space/><link><target>Lisp programming language</target><part>Lisp</part></link><space/>by Tim Hart and Mike Levin at<space/><link><target>Massachusetts Institute of Technology</target><part>MIT</part></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="url">ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf<space/></arg><arg name="author">T. Hart and M. Levin<space/></arg><arg name="title">The New Compiler, AIM-39 - CSAIL Digital Archive - Artificial Intelligence Laboratory Series<space/></arg><arg name="publisher">publications.ai.mit.edu</arg></template></extension><space/>Since the 1970s it has become common practice to implement a compiler in the language it compiles, although both<space/><link><target>Pascal (programming language)</target><part>Pascal</part></link><space/>and<space/><link><target>C (programming language)</target><part>C</part></link><space/>have been popular choices for implementation language. Building a self-hosting compiler is a<space/><link><target>bootstrapping (compilers)</target><part>bootstrapping</part></link><space/>problemthe first such compiler for a language must be compiled either by hand or by a compiler written in a different language, or (as in Hart and Levin's Lisp compiler) compiled by running the compiler in an<space/><link><target>Interpreter (computing)</target><part>interpreter</part></link>.</paragraph><heading level='3'>Compilers in education</heading><paragraph>Compiler construction and<space/><link><target>compiler optimization</target></link><space/>are taught at universities and schools as part of a<space/><link><target>computer science</target></link><space/>curriculum.<extension extension_name='ref'>Chakraborty, P., Saxena, P. C., Katti, C. P., Pahwa, G., Taneja, S. A new practicum in compiler construction.<space/><italics>Computer Applications in Engineering Education</italics>, In Press. http://onlinelibrary.wiley.com/doi/10.1002/cae.20566/pdf</extension><space/>Such courses are usually supplemented with the implementation of a compiler for an<space/><link><target>educational programming language</target></link>. A well-documented example is<space/><link><target>Niklaus Wirth</target></link>'s<space/><link><target>PL/0</target></link><space/>compiler, which Wirth used to teach compiler construction in the 1970s.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.246.dk/pl0.html<space/></arg><arg name="title">The PL/0 compiler/interpreter</arg></template></extension><space/>In spite of its simplicity, the PL/0 compiler introduced several influential concepts to the field:</paragraph><list type='numbered'><listitem>Program development by stepwise refinement (also the title of a 1971 paper by Wirth)<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.acm.org/classics/dec95/<space/></arg><arg name="title">The ACM Digital Library</arg></template></extension></listitem><listitem>The use of a<space/><link><target>recursive descent parser</target></link></listitem><listitem>The use of<space/><link><target>EBNF</target></link><space/>to specify the<space/><link><target>syntax (programming languages)</target><part>syntax</part></link><space/>of a language</listitem><listitem>A<space/><link><target>code generation (compiler)</target><part>code generator</part></link><space/>producing portable<space/><link><target>Bytecode</target><part>P-code</part></link></listitem><listitem>The use of<space/><link><target>T-diagram</target><trail>s</trail></link><space/>in the formal description of the<space/><link><target>bootstrapping (compilers)</target><part>bootstrapping</part></link><space/>problem.</listitem></list><heading level='2'>Compilation</heading><paragraph><template><target>unreferenced section</target><arg name="date">May 2013</arg></template>Compilers enabled the development of programs that are machine-independent. Before the development of FORTRAN, the first higher-level language, in the 1950s, machine-dependent<space/><link><target>assembly language</target></link><space/>was widely used. While<space/><link><target>assembly language</target></link><space/>produces more<space/><link><target>Abstraction layer</target><part>abstraction</part></link><space/>than machine code on the same architecture, just as with machine code, it has to be modified or rewritten if the program is to be executed on different<space/><link><target>computer hardware</target></link><space/>architecture.</paragraph><paragraph>With the advent of high-level programming languages that followed FORTRAN, such as COBOL, C, and<space/><link><target>BASIC</target></link>, programmers could write machine-independent source programs. A compiler translates the high-level source programs into target programs in machine languages for the specific hardware. Once the target program is generated, the user can execute the program.</paragraph><heading level='3'>Structure of a compiler</heading><paragraph>Compilers bridge source programs in high-level languages with the underlying hardware. A compiler verifies code syntax, generates efficient object code, performs run-time organization, and formats the output according to<space/><link><target>Assembler (computing)</target><part>assembler</part></link><space/>and<space/><link><target>Linker (computing)</target><part>linker</part></link><space/>conventions. A compiler consists of:</paragraph><list type='bullet'><listitem><italics>The front end</italics>: Verifies syntax and semantics, and generates an<space/><italics>intermediate representation</italics><space/>or<space/><italics>IR</italics><space/>of the source code for processing by the middle-end. Performs<space/><link><target>type checking</target></link><space/>by collecting type information. Generates errors and warning, if any, in a useful way. Aspects of the front end include lexical analysis, syntax analysis, and semantic analysis.</listitem><listitem><italics>The middle end</italics>: Performs optimizations, including removal of useless or unreachable code, discovery and propagation of constant values, relocation of computation to a less frequently executed place (e.g., out of a loop), or specialization of computation based on the context. Generates another IR for the backend.</listitem><listitem><italics>The back end</italics>: Generates the assembly code, performing<space/><link><target>register allocation</target></link><space/>in process. (Assigns<space/><link><target>processor register</target><trail>s</trail></link><space/>for the program variables where possible.) Optimizes target code utilization of the hardware by figuring out how to keep parallel<space/><link><target>execution unit</target><trail>s</trail></link><space/>busy, filling<space/><link><target>delay slot</target><trail>s</trail></link>. Although most algorithms for optimization are in<space/><link><target>NP (complexity)</target><part>NP</part></link>, heuristic techniques are well-developed.</listitem></list><heading level='2'>Compiler output</heading><paragraph><template><target>unreferenced section</target><arg name="date">May 2013</arg></template>One classification of compilers is by the<space/><link><target>platform (computing)</target><part>platform</part></link><space/>on which their generated code executes. This is known as the<space/><italics>target platform.</italics></paragraph><paragraph>A<space/><italics>native</italics><space/>or<space/><italics>hosted</italics><space/>compiler is one which output is intended to directly run on the same type of computer and operating system that the compiler itself runs on. The output of a<space/><link><target>cross compiler</target></link><space/>is designed to run on a different platform. Cross compilers are often used when developing software for<space/><link><target>embedded system</target><trail>s</trail></link><space/>that are not intended to support a software development environment.</paragraph><paragraph>The output of a compiler that produces code for a<space/><link><target>virtual machine</target></link><space/>(VM) may or may not be executed on the same platform as the compiler that produced it. For this reason such compilers are not usually classified as native or cross compilers.</paragraph><paragraph>The lower level language that is the target of a compiler may itself be a<space/><link><target>high-level programming language</target></link>. C, often viewed as some sort of portable assembler, can also be the target language of a compiler. E.g.:<space/><link><target>Cfront</target></link>, the original compiler for<space/><link><target>C++</target></link><space/>used C as target language. The C created by such a compiler is usually not intended to be read and maintained by humans. So<space/><link><target>indent style</target></link><space/>and pretty C intermediate code are irrelevant. Some features of C turn it into a good target language. E.g.: C code with<space/><link><target>C preprocessor#Special macros and directives</target><part><xhtml:code><list type='numbered'><listitem>line</listitem></list></xhtml:code></part></link><space/>directives can be generated to support<space/><link><target>debugging</target></link><space/>of the original source.</paragraph><heading level='3'>Compiled versus interpreted languages</heading><paragraph>Higher-level programming languages usually appear with a type of<space/><link><target>Translator (computing)</target><part>translation</part></link><space/>in mind: either designed as<space/><link><target>compiled language</target></link><space/>or<space/><link><target>interpreted language</target></link>. However, in practice there is rarely anything about a language that<space/><italics>requires</italics><space/>it to be exclusively compiled or exclusively interpreted, although it is possible to design languages that rely on re-interpretation at run time. The categorization usually reflects the most popular or widespread implementations of a language for instance,<space/><link><target>BASIC</target></link><space/>is sometimes called an interpreted language, and C a compiled one, despite the existence of BASIC compilers and C interpreters.</paragraph><paragraph>Interpretation does not replace compilation completely. It only hides it from the user and makes it gradual. Even though an interpreter can itself be interpreted, a directly executed program is needed somewhere at the bottom of the stack (see<space/><link><target>machine language</target></link>). Modern trends toward<space/><link><target>just-in-time compilation</target></link><space/>and<space/><link><target>bytecode</target><part>bytecode interpretation</part></link><space/>at times blur the traditional categorizations of compilers and interpreters.</paragraph><paragraph>Some language specifications spell out that implementations<space/><italics>must</italics><space/>include a compilation facility; for example,<space/><link><target>Common Lisp</target></link>. However, there is nothing inherent in the definition of Common Lisp that stops it from being interpreted. Other languages have features that are very easy to implement in an interpreter, but make writing a compiler much harder; for example,<space/><link><target>APL (programming language)</target><part>APL</part></link>,<space/><link><target>SNOBOL4</target></link>, and many scripting languages allow programs to construct arbitrary source code at runtime with regular string operations, and then execute that code by passing it to a special<space/><link><target>eval</target><part>evaluation function</part></link>. To implement these features in a compiled language, programs must usually be shipped with a<space/><link><target>runtime library</target></link><space/>that includes a version of the compiler itself.</paragraph><heading level='3'>Hardware compilation</heading><paragraph>The output of some compilers may target<space/><link><target>computer hardware</target></link><space/>at a very low level, for example a<space/><link><target>Field Programmable Gate Array</target></link><space/>(FPGA) or structured<space/><link><target>Application-specific integrated circuit</target></link><space/>(ASIC).<extension extension_name='ref'><template><target>cite web</target><arg name="first">Jordan S. Swartz, Vaughn Betz, and Jonathan Rose</arg><arg name="title">A Fast Routability-Driven Router for FPGAs</arg><arg name="url">http://www.eecg.toronto.edu/~vaughn/papers/fpga98.pdf</arg><arg name="publisher">Department of Electrical and Computer Engineering, University of Toronto</arg></template></extension><space/>Such compilers are said to be<space/><italics><link><target>hardware compiler</target><trail>s</trail></link></italics><space/>or synthesis tools because the source code they compile effectively controls the final configuration of the hardware and how it operates; the output of the compilation is not instructions that are executed in sequence - only an interconnection of transistors or lookup tables.For example, XST is the Xilinx Synthesis Tool used for configuring FPGAs. Similar tools are available from Altera, Synplicity, Synopsys and other vendors.</paragraph><heading level='2'>Compiler construction</heading><paragraph><template><target>unreferenced section</target><arg name="date">September 2010</arg></template><template><target>main</target><arg>Compiler construction</arg></template>In the early days, the approach taken to compiler design used to be directly affected by the complexity of the processing, the experience of the person(s) designing it, and the resources available.</paragraph><paragraph>A compiler for a relatively simple language written by one person might be a single, monolithic piece of software. When the source language is large and complex, and high quality output is required, the design may be split into a number of relatively independent phases. Having separate phases means development can be parceled up into small parts and given to different people. It also becomes much easier to replace a single phase by an improved one, or to insert new phases later (e.g., additional optimizations).</paragraph><paragraph>The division of the compilation processes into phases was championed by the<space/><link><target>Production Quality Compiler-Compiler Project</target></link><space/>(PQCC) at<space/><link><target>Carnegie Mellon</target></link><space/>University. This project introduced the terms<space/><italics>front end</italics>,<space/><italics>middle end</italics>, and<space/><italics>back end</italics>.</paragraph><paragraph>All but the smallest of compilers have more than two phases. However, these phases are usually regarded as being part of the front end or the back end. The point at which these two<space/><italics>ends</italics><space/>meet is open to debate. The front end is generally considered to be where syntactic and semantic processing takes place, along with translation to a lower level of representation (than source code).</paragraph><paragraph>The middle end is usually designed to perform optimizations on a form other than the source code or machine code. This source code/machine code independence is intended to enable generic optimizations to be shared between versions of the compiler supporting different languages and target processors.</paragraph><paragraph>The back end takes the output from the middle. It may perform more analysis, transformations and optimizations that are for a particular computer. Then, it generates code for a particular processor and OS.</paragraph><paragraph>This front-end/middle/back-end approach makes it possible to combine front ends for different languages with back ends for different<space/><link><target>CPU</target><trail>s</trail></link>. Practical examples of this approach are the<space/><link><target>GNU Compiler Collection</target></link>,<space/><link><target>LLVM</target></link>, and the<space/><link><target>Amsterdam Compiler Kit</target></link>, which have multiple front-ends, shared analysis and multiple back-ends.</paragraph><heading level='3'>One-pass versus multi-pass compilers<template><target>anchor</target><arg>Single-pass</arg></template></heading><paragraph>Classifying compilers by number of passes has its background in the hardware resource limitations of computers. Compiling involves performing lots of work and early computers did not have enough memory to contain one program that did all of this work. So compilers were split up into smaller programs which each made a pass over the source (or some representation of it) performing some of the required analysis and translations.</paragraph><paragraph>The ability to compile in a<space/><link><target>one-pass compiler</target><part>single pass</part></link><space/>has classically been seen as a benefit because it simplifies the job of writing a compiler and one-pass compilers generally perform compilations faster than<space/><link><target>multi-pass compiler</target><trail>s</trail></link>. Thus, partly driven by the resource limitations of early systems, many early languages were specifically designed so that they could be compiled in a single pass (e.g.,<space/><link><target>Pascal (programming language)</target><part>Pascal</part></link>).</paragraph><paragraph>In some cases the design of a language feature may require a compiler to perform more than one pass over the source. For instance, consider a declaration appearing on line 20 of the source which affects the translation of a statement appearing on line 10. In this case, the first pass needs to gather information about declarations appearing after statements that they affect, with the actual translation happening during a subsequent pass.</paragraph><paragraph>The disadvantage of compiling in a single pass is that it is not possible to perform many of the sophisticated<space/><link><target>compiler optimization</target><part>optimizations</part></link><space/>needed to generate high quality code. It can be difficult to count exactly how many passes an optimizing compiler makes. For instance, different phases of optimization may analyse one expression many times but only analyse another expression once.</paragraph><paragraph>Splitting a compiler up into small programs is a technique used by researchers interested in producing provably correct compilers. Proving the correctness of a set of small programs often requires less effort than proving the correctness of a larger, single, equivalent program.</paragraph><paragraph>While the typical multi-pass compiler outputs machine code from its final pass, there are several other types:</paragraph><list type='bullet'><listitem>A &quot;<link><target>source-to-source compiler</target></link>&quot; is a type of compiler that takes a high level language as its input and outputs a high level language. For example, an<space/><link><target>Automatic parallelization</target><part>automatic parallelizing</part></link><space/>compiler will frequently take in a high level language program as an input and then transform the code and annotate it with parallel code annotations (e.g.<space/><link><target>OpenMP</target></link>) or language constructs (e.g. Fortran's<space/><xhtml:code>DOALL</xhtml:code><space/>statements).</listitem><listitem><link><target>Stage compiler</target></link><space/>that compiles to assembly language of a theoretical machine, like some<space/><link><target>Prolog</target></link><space/>implementations<list type='bullet'><listitem>This Prolog machine is also known as the<space/><link><target>Warren Abstract Machine</target></link><space/>(or WAM).</listitem><listitem>Bytecode compilers for<space/><link><target>Java (programming language)</target><part>Java</part></link>,<space/><link><target>Python language</target><part>Python</part></link>, and many more are also a subtype of this.</listitem></list></listitem><listitem><link><target>Just-in-time compilation</target><part>Just-in-time compiler</part></link>, used by Smalltalk and Java systems, and also by Microsoft .NET's<space/><link><target>Common Intermediate Language</target></link><space/>(CIL)<list type='bullet'><listitem>Applications are delivered in bytecode, which is compiled to native machine code just prior to execution.</listitem></list></listitem></list><heading level='3'>Front end</heading><paragraph><link><target>File:Xxx Scanner and parser example for C.gif</target><part>thumb</part><part>right</part><part>400px</part><part><link><target>Lexical analysis</target><part>Lexer</part></link><space/>and<space/><link><target>Parsing</target><part>parser</part></link><space/>example for<space/><link><target>C (programming language)</target><part>C</part></link>. Starting from the sequence of characters &quot;<xhtml:code>if(net&gt;0.0)total+=net*(1.0+tax/100.0);</xhtml:code>&quot;, the scanner composes a sequence of<space/><link><target>Lexical analysis#token</target><part>tokens</part></link>, and categorizes each of them, for example as<space/><template><target>color</target><arg>#600000</arg><arg>identifier</arg></template>,<space/><template><target>color</target><arg>#606000</arg><arg>reserved word</arg></template>,<space/><template><target>color</target><arg>#006000</arg><arg>number literal</arg></template>, or<space/><template><target>color</target><arg>#000060</arg><arg>operator</arg></template>. The latter sequence is transformed by the parser into a<space/><link><target>abstract syntax tree</target><part>syntax tree</part></link>, which is then treated by the remaining compiler phases. The scanner and parser handles the<space/><link><target>regular grammar</target><part>regular</part></link><space/>and properly<space/><link><target>context-free grammar</target><part>context-free</part></link><space/>parts of the<space/><link><target>C syntax#External links</target><part>grammar for C</part></link>, respectively.</part></link></paragraph><paragraph>The<space/><italics>compiler frontend</italics><space/>analyzes the source code to build an internal representation of the program, called the<space/><link><target>intermediate representation</target></link><space/>or<space/><italics>IR</italics>. It also manages the<space/><link><target>symbol table</target></link>, a data structure mapping each symbol in the source code to associated information such as location, type and scope.</paragraph><paragraph>While the frontend can be a single monolithic function or program, as in a<space/><link><target>scannerless parser</target></link>, it is more commonly implemented and analyzed as several phases, which may execute sequentially or concurrently. This is particularly done for good engineering: modularity and<space/><link><target>separation of concerns</target></link>. Most commonly today this is done as three phases: lexing, parsing, and<space/><link><target>Semantic analysis (compilers)</target><part>semantic analysis</part></link>. Lexing and parsing comprise the syntactic analysis (word syntax and phrase syntax, respectively), and in simple cases these modules (the lexer and parser) can be automatically generated from a grammar for the language, though in more complex cases these require manual modification or writing by hand. The lexical grammar and phrase grammar are usually<space/><link><target>context-free grammar</target><trail>s</trail></link>, which simplifies analysis significantly, with context-sensitivity handled at the semantic analysis phase. The semantic analysis phase is generally more complex and written by hand, but can be partially or fully automated using<space/><link><target>attribute grammar</target><trail>s</trail></link>. These phases themselves can be further broken down lexing as scanning and evaluating, parsing as first building a concrete syntax tree (CST, parse tree), and then transforming it into an abstract syntax tree (AST, syntax tree).</paragraph><paragraph>In some cases additional phases are used, notably<space/><italics>line reconstruction</italics><space/>and<space/><italics>preprocessing,</italics><space/>but these are rare. A detailed list of possible phases includes:</paragraph><list type='numbered'><listitem><italics><template><target>visible anchor</target><arg>Line reconstruction</arg></template></italics>: Languages which<space/><link><target>stropping (syntax)</target><part>strop</part></link><space/>their keywords or allow arbitrary spaces within identifiers require a phase before parsing, which converts the input character sequence to a canonical form ready for the parser. The<space/><link><target>top-down parsing</target><part>top-down</part></link>,<space/><link><target>recursive descent parser</target><part>recursive-descent</part></link>, table-driven parsers used in the 1960s typically read the source one character at a time and did not require a separate tokenizing phase.<space/><link><target>Atlas Autocode</target></link>, and<space/><link><target>Edinburgh IMP</target><part>Imp</part></link><space/>(and some implementations of<space/><link><target>ALGOL</target></link><space/>and<space/><link><target>Coral 66</target></link>) are examples of stropped languages which compilers would have a<space/><italics>Line Reconstruction</italics><space/>phase.</listitem><listitem><link><target>Lexical analysis</target></link><space/>breaks the source code text into small pieces called<space/><italics>tokens</italics>. Each token is a single atomic unit of the language, for instance a<space/><link><target>keyword (computing)</target><part>keyword</part></link>,<space/><link><target>identifier</target></link><space/>or<space/><link><target>symbol</target><part>symbol name</part></link>. The token syntax is typically a<space/><link><target>regular language</target></link>, so a<space/><link><target>finite state automaton</target></link><space/>constructed from a<space/><link><target>regular expression</target></link><space/>can be used to recognize it. This phase is also called lexing or scanning, and the software doing lexical analysis is called a<space/><link><target>lexical analyzer</target></link><space/>or scanner. This may not be a separate step it can be combined with the parsing step in<space/><link><target>scannerless parsing</target></link>, in which case parsing is done at the character level, not the token level.</listitem><listitem><link><target>Preprocessor</target><part>Preprocessing</part></link>. Some languages, e.g., C, require a preprocessing phase which supports<space/><link><target>Macro (computer science)</target><part>macro</part></link><space/>substitution and conditional compilation. Typically the preprocessing phase occurs before syntactic or semantic analysis; e.g. in the case of C, the preprocessor manipulates lexical tokens rather than syntactic forms. However, some languages such as<space/><link><target>Scheme (programming language)</target><part>Scheme</part></link><space/>support macro substitutions based on syntactic forms.</listitem><listitem><link><target>Syntax analysis</target></link><space/>involves<space/><link><target>parsing</target></link><space/>the token sequence to identify the syntactic structure of the program. This phase typically builds a<space/><link><target>parse tree</target></link>, which replaces the linear sequence of tokens with a tree structure built according to the rules of a<space/><link><target>formal grammar</target></link><space/>which define the language's syntax. The parse tree is often analyzed, augmented, and transformed by later phases in the compiler.</listitem><listitem>Semantic analysis is the phase in which the compiler adds semantic information to the<space/><link><target>parse tree</target></link><space/>and builds the symbol table. This phase performs semantic checks such as<space/><link><target>type checking</target></link><space/>(checking for type errors), or<space/><link><target>object binding</target></link><space/>(associating variable and function references with their definitions), or<space/><link><target>definite assignment analysis</target><part>definite assignment</part></link><space/>(requiring all local variables to be initialized before use), rejecting incorrect programs or issuing warnings. Semantic analysis usually requires a complete parse tree, meaning that this phase logically follows the<space/><link><target>parsing</target></link><space/>phase, and logically precedes the<space/><link><target>code generation (compiler)</target><part>code generation</part></link><space/>phase, though it is often possible to fold multiple phases into one pass over the code in a compiler implementation.</listitem></list><heading level='3'>Back end</heading><paragraph>The term<space/><italics>back end</italics><space/>is sometimes confused with<space/><italics><link><target>code generation (compiler)</target><part>code generator</part></link></italics><space/>because of the overlapped functionality of generating assembly code. Some literature uses<space/><italics>middle end</italics><space/>to distinguish the generic analysis and optimization phases in the back end from the machine-dependent code generators.</paragraph><paragraph>The main phases of the back end include the following:</paragraph><list type='numbered'><listitem><link><target>Compiler analysis</target><part>Analysis</part></link>: This is the gathering of program information from the intermediate representation derived from the input;<space/><link><target>data-flow analysis</target></link><space/>is used to build<space/><link><target>use-define chain</target><trail>s</trail></link>, together with<space/><link><target>dependence analysis</target></link>,<space/><link><target>alias analysis</target></link>,<space/><link><target>pointer analysis</target></link>,<space/><link><target>escape analysis</target></link>, etc. Accurate analysis is the basis for any compiler optimization. The<space/><link><target>call graph</target></link><space/>and<space/><link><target>control flow graph</target></link><space/>are usually also built during the analysis phase.</listitem><listitem><link><target>Compiler optimization</target><part>Optimization</part></link>: the intermediate language representation is transformed into functionally equivalent but faster (or smaller) forms. Popular optimizations are<space/><link><target>inline expansion</target></link>,<space/><link><target>dead code elimination</target></link>,<space/><link><target>constant propagation</target></link>,<space/><link><target>loop transformation</target></link>,<space/><link><target>register allocation</target></link><space/>and even<space/><link><target>automatic parallelization</target></link>.</listitem><listitem><link><target>Code generation (compiler)</target><part>Code generation</part></link>: the transformed intermediate language is translated into the output language, usually the native<space/><link><target>machine language</target></link><space/>of the system. This involves resource and storage decisions, such as deciding which variables to fit into registers and memory and the selection and scheduling of appropriate machine instructions along with their associated addressing modes (see also<space/><link><target>Sethi-Ullman algorithm</target></link>). Debug data may also need to be generated to facilitate<space/><link><target>debugging</target></link>.</listitem></list><paragraph>Compiler analysis is the prerequisite for any compiler optimization, and they tightly work together. For example,<space/><link><target>dependence analysis</target></link><space/>is crucial for<space/><link><target>loop transformation</target></link>.</paragraph><paragraph>In addition, the scope of compiler analysis and optimizations vary greatly, from as small as a<space/><link><target>basic block</target></link><space/>to the procedure/function level, or even over the whole program (<link><target>interprocedural optimization</target></link>). Obviously, a compiler can potentially do a better job using a broader view. But that broad view is not free: large scope analysis and optimizations are very costly in terms of compilation time and memory space; this is especially true for interprocedural analysis and optimizations.</paragraph><paragraph>Interprocedural analysis and optimizations are common in modern commercial compilers from<space/><link><target>Hewlett-Packard</target><part>HP</part></link>,<space/><link><target>IBM</target></link>,<space/><link><target>Silicon Graphics</target><part>SGI</part></link>,<space/><link><target>Intel</target></link>,<space/><link><target>Microsoft</target></link>, and<space/><link><target>Sun Microsystems</target></link>. The open source<space/><link><target>GNU Compiler Collection</target><part>GCC</part></link><space/>was criticized for a long time for lacking powerful interprocedural optimizations, but it is changing in this respect. Another open source compiler with full analysis and optimization infrastructure is<space/><link><target>Open64</target></link>, which is used by many organizations for research and commercial purposes.</paragraph><paragraph>Due to the extra time and space needed for compiler analysis and optimizations, some compilers skip them by default. Users have to use compilation options to explicitly tell the compiler which optimizations should be enabled.</paragraph><heading level='2'>Compiler correctness</heading><paragraph><template><target>Main</target><arg>Compiler correctness</arg></template><link><target>Compiler correctness</target></link><space/>is the branch of software engineering that deals with trying to show that a compiler behaves according to its<space/><link><target>programming language</target><part>language specification</part></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="last">Chlipala</arg><arg name="first">Adam</arg><arg name="title">Syntactic Proofs of Compositional Compiler Correctness</arg><arg name="url">http://adam.chlipala.net/tmp/compose.pdf</arg><arg name="publisher">Harvard University Cambridge, Massachusetts, USA</arg></template></extension><space/>Techniques include developing the compiler using<space/><link><target>formal methods</target></link><space/>and using rigorous testing (often called compiler validation) on an existing compiler.</paragraph><heading level='2'>Related techniques</heading><paragraph><template><target>merge from</target><arg>Translator (computing)</arg><arg name="discuss">Talk:Compiler#Merger proposal</arg><arg name="date">July 2014</arg><arg name="section">yes</arg></template></paragraph><paragraph><link><target>Assembly language</target></link><space/>is a type of low-level language and a program that compiles it is more commonly known as an<space/><italics>assembler</italics>, with the inverse program known as a<space/><link><target>disassembler</target></link>.</paragraph><paragraph>A program that translates from a low level language to a higher level one is a<space/><link><target>decompiler</target></link>.</paragraph><paragraph>A program that translates between high-level languages is usually called a language translator,<space/><link><target>source to source translator</target></link>, language converter, or language<space/><link><target>Rewriting</target><part>rewriter</part></link>. The last term is usually applied to translations that do not involve a change of language.</paragraph><paragraph>A program that translates into an object code format that is not supported on the compilation machine is called a<space/><link><target>cross compiler</target></link><space/>and is commonly used to prepare code for embedded applications.</paragraph><heading level='2'>International conferences and organizations</heading><preblock><preline>A number of conferences in the field of<space/><link><target>programming languages</target></link><space/>present advances in compiler construction as one of their main topics.</preline></preblock><paragraph><link><target>Association for Computing Machinery</target><part>ACM</part></link><space/><link><target>SIGPLAN</target></link><space/>supports a number of conferences, including:</paragraph><list type='bullet'><listitem><link><target>Programming Language Design and Implementation</target></link><space/>(PLDI)</listitem><listitem><link><target>POPL</target><part>Principles of Programming Languages</part></link><space/>(POPL)</listitem><listitem><link><target>OOPSLA</target><part>Object-Oriented Programming, Systems, Languages, and Applications</part></link><space/>(OOPSLA)</listitem><listitem><link><target>International Conference on Functional Programming</target></link><space/>(ICFP)</listitem></list><paragraph>The European Joint Conferences on Theory and Practice of Software (<link><target>ETAPS</target></link>) sponsors the International Conference on Compiler Construction, with papers from both the academic and industrial sectors.<extension extension_name='ref'><link type='external' href='http://www.etaps.org/'>ETAPS</link><space/>- European Joint Conferences on Theory and Practice of Software. Cf. &quot;CC&quot; (Compiler Construction) subsection.</extension></paragraph><paragraph>Asian Symposium on Programming Languages and Systems (APLAS) is organized by the Asian Association for Foundation of Software (AAFS).</paragraph><heading level='2'>See also</heading><paragraph><template><target>Too many see alsos</target><arg name="date">July 2014</arg></template><template><target>Wikipedia books</target><arg>Compiler construction</arg></template></paragraph><paragraph><template><target>Div col</target><arg></arg><arg>20em</arg></template></paragraph><list type='bullet'><listitem><link><target>Abstract interpretation</target></link></listitem><listitem><link><target>Attribute grammar</target></link></listitem><listitem><link><target>Binary recompiler</target></link></listitem><listitem><link><target>Bottom-up parsing</target></link></listitem><listitem><link><target>Byzantine fault tolerance</target></link></listitem><listitem><link><target>Compile and go loader</target></link></listitem><listitem><link><target>Compile farm</target></link></listitem><listitem><link><target>List of compilers</target></link></listitem><listitem><link><target>List of important publications in computer science#Compilers</target></link></listitem><listitem><link><target>Metacompilation</target></link></listitem><listitem><link><target>Overhead code</target></link></listitem><listitem><link><target>Semantics encoding</target></link></listitem><listitem><link><target>Transcompiler</target></link></listitem></list><paragraph><template><target>Div col end</target></template></paragraph><heading level='2'>Notes</heading><paragraph><template><target>reflist</target><arg>30em</arg></template></paragraph><heading level='2'>References</heading><paragraph><template><target>refbegin</target><arg>30em</arg></template></paragraph><list type='numbered'><listitem><link type='external' href='http://www.informatik.uni-trier.de/~ley/db/books/compiler/index.html'>Compiler textbook references</link><space/>A collection of references to mainstream Compiler Construction Textbooks<template><target>dead link</target><arg name="date">January 2014</arg></template></listitem><listitem><template><target>Cite book</target><arg name="authorlink1">Alfred V. Aho<space/></arg><arg name="last1">Aho<space/></arg><arg name="first1">Alfred V.<space/></arg><arg name="authorlink2"><space/>Ravi Sethi<space/></arg><arg name="last2">Sethi<space/></arg><arg name="first2">Ravi<space/></arg><arg name="authorlink3">Jeffrey D. Ullman<space/></arg><arg name="last3">Ullman<space/></arg><arg name="first3">Jeffrey D.<space/></arg><arg name="title">[[Compilers: Principles, Techniques, and Tools]]<space/></arg><arg name="isbn">9780201100884<space/></arg><arg name="publisher">[[Addison-Wesley]]<space/></arg><arg name="year">1986<space/></arg><arg name="edition">1st</arg></template></listitem><listitem><template><target>Cite journal</target><arg name="authorlink">Frances E. Allen<space/></arg><arg name="last1">Allen<space/></arg><arg name="first1">Frances E.<space/></arg><arg name="url">http://www.research.ibm.com/journal/rd/255/ibmrd2505Q.pdf<space/></arg><arg name="title">A History of Language Processor Technology in IBM<space/></arg><arg name="work">IBM Journal of Research and Development<space/></arg><arg name="volume">25<space/></arg><arg name="number">5<space/></arg><arg name="date">September 1981<space/></arg><arg name="publisher">[[IBM]]<space/></arg><arg name="subscription">yes</arg><arg name="doi"><space/>10.1147/rd.255.0535<space/></arg></template></listitem><listitem><template><target>Cite book</target><arg name="last1">Allen<space/></arg><arg name="first1">Randy<space/></arg><arg name="authorlink2">Ken Kennedy (computer scientist)<space/></arg><arg name="last2">Kennedy<space/></arg><arg name="first2">Ken<space/></arg><arg name="title">Optimizing Compilers for Modern Architectures<space/></arg><arg name="publisher">[[Morgan Kaufmann Publishers]]<space/></arg><arg name="year">2001<space/></arg><arg name="isbn">1-55860-286-0</arg></template></listitem><listitem><template><target>Cite book</target><arg name="authorlink">Andrew Appel<space/></arg><arg name="last1">Appel<space/></arg><arg name="first1">Andrew Wilson<space/></arg><arg name="title">Modern Compiler Implementation in Java<space/></arg><arg name="edition">2nd<space/></arg><arg name="publisher">[[Cambridge University Press]]<space/></arg><arg name="year">2002<space/></arg><arg name="isbn">0-521-82060-X</arg></template></listitem><listitem><template><target>Cite book</target><arg name="authorlink">Andrew Appel<space/></arg><arg name="last1">Appel<space/></arg><arg name="first1">Andrew Wilson<space/></arg><arg name="url">http://books.google.com/books?id</arg><arg name="title">Modern Compiler Implementation in ML<space/></arg><arg name="publisher">[[Cambridge University Press]]<space/></arg><arg name="year">1998<space/></arg><arg name="isbn">0-521-58274-1</arg></template></listitem><listitem><template><target>cite book</target><arg name="last">Bornat</arg><arg name="first">Richard</arg><arg name="title">Understanding and Writing Compilers: A Do It Yourself Guide</arg><arg name="year">1979</arg><arg name="publisher">[[Macmillan Publishing]]</arg><arg name="isbn">0-333-21732-2</arg><arg name="url">http://www.cs.mdx.ac.uk/staffpages/r_bornat/books/compiling.pdf</arg><arg name="authorlink">Richard Bornat</arg></template></listitem><listitem><template><target>cite book</target><arg name="title">Engineering a Compiler<space/></arg><arg name="publisher">[[Morgan Kaufmann]]<space/></arg><arg name="year">2004<space/></arg><arg name="isbn">1-55860-699-8<space/></arg><arg name="first1">Keith D.<space/></arg><arg name="last1">Cooper<space/></arg><arg name="first2">Linda<space/></arg><arg name="last2">Torczon</arg></template></listitem><listitem><template><target>Cite journal</target><arg name="first1">Bruce W.<space/></arg><arg name="last1">Leverett<space/></arg><arg name="first2">R. G. G.<space/></arg><arg name="last2">Cattell<space/></arg><arg name="first3">Joseph M.<space/></arg><arg name="last3">Newcomer<space/></arg><arg name="last4">Hobbs<space/></arg><arg name="first4">S.O.<space/></arg><arg name="last5">Reiner<space/></arg><arg name="first5">A.H.<space/></arg><arg name="last6">Schatz<space/></arg><arg name="first6">B.R.<space/></arg><arg name="last7">Wulf<space/></arg><arg name="first7">W.A.<space/></arg><arg name="title">An Overview of the Production  Quality Compiler  Compiler Project<space/></arg><arg name="work">[[Computer (magazine)|Computer]]<space/></arg><arg name="publisher">[[Carnegie-Mellon University]]<space/></arg><arg name="volume">13<space/></arg><arg name="issue">8<space/></arg><arg name="pages">3849<space/></arg><arg name="date">August 1980<space/></arg><arg name="issn">0018-9162<space/></arg><arg name="doi">10.1109/MC.1980.1653748<space/></arg><arg name="subscription">yes</arg></template></listitem><listitem><template><target>Cite book</target><arg name="last1">McKeeman<space/></arg><arg name="first1">William Marshall<space/></arg><arg name="authorlink2">Jim Horning<space/></arg><arg name="last2">Horning<space/></arg><arg name="first2">James J.<space/></arg><arg name="last3">Wortman<space/></arg><arg name="first3">David B.<space/></arg><arg name="url">http://www.cs.toronto.edu/XPL/<space/></arg><arg name="title">A Compiler Generator<space/></arg><arg name="location">[[Englewood Cliffs, NJ]]<space/></arg><arg name="publisher">[[Prentice-Hall]]<space/></arg><arg name="year">1970<space/></arg><arg name="isbn">0-13-155077-2</arg></template></listitem><listitem><template><target>Cite book</target><arg name="authorlink">Steven Muchnick<space/></arg><arg name="last1">Muchnick<space/></arg><arg name="first1">Steven<space/></arg><arg name="url">http://books.google.com/books?id</arg><arg name="title">Advanced Compiler Design and Implementation<space/></arg><arg name="publisher">[[Morgan Kaufmann Publishers]]<space/></arg><arg name="year">1997<space/></arg><arg name="isbn">1-55860-320-4</arg></template></listitem><listitem><template><target>cite book</target><arg name="authorlink">Michael L. Scott<space/></arg><arg name="last1">Scott<space/></arg><arg name="first1">Michael Lee<space/></arg><arg name="url">http://books.google.com/books?id</arg><arg name="title">Programming Language Pragmatics<space/></arg><arg name="publisher">[[Morgan Kaufmann]]<space/></arg><arg name="year">2005<space/></arg><arg name="edition">2nd<space/></arg><arg name="isbn">0-12-633951-1</arg></template></listitem><listitem><template><target>Cite book</target><arg name="last">Srikant<space/></arg><arg name="first">Y. N.<space/></arg><arg name="last2">Shankar<space/></arg><arg name="first2">Priti<space/></arg><arg name="url">http://books.google.com/books?id</arg><arg name="title">The Compiler Design Handbook: Optimizations and Machine Code Generation<space/></arg><arg name="publisher">[[CRC Press]]<space/></arg><arg name="year">2003<space/></arg><arg name="isbn">0-8493-1240-X</arg></template></listitem><listitem><template><target>Cite book</target><arg name="last1">Terry<space/></arg><arg name="first1">Patrick D.<space/></arg><arg name="url">http://scifac.ru.ac.za/compilers/conts.htm<space/></arg><arg name="title">Compilers and Compiler Generators: An Introduction with C++<space/></arg><arg name="publisher">International Thomson Computer Press<space/></arg><arg name="year">1997<space/></arg><arg name="isbn">1-85032-298-8</arg></template></listitem><listitem><template><target>Cite book</target><arg name="authorlink1">Niklaus Wirth<space/></arg><arg name="last1">Wirth<space/></arg><arg name="first1">Niklaus url</arg><arg name="title">Compiler Construction<space/></arg><arg name="isbn">0-201-40353-6<space/></arg><arg name="publisher">[[Addison-Wesley]]<space/></arg><arg name="year">1996</arg></template></listitem></list><paragraph><template><target>refend</target></template></paragraph><heading level='2'>External links</heading><paragraph><template><target>Wiktionary</target><arg>compiler</arg></template><template><target>Wikibooks</target><arg>Compiler Construction</arg></template></paragraph><list type='bullet'><listitem><template><target>dmoz</target><arg>Computers/Programming/Compilers/</arg><arg>Compilers</arg></template></listitem><listitem><link type='external' href='http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf'>Incremental Approach to Compiler Construction</link><template><target>snd</target></template><space/>a PDF Tutorial</listitem><listitem><link type='external' href='http://la-samhna.de/library/compile/index.html'>Compile-Howto</link></listitem><listitem><italics><link type='external' href='http://www.diku.dk/hjemmesider/ansatte/torbenm/Basics/'>Basics of Compiler Design</link></italics><space/>by Torben gidius Mogensen</listitem><listitem><template><target>YouTube</target><arg>_C5AHaS1mOA</arg><arg>Short animation</arg></template><space/>explaining the key conceptual difference between compilers and interpreters</listitem><listitem><template><target>YouTube</target><arg name="id">QPCC2sbukeo</arg><arg name="title">Syntax Analysis & LL1 Parsing</arg></template></listitem><listitem><link type='external' href='http://compilers.iecc.com/crenshaw/'>Let's Build a Compiler</link>, by Jack Crenshaw</listitem><listitem><link type='external' href='http://www.compdev.net'>Forum about compiler development</link></listitem></list><paragraph><template><target>Authority control</target></template><link><target>Category:American inventions</target></link><link><target>Category:Compilers</target><part></part></link><link><target>Category:Compiler construction</target></link><link><target>Category:Computer libraries</target></link><link><target>Category:Programming language implementation</target></link><link><target>Category:Utility software types</target></link></paragraph></article>