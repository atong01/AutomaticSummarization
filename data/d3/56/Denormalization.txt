{{Refimprove|type=Computing|date=May 2008}}
In [[computing]], '''denormalization''' is the process of attempting to optimize the read performance of a [[database]] by adding redundant data or by grouping data.<ref>G. L. Sanders and S. K. Shin. [http://www.hicss.hawaii.edu/HICSS_34/PDFs/DTDMK04.pdf Denormalization effects on performance of RDBMS]. In Proceedings of the HICSS Conference, January 2001.</ref><ref>S. K. Shin and G. L. Sanders. [http://portal.acm.org/citation.cfm?id=1217757 Denormalization strategies for data retrieval from data warehouses]. Decision Support Systems, 42(1):267-282, October 2006.</ref>  In some cases, denormalization is a means of addressing [[Computer performance|performance]] or [[scalability]] in [[relational model|relational]] [[DBMS|database software]].

A [[Database normalization|normalized]] design will often store different but related pieces of information in separate logical tables (called relations).  If these relations are stored physically as separate disk files, completing a database [[Information retrieval|query]] that draws information from several relations (a ''[[Join (SQL)|join operation]]'') can be slow.  If many relations are joined, it may be prohibitively slow. There are two strategies for dealing with this. The preferred method is to keep the logical design normalized, but allow the [[database management system]] (DBMS) to store additional redundant information on disk to optimise query response. In this case it is the DBMS software's responsibility to ensure that any redundant copies are kept consistent.  This method is often implemented in [[SQL]] as indexed views ([[Microsoft SQL Server]]) or [[materialised view]]s ([[Oracle Database|Oracle]], [[PostgreSQL]]).  A view represents information in a format convenient for querying, and the index ensures that queries against the view are optimised.

The more common approach is to denormalize the logical data design.  With care this can achieve a similar improvement in query response, but at a costâ€”it is now the database designer's responsibility to ensure that the denormalized database does not become inconsistent.  This is done by creating rules in the database called ''[[Constraint satisfaction|constraints]]'', that specify how the redundant copies of information must be kept synchronised.  It is the increase in logical [[Complexity of constraint satisfaction|complexity]] of the database design and the added complexity of the additional constraints that make this approach hazardous. Moreover, constraints introduce a [[trade-off]], speeding up reads (<code>SELECT</code> in SQL) while slowing down writes (<code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>). This means a denormalized database under heavy write load may actually offer ''worse'' performance than its functionally equivalent normalized counterpart.

A denormalized data model is not the same as a data model that has not been normalized, and denormalization should only take place after a satisfactory level of normalization has taken place and that any required constraints and/or rules have been created to deal with the inherent anomalies in the design. For example, all the relations are in [[third normal form]] and any relations with join and multi-valued dependencies are handled appropriately.

Examples of denormalization techniques include:
* [[Materialised view]]s, which may implement the following:
** Storing the count of the "many" objects in a one-to-many relationship as an attribute of the "one" relation
** Adding attributes to a relation from another relation with which it will be joined
* [[Star schema]]s, which are also known as fact-dimension models and have been extended to [[snowflake schema]]s
* Prebuilt summarisation or [[OLAP cube]]s

Denormalization techniques are often used to improve the scalability of Web applications.<ref>Z. Wei, J. Dejun, G. Pierre, C.-H. Chi and M. van Steen. [http://www.globule.org/publi/SODDSWA_www2008.html Service-Oriented Data Denormalization for Scalable Web Applications]. In Proceedings of the International World-Wide Web conference, April 2008.</ref>

==References==
{{Reflist}}

==See also==
*[[Cache (computing)]]
*[[Scalability]]

{{Database normalization}}