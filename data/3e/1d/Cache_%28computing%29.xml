<article title='Cache_%28computing%29'><paragraph><template><target>About</target><arg>the computing optimization concept</arg><arg>other uses in the field of computing</arg><arg>Cache (disambiguation)#Computing{{!}}Cache (disambiguation) § Computing</arg></template><template><target>Use dmy dates</target><arg name="date">April 2012</arg></template><template><target>Refimprove</target><arg name="date">April 2011</arg></template></paragraph><paragraph><link><target>File:cache,basic.svg</target><part>frame</part><part>Diagram of a CPU memory cache operation</part></link></paragraph><paragraph>In<space/><link><target>computing</target></link>, a<space/><bold>cache</bold><space/>(<template><target>IPAc-en</target><arg>ˈ</arg><arg>k</arg><arg>æ</arg><arg>ʃ</arg></template><space/><template><target>respell</target><arg>KASH</arg><arg>'</arg></template>,<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.merriam-webster.com/dictionary/cache
</arg><arg name="title">Cache
</arg><arg name="publisher">Merriam-Webster, Incorporated
</arg><arg name="work">Merriam-Webster Online Dictionary
</arg><arg name="accessdate">2 May 2011</arg></template></extension><space/>or<space/><template><target>IPAc-en</target><arg>ˈ</arg><arg>k</arg><arg>eɪ</arg><arg>ʃ</arg></template><space/><template><target>respell</target><arg>KAYSH</arg><arg>'</arg></template><space/>in<space/><link><target>Australian English</target><part>AuE</part></link><extension extension_name='ref'><template><target>cite web</target><arg name="url">https://www.macquariedictionary.com.au/features/word/search/?word</arg><arg name="title">Cache
</arg><arg name="publisher">Macmillan Publishers Group Australia 2015
</arg><arg name="work">Macquarie Dictionary
</arg><arg name="accessdate">21 July 2015</arg></template></extension>) is a component that stores data so future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation, or the duplicate of data stored elsewhere. A<space/><italics>cache hit</italics><space/>occurs when the requested data can be found in a cache, while a<space/><italics>cache miss</italics><space/>occurs when it cannot. Cache hits are served by reading data from the cache, which is faster than recomputing a result or reading from a slower data store; thus, the more requests can be served from the cache, the faster the system performs.</paragraph><paragraph>To be cost-effective and to enable efficient use of data, caches are relatively small. Nevertheless, caches have proven themselves in many areas of computing because access patterns in typical<space/><link><target>Application software</target><part>computer applications</part></link><space/>exhibit the<space/><link><target>locality of reference</target></link>. Moreover, access patterns exhibit<space/><link><target>Memory locality</target><part>temporal locality</part></link><space/>if data is requested again that has been recently requested already, while<space/><link><target>Memory locality</target><part>spatial locality</part></link><space/>refers to requests for data physically stored close to data that has been already requested.</paragraph><heading level='2'><template><target>Anchor</target><arg>CACHE-HIT</arg></template>Operation</heading><paragraph>Hardware implements cache as a<space/><link><target>block (data storage)</target><part>block</part></link><space/>of memory for temporary storage of data likely to be used again.<space/><link><target>Central processing unit</target><trail>s</trail></link><space/>(CPUs) and<space/><link><target>hard disk drive</target><trail>s</trail></link><space/>(HDDs) frequently use a cache, as do web browsers and web servers.</paragraph><paragraph>A cache is made up of a pool of entries. Each entry has associated data, which is a copy of the same data in some<space/><italics>backing store</italics>. Each entry also has a tag, which specifies the identity of the data in the backing store of which the entry is a copy.</paragraph><paragraph>When the cache client (a CPU, web browser,<space/><link><target>operating system</target></link>) needs to access data presumed to exist in the backing store, it first checks the cache. If an entry can be found with a tag matching that of the desired data, the data in the entry is used instead. This situation is known as a<space/><bold>cache hit</bold>. So, for example, a web browser program might check its local cache on disk to see if it has a local copy of the contents of a web page at a particular URL. In this example, the URL is the tag, and the contents of the web page is the data. The percentage of accesses that result in cache hits is known as the<space/><bold>hit rate</bold><space/>or<space/><bold>hit ratio</bold><space/>of the cache.</paragraph><paragraph>The alternative situation, when the cache is consulted and found not to contain data with the desired tag, has become known as a<space/><bold>cache miss</bold>. The previously uncached data fetched from the backing store during miss handling is usually copied into the cache, ready for the next access.</paragraph><paragraph>During a cache miss, the CPU usually ejects some other entry in order to make room for the previously uncached data. The<space/><link><target>Heuristic (computer science)</target><part>heuristic</part></link><space/>used to select the entry to eject is known as the<space/><link><target>Cache algorithm</target><part>replacement policy</part></link>. One popular replacement policy, &quot;least recently used&quot; (LRU), replaces the least recently used entry (see<space/><link><target>cache algorithm</target></link>). More efficient caches compute use frequency against the size of the stored contents, as well as the<space/><link><target>Access time</target><part>latencies</part></link><space/>and throughputs for both the cache and the backing store. This works well for larger amounts of data, longer latencies and slower throughputs, such as experienced with a hard drive and the Internet, but is not efficient for use with a CPU cache.<template><target>Citation needed</target><arg name="date">May 2007</arg></template></paragraph><heading level='3'><template><target>Anchor</target><arg>Dirty</arg><arg>WRITEPOLICIES</arg><arg>WRITE-BACK</arg><arg>WRITE-BEHIND</arg><arg>WRITE-THROUGH</arg><arg>WRITE-AROUND</arg></template>Writing policies</heading><paragraph><link><target>File:Write-through with no-write-allocation.svg</target><part>thumb</part><part>right</part><part>A write-through cache with no-write allocation</part></link><link><target>File:Write-back with write-allocation.svg</target><part>thumb</part><part>right</part><part>A write-back cache with write allocation</part></link></paragraph><paragraph>When a system writes data to cache, it must at some point write that data to the backing store as well. The timing of this write is controlled by what is known as the<space/><italics>write policy</italics>.</paragraph><paragraph>There are two basic writing approaches:</paragraph><list type='bullet'><listitem><italics>Write-through</italics>: write is done synchronously both to the cache and to the backing store.</listitem><listitem><italics>Write-back</italics><space/>(or<space/><italics>write-behind</italics>): initially, writing is done only to the cache. The write to the backing store is postponed until the cache blocks containing the data are about to be modified/replaced by new content.</listitem></list><paragraph>A write-back cache is more complex to implement, since it needs to track which of its locations have been written over, and mark them as<space/><italics>dirty</italics><space/>for later writing to the backing store. The data in these locations are written back to the backing store only when they are evicted from the cache, an effect referred to as a<space/><italics>lazy write</italics>. For this reason, a read miss in a write-back cache (which requires a block to be replaced by another) will often require two memory accesses to service: one to write the replaced data from the cache back to the store, and then one to retrieve the needed data.</paragraph><paragraph>Other policies may also trigger data write-back. The client may make many changes to data in the cache, and then explicitly notify the cache to write back the data.</paragraph><paragraph>No data is returned on write operations, thus there are two approaches for situations of write-misses:</paragraph><list type='bullet'><listitem><italics>Write allocate</italics><space/>(also called<space/><italics>fetch on write</italics>): data at the missed-write location is loaded to cache, followed by a write-hit operation. In this approach, write misses are similar to read misses.</listitem><listitem><italics>No-write allocate</italics><space/>(also called<space/><italics>write-no-allocate</italics><space/>or<space/><italics>write around</italics>): data at the missed-write location is not loaded to cache, and is written directly to the backing store. In this approach, only the reads are being cached.</listitem></list><paragraph>Both write-through and write-back policies can use either of these write-miss policies, but usually they are paired in this way:<extension extension_name='ref' name="HennessyPatterson2011"><template><target>cite book</target><arg name="author1">John L. Hennessy
</arg><arg name="author2">David A. Patterson
</arg><arg name="title">Computer Architecture: A Quantitative Approach
</arg><arg name="url">http://books.google.com/books?id</arg><arg name="accessdate">25 March 2012
</arg><arg name="date">16 September 2011
</arg><arg name="publisher">Elsevier
</arg><arg name="isbn">978-0-12-383872-8
</arg><arg name="pages">B–12</arg></template></extension></paragraph><list type='bullet'><listitem>A write-back cache uses write allocate, hoping for subsequent writes (or even reads) to the same location, which is now cached.</listitem><listitem>A write-through cache uses no-write allocate. Here, subsequent writes have no advantage, since they still need to be written directly to the backing store.</listitem></list><paragraph>Entities other than the cache may change the data in the backing store, in which case the copy in the cache may become out-of-date or<space/><italics>stale</italics>. Alternatively, when the client updates the data in the cache, copies of those data in other caches will become stale. Communication protocols between the cache managers which keep the data consistent are known as<space/><link><target>cache coherency</target><part>coherency protocols</part></link>.</paragraph><heading level='2'>Applications</heading><heading level='3'>CPU cache</heading><paragraph><template><target>Main</target><arg>CPU cache</arg></template></paragraph><paragraph>Small memories on or close to the<space/><link><target>CPU</target></link><space/>can operate faster than the much larger<space/><link><target>main memory</target></link>. Most CPUs since the 1980s have used one or more caches, and modern high-end embedded, desktop and server<space/><link><target>microprocessor</target><trail>s</trail></link><space/>may have as many as six, each specialized for a specific function. Examples of caches with a specific function are the D-cache and I-cache (data cache and instruction cache).</paragraph><heading level='3'><template><target>Anchor</target><arg>GPU</arg></template>GPU cache</heading><paragraph>Earlier<space/><link><target>graphics processing unit</target><trail>s</trail></link><space/>(GPUs) did not feature hardware-managed caches; however, as GPUs moved toward general-purpose computing (<link><target>GPGPU</target></link>), they have introduced and used progressively larger caches.<extension extension_name='ref' name="ReferenceGCS7">S. Mittal, &quot;<link type='external' href='https://www.academia.edu/6940614/A_Survey_of_Techniques_for_Managing_and_Leveraging_Caches_in_GPUs'>A Survey of Techniques for Managing and Leveraging Caches in GPUs</link>&quot;, JCSC, 23(8), 2014.</extension><space/>For example,<space/><link><target>GeForce 200 series</target><part>GT200</part></link><space/>architecture GPUs did not feature an L2 cache, while the<space/><link><target>Fermi (microarchitecture)</target><part>Fermi</part></link><space/>GPU has 768&amp;nbsp;KB of last-level cache, the<space/><link><target>Kepler (microarchitecture)</target><part>Kepler</part></link><space/>GPU has 1536&amp;nbsp;KB of last-level cache,<extension extension_name='ref' name="ReferenceGCS7"></extension><space/>and the<space/><link><target>Maxwell (microarchitecture)</target><part>Maxwell</part></link><space/>GPU has 2048&amp;nbsp;KB of last-level cache.</paragraph><heading level='3'>Translation lookaside buffer</heading><paragraph><template><target>Main</target><arg>Translation lookaside buffer</arg></template></paragraph><paragraph>A<space/><link><target>memory management unit</target></link><space/>(MMU) that fetches page table entries from main memory has a specialized cache, used for recording the results of<space/><link><target>virtual address</target></link><space/>to<space/><link><target>physical address</target></link><space/>translations. This specialized cache is called a<space/><link><target>translation lookaside buffer</target></link><space/>(TLB).<extension extension_name='ref'><template><target>cite web</target><arg name="url"><space/>http://cseweb.ucsd.edu/classes/su09/cse120/lectures/Lecture7.pdf
<space/></arg><arg name="title"><space/>Lecture 7: Memory Management
<space/></arg><arg name="work"><space/>CSE 120: Principles of Operating Systems
<space/></arg><arg name="year"><space/>2009<space/></arg><arg name="accessdate"><space/>2013-12-04
<space/></arg><arg name="author"><space/>Frank Uyeda<space/></arg><arg name="publisher"><space/>UC San Diego
<space/></arg><arg name="format"><space/>PDF
</arg></template></extension></paragraph><heading level='3'>Disk cache</heading><paragraph><template><target>Main</target><arg>Page cache</arg></template></paragraph><paragraph>While CPU caches are generally managed entirely by hardware, a variety of software manages other caches. The<space/><link><target>page cache</target></link><space/>in main memory, which is an example of disk cache, is managed by the operating system<space/><link><target>Kernel (computing)</target><part>kernel</part></link>.</paragraph><paragraph>While the<space/><link><target>disk buffer</target></link>, which is an integrated part of the hard disk drive, is sometimes misleadingly referred to as &quot;disk cache&quot;, its main functions are write sequencing and read prefetching. Repeated cache hits are relatively rare, due to the small size of the buffer in comparison to the drive's capacity. However, high-end<space/><link><target>disk controller</target><trail>s</trail></link><space/>often have their own on-board cache of the hard disk drive's<space/><link><target>Block (data storage)</target><part>data blocks</part></link>.</paragraph><paragraph>Finally, a fast local hard disk drive can also cache information held on even slower data storage devices, such as remote servers (<link><target>web cache</target></link>) or local<space/><link><target>tape drive</target><trail>s</trail></link><space/>or<space/><link><target>optical jukebox</target><trail>es</trail></link>; such a scheme is the main concept of<space/><link><target>hierarchical storage management</target></link>. Also, fast flash-based<space/><link><target>solid-state drive</target><trail>s</trail></link><space/>(SSDs) can be used as caches for slower rotational-media hard disk drives, working together as<space/><link><target>hybrid drive</target><trail>s</trail></link><space/>or<space/><link><target>solid-state hybrid drive</target><trail>s</trail></link><space/>(SSHDs).</paragraph><heading level='3'>Web cache</heading><paragraph><template><target>Main</target><arg>Web cache</arg></template></paragraph><paragraph><link><target>Web browser</target><trail>s</trail></link><space/>and<space/><link><target>Proxy server</target><part>web proxy servers</part></link><space/>employ web caches to store previous responses from<space/><link><target>web server</target><trail>s</trail></link>, such as<space/><link><target>web page</target><trail>s</trail></link><space/>and<space/><link><target>image</target><trail>s</trail></link>. Web caches reduce the amount of information that needs to be transmitted across the network, as information previously stored in the cache can often be re-used. This reduces bandwidth and processing requirements of the web server, and helps to improve<space/><link><target>responsiveness</target></link><space/>for users of the web.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://docforge.com/wiki/Web_application/Caching<space/></arg><arg name="title">Web application caching<space/></arg><arg name="author">Multiple (wiki)<space/></arg><arg name="work">Docforge<space/></arg><arg name="accessdate">2013-07-24<space/></arg></template></extension></paragraph><paragraph>Web browsers employ a built-in web cache, but some<space/><link><target>Internet Service Provider</target><part>internet service providers</part></link><space/>or organizations also use a caching proxy server, which is a web cache that is shared among all users of that network.</paragraph><paragraph>Another form of cache is<space/><link><target>P2P caching</target></link>, where the files most sought for by<space/><link><target>peer-to-peer</target></link><space/>applications are stored in an<space/><link><target>ISP</target></link><space/>cache to accelerate P2P transfers. Similarly, decentralised equivalents exist, which allow communities to perform the same task for P2P traffic, for example, Corelli.<extension extension_name='ref'>Gareth Tyson, Andreas Mauthe, Sebastian Kaune, Mu Mu and Thomas Plagemann. Corelli: A Dynamic Replication Service for Supporting Latency-Dependent Content in Community Networks. In Proc. MMCN'09<space/><link type='external' href='http://comp.eprints.lancs.ac.uk/2044/1/MMCN09.pdf'></link></extension></paragraph><heading level='3'>Memoization</heading><paragraph><template><target>Main</target><arg>Memoization</arg></template></paragraph><paragraph>A cache can store data that is computed on demand rather than retrieved from a backing store.<space/><link><target>Memoization</target></link><space/>is an<space/><link><target>Program optimization</target><part>optimization</part></link><space/>technique that stores the results of resource-consuming<space/><link><target>function call</target><trail>s</trail></link><space/>within a lookup table, allowing subsequent calls to reuse the stored results and avoid repeated computation.</paragraph><heading level='3'>Other caches</heading><paragraph>The BIND<space/><link><target>Domain Name System</target><part>DNS</part></link><space/>daemon caches a mapping of domain names to<space/><link><target>IP address</target><trail>es</trail></link>, as does a resolver library.</paragraph><paragraph>Write-through operation is common when operating over unreliable networks (like an Ethernet LAN), because of the enormous complexity of the<space/><link><target>cache coherency</target><part>coherency protocol</part></link><space/>required between multiple write-back caches when communication is unreliable. For instance, web page caches and<space/><link><target>client-side</target></link><space/><link><target>Network File System</target><part>network file system</part></link><space/>caches (like those in<space/><link><target>Network File System (protocol)</target><part>NFS</part></link><space/>or<space/><link><target>Server Message Block</target><part>SMB</part></link>) are typically read-only or write-through specifically to keep the network protocol simple and reliable.</paragraph><paragraph><link><target>Web search engine</target><part>Search engine</part><trail>s</trail></link><space/>also frequently make<space/><link><target>web page</target><trail>s</trail></link><space/>they have indexed available from their cache. For example,<space/><link><target>Google</target></link><space/>provides a &quot;Cached&quot; link next to each search result. This can prove useful when web pages from a<space/><link><target>web server</target></link><space/>are temporarily or permanently inaccessible.</paragraph><paragraph>Another type of caching is storing computed results that will likely be needed again, or<space/><link><target>memoization</target></link>. For example,<space/><link><target>ccache</target></link><space/>is a program that caches the output of the compilation, in order to speed up later compilation runs.</paragraph><paragraph><link><target>Database caching</target></link><space/>can substantially improve the throughput of<space/><link><target>database</target></link><space/>applications, for example in the processing of<space/><link><target>Index (database)</target><part>indexes</part></link>,<space/><link><target>Data dictionary</target><part>data dictionaries</part></link>, and frequently used subsets of data.</paragraph><paragraph>A<space/><link><target>distributed cache</target></link><extension extension_name='ref'><template><target>cite journal</target><arg name="last"><space/>Paul
</arg><arg name="first"><space/>S
</arg><arg name="author2">Z Fei
</arg><arg name="date"><space/>1 February 2001
</arg><arg name="title"><space/>Distributed caching with centralized control
</arg><arg name="journal"><space/>Computer Communications
</arg><arg name="volume"><space/>24
</arg><arg name="issue"><space/>2
</arg><arg name="pages"><space/>256–268
</arg><arg name="doi"><space/>10.1016/S0140-3664(00)00322-4
</arg><arg name="accessdate">18 November 2009
</arg></template></extension><space/>uses networked hosts to provide scalability, reliability and performance to the application.<extension extension_name='ref'><template><target>cite journal</target><arg name="last"><space/>Khan
</arg><arg name="first"><space/>Iqbal
</arg><arg name="title"><space/>Distributed Caching On The Path To Scalability
</arg><arg name="magazine"><space/>MSDN
</arg><arg name="issue"><space/>July 2009
</arg><arg name="accessdate">29 March 2012
</arg></template></extension><space/>The hosts can be co-located or spread over different geographical regions.</paragraph><heading level='3'>Buffer vs. cache</heading><paragraph>The semantics of a &quot;buffer&quot; and a &quot;cache&quot; are not necessarily mutually exclusive; even so, there are fundamental differences in intent between the process of caching and the process of buffering.</paragraph><paragraph>Fundamentally, caching realizes a performance increase for transfers of data that is being repeatedly transferred. While a caching system may realize a performance increase upon the initial (typically write) transfer of a data item, this performance increase is due to buffering occurring within the caching system.</paragraph><paragraph>With read caches, a data item must have been fetched from its residing location at least once in order for subsequent reads of the data item to realize a performance increase by virtue of being able to be fetched from the cache's (faster) intermediate storage rather than the data's residing location. With write caches, a performance increase of writing a data item may be realized upon the first write of the data item by virtue of the data item immediately being stored in the cache's intermediate storage, deferring the transfer of the data item to its residing storage at a later stage or else occurring as a background process. Contrary to strict buffering, a caching process must adhere to a (potentially distributed) cache coherency protocol in order to maintain consistency between the cache's intermediate storage and the location where the data resides. Buffering, on the other hand,</paragraph><list type='bullet'><listitem>reduces the number of transfers for otherwise novel data amongst communicating processes, which amortizes overhead involved for several small transfers over fewer, larger transfers,</listitem><listitem>provides an intermediary for communicating processes which are incapable of direct transfers amongst each other, or</listitem><listitem>ensures a minimum data size or representation required by at least one of the communicating processes involved in a transfer.</listitem></list><paragraph>With typical caching implementations, a data item that is read or written for the first time is effectively being buffered; and in the case of a write, mostly realizing a performance increase for the application from where the write originated. Additionally, the portion of a caching protocol where individual writes are deferred to a batch of writes is a form of buffering. The portion of a caching protocol where individual reads are deferred to a batch of reads is also a form of buffering, although this form may negatively impact the performance of at least the initial reads (even though it may positively impact the performance of the sum of the individual reads). In practice, caching almost always involves some form of buffering, while strict buffering does not involve caching.</paragraph><paragraph>A<space/><link><target>data buffer</target><part>buffer</part></link><space/>is a temporary memory location that is traditionally used because CPU<space/><link><target>instruction (computing)</target><part>instruction</part><trail>s</trail></link><space/>cannot directly address data stored in peripheral devices. Thus, addressable memory is used as an intermediate stage. Additionally, such a buffer may be feasible when a large block of data is assembled or disassembled (as required by a storage device), or when data may be delivered in a different order than that in which it is produced. Also, a whole buffer of data is usually transferred sequentially (for example to hard disk), so buffering itself sometimes increases transfer performance or reduces the variation or jitter of the transfer's latency as opposed to caching where the intent is to reduce the latency. These benefits are present even if the buffered data are written to the<space/><link><target>Data buffer</target><part>buffer</part></link><space/>once and read from the buffer once.</paragraph><paragraph>A cache also increases transfer performance. A part of the increase similarly comes from the possibility that multiple small transfers will combine into one large block. But the main performance-gain occurs because there is a good chance that the same data will be read from cache multiple times, or that written data will soon be read. A cache's sole purpose is to reduce accesses to the underlying slower storage. Cache is also usually an<space/><link><target>abstraction layer</target></link><space/>that is designed to be invisible from the perspective of neighboring layers.</paragraph><heading level='2'>See also</heading><paragraph><template><target>Div col</target><arg></arg><arg>25em</arg></template></paragraph><list type='bullet'><listitem><link><target>Cache algorithms</target></link></listitem><listitem><link><target>Cache coherence</target></link></listitem><listitem><link><target>Cache coloring</target></link></listitem><listitem><link><target>Cache hierarchy</target></link></listitem><listitem><link><target>Cache-oblivious algorithm</target></link></listitem><listitem><link><target>Cache stampede</target></link></listitem><listitem><link><target>Cache language model</target></link></listitem><listitem><link><target>Database cache</target></link></listitem><listitem><link><target>Dirty bit</target></link></listitem><listitem><link><target>Disk buffer</target></link></listitem><listitem><link><target>Cache manifest in HTML5</target></link></listitem><listitem><link><target>Five-minute rule</target></link></listitem><listitem><link><target>Materialized view</target></link></listitem><listitem><link><target>Pipeline burst cache</target></link></listitem><listitem><link><target>Temporary file</target></link></listitem></list><paragraph><template><target>Div col end</target></template></paragraph><heading level='2'>References</heading><paragraph><template><target>Reflist</target><arg>30em</arg></template></paragraph><heading level='2'>Further reading</heading><list type='bullet'><listitem><link type='external' href='http://www.unilim.fr/sci/wiki/_media/cali/cpumemory.pdf'>&quot;What Every Programmer Should Know About Memory&quot;</link><space/>by<space/><link><target>Ulrich Drepper</target></link></listitem><listitem><link type='external' href='http://msdn.microsoft.com/en-us/library/dd129907.aspx'>&quot;Caching in the Distributed Environment&quot;</link></listitem></list><paragraph><template><target>Authority control</target></template></paragraph><paragraph><link><target>Category:Cache (computing)</target><part></part></link></paragraph></article>