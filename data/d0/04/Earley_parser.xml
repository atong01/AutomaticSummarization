<article title='Earley_parser'><paragraph>In<space/><link><target>computer science</target></link>, the<space/><bold>Earley parser</bold><space/>is an<space/><link><target>algorithm</target></link><space/>for<space/><link><target>parsing</target></link><space/><link><target>String (computer science)</target><part>strings</part></link><space/>that belong to a given<space/><link><target>context-free language</target></link>, though (depending on the variant) it may suffer problems with certain nullable grammars.<extension extension_name='ref'><template><target>cite web</target><arg name="last">Kegler</arg><arg name="first">Jeffrey</arg><arg name="title">What is the Marpa algorithm?</arg><arg name="url">http://blogs.perl.org/users/jeffrey_kegler/2011/11/what-is-the-marpa-algorithm.html</arg><arg name="accessdate">20 August 2013</arg></template></extension><space/>The algorithm, named after its inventor,<space/><link><target>Jay Earley</target></link>, is a<space/><link><target>chart parser</target></link><space/>that uses<space/><link><target>dynamic programming</target></link>; it is mainly used for parsing in<space/><link><target>computational linguistics</target></link>. It was first introduced in his dissertation<extension extension_name='ref' name="Earley1"><template><target>cite book</target><arg name="last">Earley
<space/></arg><arg name="first">Jay
<space/></arg><arg name="title">An Efficient Context-Free Parsing Algorithm
<space/></arg><arg name="year">1968
<space/></arg><arg name="publisher">Carnegie-Mellon Dissertation
<space/></arg><arg name="url">http://reports-archive.adm.cs.cmu.edu/anon/anon/usr/ftp/scan/CMU-CS-68-earley.pdf</arg></template></extension><space/>in 1968 (and later appeared in abbreviated, more legible form in a journal<extension extension_name='ref' name="Earley2"><template><target>citation</target><arg name="last"><space/>Earley<space/></arg><arg name="first"><space/>Jay<space/></arg><arg name="authorlink"><space/>Jay Earley
<space/></arg><arg name="doi"><space/>10.1145/362007.362035
<space/></arg><arg name="issue"><space/>2
<space/></arg><arg name="journal"><space/>[[Communications of the ACM]]
<space/></arg><arg name="pages"><space/>94â€“102
<space/></arg><arg name="title"><space/>An efficient context-free parsing algorithm
<space/></arg><arg name="volume"><space/>13
<space/></arg><arg name="year"><space/>1970</arg></template></extension>).</paragraph><paragraph>Earley parsers are appealing because they can parse all context-free languages<template><target>discuss</target></template>, unlike<space/><link><target>LR parser</target><trail>s</trail></link><space/>and<space/><link><target>LL parser</target><trail>s</trail></link>, which are more typically used in<space/><link><target>compiler</target><trail>s</trail></link><space/>but which can only handle restricted classes of languages. The Earley parser executes in cubic time in the general case<space/><extension extension_name='math'>{O}(n^3)</extension>, where<space/><italics>n</italics><space/>is the length of the parsed string, quadratic time for unambiguous grammars<space/><extension extension_name='math'>{O}(n^2)</extension>, and linear time for almost all<space/><link><target>LR parser</target><part>LR(k) grammars</part></link>. It performs particularly well when the rules are written<space/><link><target>left recursion</target><part>left-recursively</part></link>.</paragraph><heading level='2'>Earley recogniser</heading><paragraph>The following algorithm describes the Earley recogniser. The recogniser can be easily modified to create a parse tree as it recognises, and in that way can be turned into a parser.</paragraph><heading level='2'>The algorithm</heading><paragraph>In the following descriptions, , , and represent any<space/><link><target>string (computer science)</target><part>string</part></link><space/>of<space/><link><target>Terminal and nonterminal symbols</target><part>terminals/nonterminals</part></link><space/>(including the<space/><link><target>empty string</target></link>), X and Y represent single nonterminals, and<space/><italics>a</italics><space/>represents a terminal symbol.</paragraph><paragraph>Earley's algorithm is a top-down<space/><link><target>dynamic programming</target></link><space/>algorithm. In the following, we use Earley's dot notation: given a<space/><link><target>Formal grammar#The syntax of grammars</target><part>production</part></link><space/>X , the notation X represents a condition in which has already been parsed and is expected.</paragraph><paragraph>Input position 0 is the position prior to input. Input position<space/><italics>n</italics><space/>is the position after accepting the<space/><italics>n</italics>th token. (Informally, input positions can be thought of as locations at<space/><link><target>Lexical analysis</target><part>token</part></link><space/>boundaries.) For every input position, the parser generates a<space/><italics>state set</italics>. Each state is a<space/><link><target>tuple</target></link><space/>(X ,<space/><italics>i</italics>), consisting of</paragraph><list type='bullet'><listitem>the production currently being matched (X )</listitem><listitem>our current position in that production (represented by the dot)</listitem><listitem>the position<space/><italics>i</italics><space/>in the input at which the matching of this production began: the<space/><italics>origin position</italics></listitem></list><paragraph>(Earley's original algorithm included a look-ahead in the state; later research showed this to have little practical effect on the parsing efficiency, and it has subsequently been dropped from most implementations.)</paragraph><paragraph>The state set at input position<space/><italics>k</italics><space/>is called S(<italics>k</italics>). The parser is seeded with S(0) consisting of only the top-level rule. The parser then repeatedly executes three operations:<space/><italics>prediction</italics>,<space/><italics>scanning</italics>, and<space/><italics>completion</italics>.</paragraph><list type='bullet'><listitem><italics>Prediction</italics>: For every state in S(<italics>k</italics>) of the form (X Y ,<space/><italics>j</italics>) (where<space/><italics>j</italics><space/>is the origin position as above), add (Y ,<space/><italics>k</italics>) to S(<italics>k</italics>) for every production in the grammar with Y on the left-hand side (Y ).</listitem><listitem><italics>Scanning</italics>: If<space/><italics>a</italics><space/>is the next symbol in the input stream, for every state in S(<italics>k</italics>) of the form (X<space/><italics>a</italics><space/>,<space/><italics>j</italics>), add (X<space/><italics>a</italics><space/>,<space/><italics>j</italics>) to S(<italics>k</italics>+1).</listitem><listitem><italics>Completion</italics>: For every state in S(<italics>k</italics>) of the form (X ,<space/><italics>j</italics>), find states in S(<italics>j</italics>) of the form (Y X ,<space/><italics>i</italics>) and add (Y X ,<space/><italics>i</italics>) to S(<italics>k</italics>).</listitem></list><paragraph>It is important to note that duplicate states are not added to the state set, only new ones. These three operations are repeated until no new states can be added to the set. The set is generally implemented as a queue of states to process, with the operation to be performed depending on what kind of state it is.</paragraph><heading level='2'>Pseudocode</heading><paragraph>Adapted from<space/><extension extension_name='ref' name="Jurafsky"><template><target>cite book</target><arg name="last">Jurafsky</arg><arg name="first">D.</arg><arg name="title">Speech and Language Processing: An Introduction to Natural Language Processing, Computational Linguistics, and Speech Recognition</arg><arg name="year">2009</arg><arg name="publisher">Pearson Prentice Hall</arg><arg name="isbn">9780131873216</arg><arg name="url">http://books.google.co.uk/books?id</arg></template></extension><space/>by Daniel Jurafsky and James H. Martin</paragraph><paragraph><extension extension_name='syntaxhighlight' lang="pascal"><paragraph>function EARLEY-PARSE(words, grammar)</paragraph><preblock><preline><space/><space/><space/>ENQUEUE(( S, 0), chart[0])</preline><preline><space/><space/><space/>for i from 0 to LENGTH(words) do</preline><preline><space/><space/><space/><space/><space/><space/><space/>for each state in chart[i] do</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>if INCOMPLETE?(state) then</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>if NEXT-CAT(state) is a nonterminal then</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>PREDICTOR(state, i, grammar) // non-terminal</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>else do</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>SCANNER(state, i) // terminal</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>else do</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/><space/>COMPLETER(state, i)</preline><preline><space/><space/><space/><space/><space/><space/><space/>end</preline><preline><space/><space/><space/>end</preline><preline><space/><space/><space/>return chart</preline></preblock><paragraph>procedure PREDICTOR((A B, i), j, grammar)</paragraph><preblock><preline><space/><space/><space/>for each (B ) in GRAMMAR-RULES-FOR(B, grammar) do</preline><preline><space/><space/><space/><space/><space/><space/><space/>ADD-TO-SET((B , j), chart[j])</preline><preline><space/><space/><space/>end</preline></preblock><paragraph>procedure SCANNER((A B, i), j)</paragraph><preblock><preline><space/><space/><space/>if B PARTS-OF-SPEECH(word[j]) then</preline><preline><space/><space/><space/><space/><space/><space/><space/>ADD-TO-SET((B word[j], j), chart[j + 1])</preline><preline><space/><space/><space/>end</preline></preblock><paragraph>procedure COMPLETER((B , j), k)</paragraph><preblock><preline><space/><space/><space/>for each (A B, i) in chart[j] do</preline><preline><space/><space/><space/><space/><space/><space/><space/>ADD-TO-SET((A B, i), chart[k])</preline><preline><space/><space/><space/>end</preline></preblock></extension></paragraph><heading level='2'>Example</heading><paragraph>Consider the following simple grammar for arithmetic expressions:<extension extension_name='syntaxhighlight' lang="bnf">&lt;P&gt; ::= &lt;S&gt; # the start rule&lt;S&gt; ::= &lt;S&gt; &quot;+&quot; &lt;M&gt; | &lt;M&gt;&lt;M&gt; ::= &lt;M&gt; &quot;*&quot; &lt;T&gt; | &lt;T&gt;&lt;T&gt; ::= &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot;</extension>With the input:</paragraph><preblock><preline>2 + 3 * 4</preline></preblock><paragraph>This is the sequence of state sets:</paragraph><preblock><preline>(state no.) Production (Origin) # Comment</preline><preline>-----------------------------------------</preline></preblock><heading level='3'>S(0): 2 + 3 * 4</heading><preblock><preline>(1) P S (0) # start rule</preline><preline>(2) S S + M (0) # predict from (1)</preline><preline>(3) S M (0) # predict from (1)</preline><preline>(4) M M * T (0) # predict from (3)</preline><preline>(5) M T (0) # predict from (3)</preline><preline>(6) T number (0) # predict from (5)</preline></preblock><heading level='3'>S(1): 2 + 3 * 4</heading><preblock><preline>(1) T number (0) # scan from S(0)(6)</preline><preline>(2) M T (0) # complete from (1) and S(0)(5)</preline><preline>(3) M M * T (0) # complete from (2) and S(0)(4)</preline><preline>(4) S M (0) # complete from (2) and S(0)(3)</preline><preline>(5) S S + M (0) # complete from (4) and S(0)(2)</preline><preline>(6) P S (0) # complete from (4) and S(0)(1)</preline></preblock><heading level='3'>S(2): 2 + 3 * 4</heading><preblock><preline>(1) S S + M (0) # scan from S(1)(5)</preline><preline>(2) M M * T (2) # predict from (1)</preline><preline>(3) M T (2) # predict from (1)</preline><preline>(4) T number (2) # predict from (3)</preline></preblock><heading level='3'>S(3): 2 + 3 * 4</heading><preblock><preline>(1) T number (2) # scan from S(2)(4)</preline><preline>(2) M T (2) # complete from (1) and S(2)(3)</preline><preline>(3) M M * T (2) # complete from (2) and S(2)(2)</preline><preline>(4) S S + M (0) # complete from (2) and S(2)(1)</preline><preline>(5) S S + M (0) # complete from (4) and S(0)(2)</preline><preline>(6) P S (0) # complete from (4) and S(0)(1)</preline></preblock><heading level='3'>S(4): 2 + 3 * 4</heading><preblock><preline>(1) M M * T (2) # scan from S(3)(3)</preline><preline>(2) T number (4) # predict from (1)</preline></preblock><heading level='3'>S(5): 2 + 3 * 4</heading><preblock><preline>(1) T number (4) # scan from S(4)(2)</preline><preline>(2) M M * T (2) # complete from (1) and S(4)(1)</preline><preline>(3) M M * T (2) # complete from (2) and S(2)(2)</preline><preline>(4) S S + M (0) # complete from (2) and S(2)(1)</preline><preline>(5) S S + M (0) # complete from (4) and S(0)(2)</preline><preline>(6) P S (0) # complete from (4) and S(0)(1)</preline></preblock><paragraph>The state (P S , 0) represents a completed parse. This state also appears in S(3) and S(1), which are complete sentences.</paragraph><heading level='2'>Constructing the parse forest</heading><paragraph>Earley's dissertation<extension extension_name='ref' name="Earley3"><template><target>cite book</target><arg name="last">Earley
<space/></arg><arg name="first">Jay
<space/></arg><arg name="title">An Efficient Context-Free Parsing Algorithm
<space/></arg><arg name="year">1968
<space/></arg><arg name="publisher">Carnegie-Mellon Dissertation
<space/></arg><arg name="page">106
<space/></arg><arg name="url">http://reports-archive.adm.cs.cmu.edu/anon/anon/usr/ftp/scan/CMU-CS-68-earley.pdf</arg></template></extension><space/>briefly describes an algorithm for constructing parse trees by adding a set of pointers from each non-terminal in an Earley item back to the items which caused it to be recognized. But Tomita noticed<extension extension_name='ref'><template><target>cite book</target><arg name="last1">Tomita</arg><arg name="first1">Masaru</arg><arg name="title">Efficient Parsing for Natural Language: A Fast Algorithm for Practical Systems</arg><arg name="date">April 17, 2013</arg><arg name="publisher">Springer Science and Business Media</arg><arg name="isbn">1475718853</arg><arg name="page">74</arg><arg name="url">https://books.google.com/books?id</arg><arg name="accessdate">16 September 2015</arg></template></extension><space/>that this does not take into account the relations between symbols, so if we consider the grammar S SS | b and the string bbb, it only notes that each S can match one or two b's, and thus produces spurious derivations for bb and bbbb as well as the two correct derivations for bbb.</paragraph><paragraph>It is relatively straightforward to take the complete items from the chart and search through them from the top down, assembling the ones which fit together to make the parse forest.</paragraph><paragraph>Another method, described in,<extension extension_name='ref'><template><target>cite journal</target><arg name="last1">Scott</arg><arg name="first1">Elizabeth</arg><arg name="title">SPPF-Style Parsing From Earley Recognizers</arg><arg name="journal">Electronic Notes in Theoretical Computer Science</arg><arg name="date">April 1, 2008</arg><arg name="volume">203</arg><arg name="issue">2</arg><arg name="pages">53â€“67</arg><arg name="doi">10.1016/j.entcs.2008.03.044</arg><arg name="url">http://www.sciencedirect.com/science/article/pii/S1571066108001497</arg><arg name="accessdate">16 September 2015</arg></template></extension><space/>is to build the parse forest as you go, augmenting each Earley item with a pointer to a shared packed parse forest (SPPF) node labelled with a triple (s, i, j) where s is a symbol or an LR(0) item (production rule with dot), and i and j give the section of the input string derived by this node. A node's contents are either a pair of child pointers giving a single derivation, or a list of &quot;packed&quot; nodes each containing a pair of pointers and representing one derivation. SPPF nodes are unique (there is only one with a given label), but may contain more than one derivation for ambiguous parses. So even if an operation does not add an Earley item (because it already exists), it may still add a derivation to the item's parse forest.</paragraph><list type='bullet'><listitem>Predicted items have a null SPPF pointer.</listitem><listitem>The scanner creates an SPPF node representing the non-terminal it is scanning.</listitem><listitem>Then when the scanner or completer advance an item, they add a derivation whose children are the node from the item whose dot was advanced, and the one for the new symbol which was advanced over (the non-terminal or completed item).</listitem></list><paragraph>Note also that SPPF nodes are never labeled with a completed LR(0) item: instead they are labelled with the symbol which is produced so that all derivations are combined under one node regardless of which alternative production they come from.</paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>CYK algorithm</target></link></listitem><listitem><link><target>Context-free grammar</target></link></listitem><listitem><link><target>List of algorithms#Parsing</target><part>Parsing Algorithms</part></link></listitem></list><heading level='2'>Citations</heading><paragraph><template><target>Reflist</target></template></paragraph><heading level='2'>Other reference materials</heading><list type='bullet'><listitem><template><target>cite book</target><arg name="last1"><space/>Aycock<space/></arg><arg name="first1"><space/>John
<space/></arg><arg name="last2"><space/>Horspool<space/></arg><arg name="first2"><space/>R. Nigel<space/></arg><arg name="author2-link"><space/>Nigel Horspool
<space/></arg><arg name="doi"><space/>10.1093/comjnl/45.6.620
<space/></arg><arg name="issue"><space/>6
<space/></arg><arg name="journal"><space/>[[The Computer Journal]]
<space/></arg><arg name="pages"><space/>620â€“630
<space/></arg><arg name="title"><space/>Practical Earley Parsing
<space/></arg><arg name="volume"><space/>45
<space/></arg><arg name="year"><space/>2002</arg></template></listitem><listitem><template><target>citation</target><arg name="last"><space/>Leo<space/></arg><arg name="first"><space/>Joop M. I. M.
<space/></arg><arg name="doi"><space/>10.1016/0304-3975(91)90180-A
<space/></arg><arg name="issue"><space/>1
<space/></arg><arg name="journal"><space/>[[Theoretical Computer Science (journal)|Theoretical Computer Science]]
<space/></arg><arg name="mr"><space/>1112117
<space/></arg><arg name="pages"><space/>165â€“176
<space/></arg><arg name="title"><space/>A general context-free parsing algorithm running in linear time on every LR(''k'') grammar without using lookahead
<space/></arg><arg name="volume"><space/>82
<space/></arg><arg name="year"><space/>1991
</arg></template></listitem></list><list type='bullet'><listitem><template><target>cite conference</target><arg name="first"><space/>Masaru</arg><arg name="last"><space/>Tomita</arg><arg name="title"><space/>LR parsers for natural languages<space/></arg><arg name="conference"><space/>10th International Conference on Computational Linguistics<space/></arg><arg name="booktitle"><space/>COLING</arg><arg name="pages"><space/>354â€“357</arg><arg name="year"><space/>1984</arg></template></listitem></list><heading level='2'>Implementations</heading><heading level='3'>C, C++</heading><list type='bullet'><listitem><link type='external' href='https://github.com/vnmakarov/yaep'>'Yet Another Earley Parser (YAEP)'</link><space/><link><target>C (programming language)</target><part>C</part></link>/<link><target>C++</target></link><space/>libraries.</listitem><listitem><link type='external' href='https://bitbucket.org/amirouche/c-earley-parser/src'>'C Earley Parser'</link><space/>An Earley parser C.</listitem></list><heading level='3'>Haskell</heading><list type='bullet'><listitem><link type='external' href='https://hackage.haskell.org/package/Earley'>'Earley'</link><space/>An Earley parser<space/><link><target>Domain-specific language</target><part>DSL</part></link><space/>in<space/><link><target>Haskell (programming language)</target><part>Haskell</part></link></listitem></list><heading level='3'>Java</heading><list type='bullet'><listitem><link type='external' href='http://linguateca.dei.uc.pt/index.php?sep=recursos'>PEN</link><space/>A Java library that implements the Earley algorithm.</listitem><listitem><link type='external' href='http://www.coffeeblack.org/#projects-pep'>Pep</link><space/>A Java library that implements the Earley algorithm and provides charts and parse trees as parsing artifacts.</listitem><listitem><link type='external' href='http://www.cs.umanitoba.ca/~comp4190/Earley/Earley.java'></link><space/>A Java implementation of Earley parser.</listitem></list><heading level='3'>JavaScript</heading><list type='bullet'><listitem><link type='external' href='http://parser.moonyweb.com'>JavaScript Moony Parser</link><space/>A type of Earley parser written in<space/><link><target>JavaScript</target></link>.</listitem><listitem><link type='external' href='https://github.com/Hardmath123/nearley'>Nearley</link><space/>An Earley parser that's starting to integrate the improvements that Marpa adopted.</listitem><listitem><link type='external' href='http://joshuagrams.github.io/pep/'>A Pint-sized Earley Parser</link><space/>A toy parser (with annotated pseudocode) to demonstrate Elizabeth Scott's technique for building the shared packed parse forest.</listitem><listitem><link type='external' href='https://github.com/lagodiuk/earley-parser-js'>earley-parser-js</link><space/>Tiny JavaScript implementation of context-free languages parser - Earley parser</listitem></list><heading level='3'>Perl</heading><list type='bullet'><listitem><link type='external' href='https://metacpan.org/module/Marpa::R2'>Marpa::R2</link>, a<space/><link><target>Perl</target></link><space/>module.<space/><link type='external' href='http://jeffreykegler.github.com/Marpa-web-site/'>Marpa</link><space/>is an Earley's algorithm that includes the improvements made by Joop Leo, and by Aycock and Horspool.</listitem><listitem><link type='external' href='https://metacpan.org/module/Parse::Earley'>Parse::Earley</link><space/>A Perl module implementing Jay Earley's original algorithm.</listitem></list><heading level='3'>Python</heading><list type='bullet'><listitem><link type='external' href='http://www.cavar.me/damir/charty/python/'>Charty</link><space/>a<space/><link><target>Python (programming language)</target><part>Python</part></link><space/>implementation of an Earley parser.</listitem><listitem><link type='external' href='http://nltk.org/'>NLTK</link><space/>a<space/><link><target>Python (programming language)</target><part>Python</part></link><space/>toolkit with an Earley parser.</listitem><listitem><link type='external' href='http://pages.cpsc.ucalgary.ca/~aycock/spark/'>Spark</link><space/>an object-oriented<space/><italics>little language framework</italics><space/>for Python implementing an Earley parser.</listitem><listitem><link type='external' href='https://github.com/tomerfiliba/tau/blob/master/earley3.py'>earley3.py</link><space/>A stand-alone implementation of the algorithm in less than 150 lines of code, including generation of the parsing-forest and samples.</listitem></list><heading level='3'>Common Lisp</heading><list type='bullet'><listitem><link type='external' href='http://www.cliki.net/CL-EARLEY-PARSER'>CL-Earley-parser</link><space/>A Common Lisp library implementing an Earley parser.</listitem></list><heading level='3'>Scheme, Racket</heading><list type='bullet'><listitem><link type='external' href='http://www.cavar.me/damir/charty/scheme/'>Charty-Racket</link><space/>A<space/><link><target>Scheme (programming language)</target><part>Scheme</part></link>-<link><target>Racket (programming language)</target><part>Racket</part></link><space/>implementation of an Earley parser.</listitem></list><heading level='3'>Resources</heading><list type='bullet'><listitem><link type='external' href='http://accent.compilertools.net/Entire.html'>The Accent compiler-compiler</link></listitem></list><paragraph><link><target>Category:Parsing algorithms</target></link><link><target>Category:Dynamic programming</target></link></paragraph></article>