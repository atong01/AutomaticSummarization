<article title='Buffer_overflow'><paragraph>In<space/><link><target>computer security</target></link><space/>and<space/><link><target>computer programming</target><part>programming</part></link>, a<space/><bold>buffer overflow</bold>, or<space/><bold>buffer overrun</bold>, is an<space/><link><target>anomaly in software</target><part>anomaly</part></link><space/>where a<space/><link><target>computer program</target><part>program</part></link>, while writing<space/><link><target>Data (computing)</target><part>data</part></link><space/>to a<space/><link><target>buffer (computer science)</target><part>buffer</part></link>, overruns the buffer's boundary and overwrites adjacent<space/><link><target>Main memory</target><part>memory</part></link><space/>locations. This is a special case of the violation of<space/><link><target>memory safety</target></link>.</paragraph><paragraph>Buffer overflows can be triggered by inputs that are designed to<space/><link><target>execution (computing)</target><part>execute</part></link><space/>code, or alter the way the program operates. This may result in erratic program behavior, including memory access errors, incorrect results, a<space/><link><target>crash (computing)</target><part>crash</part></link>, or a breach of system security. Thus, they are the basis of many<space/><link><target>vulnerability (computer science)</target><part>software vulnerabilities</part></link><space/>and can be maliciously<space/><link><target>exploit (computer security)</target><part>exploited</part></link>.</paragraph><paragraph><link><target>Programming language</target><trail>s</trail></link><space/>commonly associated with buffer overflows include<space/><link><target>C (programming language)</target><part>C</part></link><space/>and<space/><link><target>C++</target></link>, which provide no built-in protection against accessing or overwriting data in any part of memory and do not automatically check that data written to an<space/><link><target>Array data structure</target><part>array</part></link><space/>(the built-in buffer type) is within the boundaries of that array.<space/><link><target>Bounds checking</target></link><space/>can prevent buffer overflows.</paragraph><heading level='2'>Technical description</heading><paragraph>A buffer overflow occurs when<space/><link><target>data</target></link><space/>written to a buffer also corrupts data values in<space/><link><target>memory address</target><trail>es</trail></link><space/>adjacent to the destination buffer due to insufficient<space/><link><target>bounds checking</target></link>. This can occur when copying data from one buffer to another without first checking that the data fits within the destination buffer.</paragraph><heading level='3'>Example</heading><paragraph><template><target>Details</target><arg>Stack buffer overflow</arg><arg>stack-based overflows</arg></template></paragraph><paragraph>In the following example, a program has two data items which are adjacent in memory: an 8-byte-long string buffer, A, and a two-byte<space/><link><target>endianness</target><part>big-endian</part></link><space/>integer, B.</paragraph><paragraph><extension extension_name='source' lang="c">char A[8] = &quot;&quot;;unsigned short B = 1979;</extension></paragraph><paragraph>Initially, A contains nothing but zero bytes, and B contains the number 1979.</paragraph><table class="wikitable" style="width:32em; text-align:center;"><tablerow><tablehead style="white-space:nowrap;">variable name</tablehead><tablehead colspan="8" style="background:#ddf;">A</tablehead><tablehead colspan="2" style="background:#fdd;">B</tablehead></tablerow><tablerow style="background:#ddf;"><tablehead>value</tablehead><tablecell colspan="8">[<extension extension_name='nowiki'></extension><link><target>null string</target></link><extension extension_name='nowiki'></extension>]</tablecell><tablecell colspan="2" style="background:#fdd;"><xhtml:tt>1979</xhtml:tt></tablecell></tablerow><tablerow style="background:#ddf;"><tablehead>hex value</tablehead><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell><space/><xhtml:tt>00</xhtml:tt></tablecell><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell><xhtml:tt>00</xhtml:tt></tablecell><tablecell style="background:#fdd;"><xhtml:tt>07</xhtml:tt></tablecell><tablecell style="background:#fdd;"><xhtml:tt>BB</xhtml:tt></tablecell></tablerow></table><paragraph>Now, the program attempts to store the<space/><link><target>null-terminated string</target></link><space/><template><target>code</target><arg>"excessive"</arg></template><space/>with<space/><link><target>ASCII</target></link><space/>encoding in the A buffer.<extension extension_name='source' lang="c">strcpy(A, &quot;excessive&quot;);</extension><template><target>code</target><arg>"excessive"</arg></template><space/>is 9 characters long and encodes to 10 bytes including the terminator, but A can take only 8 bytes. By failing to check the length of the string, it also overwrites the value of B:</paragraph><table class="wikitable" style="width:32em; text-align:center;"><tablerow><tablehead style="white-space:nowrap;">variable name</tablehead><tablehead colspan="8" style="background:#ddf;">A</tablehead><tablehead colspan="2" style="background:#fdd;">B</tablehead></tablerow><tablerow style="background:#ddf;"><tablehead>value</tablehead><tablecell><xhtml:tt>'e'</xhtml:tt></tablecell><tablecell><xhtml:tt>'x'</xhtml:tt></tablecell><tablecell><xhtml:tt>'c'</xhtml:tt></tablecell><tablecell><xhtml:tt>'e'</xhtml:tt></tablecell><tablecell><space/><xhtml:tt>'s'</xhtml:tt></tablecell><tablecell><xhtml:tt>'s'</xhtml:tt></tablecell><tablecell><xhtml:tt>'i'</xhtml:tt></tablecell><tablecell><xhtml:tt>'v'</xhtml:tt></tablecell><tablecell colspan="2" style="background:#dbd;"><xhtml:tt>25856</xhtml:tt></tablecell></tablerow><tablerow style="background:#ddf;"><tablehead>hex</tablehead><tablecell><xhtml:tt>65</xhtml:tt></tablecell><tablecell><xhtml:tt>78</xhtml:tt></tablecell><tablecell><xhtml:tt>63</xhtml:tt></tablecell><tablecell><xhtml:tt>65</xhtml:tt></tablecell><tablecell><space/><xhtml:tt>73</xhtml:tt></tablecell><tablecell><xhtml:tt>73</xhtml:tt></tablecell><tablecell><xhtml:tt>69</xhtml:tt></tablecell><tablecell><xhtml:tt>76</xhtml:tt></tablecell><tablecell style="background:#dbd;"><xhtml:tt>65</xhtml:tt></tablecell><tablecell style="background:#dbd;"><xhtml:tt>00</xhtml:tt></tablecell></tablerow></table><paragraph>B's value has now been inadvertently replaced by a number formed from part of the character string. In this example &quot;e&quot; followed by a zero byte would become 25856.</paragraph><paragraph>Writing data past the end of allocated memory can sometimes be detected by the operating system to generate a<space/><link><target>segmentation fault</target></link><space/>error that terminates the process.</paragraph><paragraph>To prevent the buffer overflow from happening in this example, the call to<space/><xhtml:tt><link><target>strcpy</target></link></xhtml:tt><space/>could be replaced with<space/><xhtml:tt><link><target>strncpy</target></link></xhtml:tt>, which takes the maximum capacity of A as an additional parameter and ensures that no more than this amount of data is written to A:</paragraph><paragraph><extension extension_name='source' lang="c">strncpy(A, &quot;excessive&quot;, sizeof(A));</extension></paragraph><heading level='2'>Exploitation</heading><paragraph>The techniques to<space/><link><target>exploit (computer security)</target><part>exploit</part></link><space/>a buffer overflow vulnerability vary by<space/><link><target>computer architecture</target><part>architecture</part></link>, by<space/><link><target>operating system</target></link><space/>and by memory region. For example, exploitation on the<space/><link><target>dynamic memory allocation#Heap-based memory allocation</target><part>heap</part></link><space/>(used for dynamically allocated memory), differs markedly from exploitation on the<space/><link><target>call stack</target></link>.</paragraph><heading level='3'>Stack-based exploitation</heading><paragraph><template><target>Main</target><arg>Stack buffer overflow</arg></template></paragraph><paragraph>A technically inclined user may exploit stack-based buffer overflows to manipulate the program to their advantage in one of several ways:</paragraph><list type='bullet'><listitem>by overwriting a local variable that is near the buffer in memory on the stack to change the behavior of the program - which may benefit the attacker.</listitem><listitem>by overwriting the return address in a<space/><link><target>stack frame</target></link>. Once the function returns, execution will resume at the return address as specified by the attacker, usually a user-input filled buffer.</listitem><listitem>by overwriting a function pointer<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.securityfocus.com/archive/1/462728/30/150/threaded<space/></arg><arg name="title">CORE-2007-0219: OpenBSD's IPv6 mbufs remote kernel buffer overflow<space/></arg><arg name="accessdate">2007-05-15</arg></template></extension><space/>or<space/><link><target>exception handler</target></link>, which is subsequently executed</listitem><listitem>by overwriting a parameter of a different stack frame or a non-local address pointed to in the current stack context<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://packetstormsecurity.com/files/download/121751/ModernOverflowTargets.pdf<space/></arg><arg name="title">Modern Overflow Targets<space/></arg><arg name="accessdate">2013-07-05</arg></template></extension></listitem></list><paragraph>With a method called &quot;trampolining&quot;, if the address of the user-supplied data is unknown, but the location is stored in a register, then the return address can be overwritten with the address of an<space/><link><target>opcode</target></link><space/>which will cause execution to jump to the user supplied data. If the location is stored in a register R, then a jump to the location containing the opcode for a jump R, call R or similar instruction, will cause execution of user-supplied data. The locations of suitable opcodes, or bytes in memory, can be found in<space/><link><target>dynamic-link library</target><part>DLLs</part></link><space/>or in the executable itself. However the address of the opcode typically cannot contain any<space/><link><target>null character</target><trail>s</trail></link><space/>and the locations of these opcodes can vary between applications and versions of the operating system. The<space/><link><target>Metasploit Project</target></link>, for example, maintains a database of suitable opcodes, though listing only those found in the<space/><link><target>Microsoft Windows</target><part>Windows</part></link><space/>operating system.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://metasploit.com/users/opcode/msfopcode.cgi<space/></arg><arg name="title">The Metasploit Opcode Database<space/></arg><arg name="accessdate">2007-05-15<space/></arg><arg name="deadurl">yes<space/></arg><arg name="archiveurl">https://web.archive.org/20070512195939/http://www.metasploit.com:80/users/opcode/msfopcode.cgi<space/></arg><arg name="archivedate">12 May 2007<space/></arg></template></extension></paragraph><paragraph>Stack-based buffer overflows are not to be confused with<space/><link><target>stack overflow</target><trail>s</trail></link>.</paragraph><paragraph>Also note that these vulnerabilities are usually discovered through the use of a<space/><link><target>fuzzer</target></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://raykoid666.wordpress.com<space/></arg><arg name="title">The Exploitant - Security info and tutorials<space/></arg><arg name="accessdate">2009-11-29</arg></template></extension></paragraph><heading level='3'>Heap-based exploitation</heading><paragraph><template><target>Main</target><arg>Heap overflow</arg></template></paragraph><paragraph>A buffer overflow occurring in the heap data area is referred to as a heap overflow and is exploitable in a manner different from that of stack-based overflows. Memory on the heap is dynamically allocated by the application at run-time and typically contains program data. Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked list pointers. The canonical heap overflow technique overwrites dynamic memory allocation linkage (such as<space/><link><target>malloc</target></link><space/>meta data) and uses the resulting pointer exchange to overwrite a program function pointer.</paragraph><paragraph><link><target>Microsoft</target></link>'s<space/><link><target>Graphics Device Interface</target><part>GDI+</part></link><space/>vulnerability in handling<space/><link><target>JPEG</target><trail>s</trail></link><space/>is an example of the danger a heap overflow can present.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.microsoft.com/technet/security/bulletin/MS04-028.mspx<space/></arg><arg name="title">Microsoft Technet Security Bulletin MS04-028<space/></arg><arg name="accessdate">2007-05-15</arg></template></extension></paragraph><heading level='3'>Barriers to exploitation</heading><paragraph>Manipulation of the buffer, which occurs before it is read or executed, may lead to the failure of an exploitation attempt. These manipulations can mitigate the threat of exploitation, but may not make it impossible. Manipulations could include conversion to upper or lower case, removal of<space/><link><target>metacharacter</target><trail>s</trail></link><space/>and filtering out of non-<link><target>alphanumeric</target></link><space/>strings. However, techniques exist to bypass these filters and manipulations;<space/><link><target>alphanumeric code</target></link>,<space/><link><target>polymorphic code</target></link>,<space/><link><target>self-modifying code</target></link><space/>and<space/><link><target>return-to-libc attack</target><trail>s</trail></link>. The same methods can be used to avoid detection by<space/><link><target>intrusion detection system</target><trail>s</trail></link>. In some cases, including where code is converted into unicode,<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.net-security.org/dl/articles/unicodebo.pdf<space/></arg><arg name="title">Creating Arbitrary Shellcode In Unicode Expanded Strings<space/></arg><arg name="format">PDF<space/></arg><arg name="accessdate">2007-05-15</arg></template></extension><space/>the threat of the vulnerability have been misrepresented by the disclosers as only Denial of Service when in fact the remote execution of arbitrary code is possible.</paragraph><heading level='3'>Practicalities of exploitation</heading><paragraph>In real-world exploits there are a variety of challenges which need to be overcome for exploits to operate reliably. These factors include null bytes in addresses, variability in the location of shellcode, differences between environments and various counter-measures in operation.</paragraph><heading level='4'>NOP sled technique</heading><paragraph><template><target>Main</target><arg>NOP slide</arg></template></paragraph><paragraph><link><target>File:nopsled.svg</target><part>right</part><part>thumb</part><part>200px</part><part>Illustration of a NOP-sled payload on the stack.</part></link></paragraph><paragraph>A NOP-sled is the oldest and most widely known technique for successfully exploiting a stack buffer overflow.<extension extension_name='ref' name="neworder"></extension><space/>It solves the problem of finding the exact address of the buffer by effectively increasing the size of the target area. To do this, much larger sections of the stack are corrupted with the<space/><link><target>no-op</target></link><space/>machine instruction. At the end of the attacker-supplied data, after the no-op instructions, the attacker places an instruction to perform a relative jump to the top of the buffer where the<space/><link><target>shellcode</target></link><space/>is located. This collection of no-ops is referred to as the &quot;NOP-sled&quot; because if the return address is overwritten with any address within the no-op region of the buffer it will &quot;slide&quot; down the no-ops until it is redirected to the actual malicious code by the jump at the end. This technique requires the attacker to guess where on the stack the NOP-sled is instead of the comparatively small shellcode.<extension extension_name='ref' name="enderunix"></extension></paragraph><paragraph>Because of the popularity of this technique, many vendors of<space/><link><target>intrusion prevention system</target><trail>s</trail></link><space/>will search for this pattern of no-op machine instructions in an attempt to detect shellcode in use. It is important to note that a NOP-sled does not necessarily contain only traditional no-op machine instructions; any instruction that does not corrupt the machine state to a point where the shellcode will not run can be used in place of the hardware assisted no-op. As a result it has become common practice for exploit writers to compose the no-op sled with randomly chosen instructions which will have no real effect on the shellcode execution.<extension extension_name='ref' name="Akritidis1"></extension></paragraph><paragraph>While this method greatly improves the chances that an attack will be successful, it is not without problems. Exploits using this technique still must rely on some amount of luck that they will guess offsets on the stack that are within the NOP-sled region.<extension extension_name='ref' name="klein1"></extension><space/>An incorrect guess will usually result in the target program crashing and could alert the<space/><link><target>system administrator</target></link><space/>to the attacker's activities. Another problem is that the NOP-sled requires a much larger amount of memory in which to hold a NOP-sled large enough to be of any use. This can be a problem when the allocated size of the affected buffer is too small and the current depth of the stack is shallow (i.e. there is not much space from the end of the current stack frame to the start of the stack). Despite its problems, the NOP-sled is often the only method that will work for a given platform, environment, or situation; as such it is still an important technique.</paragraph><heading level='4'>The jump to address stored in a register technique</heading><paragraph>The &quot;jump to register&quot; technique allows for reliable exploitation of stack buffer overflows without the need for extra room for a NOP-sled and without having to guess stack offsets. The strategy is to overwrite the return pointer with something that will cause the program to jump to a known pointer stored within a register which points to the controlled buffer and thus the shellcode. For example, if register A contains a pointer to the start of a buffer then any jump or call taking that register as an operand can be used to gain control of the flow of execution.<extension extension_name='ref' name="shah"></extension><space/><link><target>File:jumpToEsp.png</target><part>left</part><part>thumb</part><part>300px</part><part>An instruction from ntdll.dll to call the<space/><xhtml:code>DbgPrint()</xhtml:code><space/>routine contains the<space/><link><target>i386</target></link><space/>machine opcode for<space/><xhtml:code>jmp esp</xhtml:code>.</part></link></paragraph><paragraph>In practice a program may not intentionally contain instructions to jump to a particular register. The traditional solution is to find an unintentional instance of a suitable<space/><link><target>opcode</target></link><space/>at a fixed location somewhere within the program memory. In figure<space/><link><target>:Image:JumpToEsp.png</target><part>E</part></link><space/>on the left you can see an example of such an unintentional instance of the i386<space/><xhtml:code>jmp esp</xhtml:code><space/>instruction. The opcode for this instruction is<space/><xhtml:code>FF E4</xhtml:code>.<extension extension_name='ref' name="intel1"></extension><space/>This two-byte sequence can be found at a one-byte offset from the start of the instruction<space/><xhtml:code>call DbgPrint</xhtml:code><space/>at address<space/><xhtml:code>0x7C941EED</xhtml:code>. If an attacker overwrites the program return address with this address the program will first jump to<space/><xhtml:code>0x7C941EED</xhtml:code>, interpret the opcode<space/><xhtml:code>FF E4</xhtml:code><space/>as the<space/><xhtml:code>jmp esp</xhtml:code><space/>instruction, and will then jump to the top of the stack and execute the attacker's code.<extension extension_name='ref' name="packetstorm1"></extension></paragraph><paragraph>When this technique is possible the severity of the vulnerability increases considerably. This is because exploitation will work reliably enough to automate an attack with a virtual guarantee of success when it is run. For this reason, this is the technique most commonly used in<space/><link><target>Internet worm</target><trail>s</trail></link><space/>that exploit stack buffer overflow vulnerabilities.<extension extension_name='ref' name="Yuji1"></extension></paragraph><paragraph>This method also allows shellcode to be placed after the overwritten return address on the Windows platform. Since executables are mostly based at address<space/><xhtml:code>0x00400000</xhtml:code><space/>and x86 is a<space/><link><target>Little endian</target><part>Little Endian</part></link><space/>architecture, the last byte of the return address must be a null, which terminates the buffer copy and nothing is written beyond that. This limits the size of the shellcode to the size of the buffer, which may be overly restrictive. DLLs are located in high memory (above<space/><xhtml:code>0x01000000</xhtml:code>) and so have addresses containing no null bytes, so this method can remove null bytes (or other disallowed characters) from the overwritten return address. Used in this way, the method is often referred to as &quot;DLL Trampolining&quot;.</paragraph><heading level='2'>Protective countermeasures</heading><paragraph>Various techniques have been used to detect or prevent buffer overflows, with various tradeoffs. The most reliable way to avoid or prevent buffer overflows is to use automatic protection at the language level. This sort of protection, however, cannot be applied to<space/><link><target>legacy code</target></link>, and often technical, business, or cultural constraints call for a vulnerable language. The following sections describe the choices and implementations available.</paragraph><heading level='3'>Choice of programming language</heading><paragraph>The choice of programming language can have a profound effect on the occurrence of buffer overflows.<space/><template><target>As of</target><arg>2008</arg></template>, among the most popular languages are<space/><link><target>C (programming language)</target><part>C</part></link><space/>and its derivative,<space/><link><target>C++</target></link>, with a vast body of software having been written in these languages. C provides no built-in protection against accessing or overwriting data in any part of memory; more specifically, it does not check that data written to a buffer is within the boundaries of that buffer. The standard C++ libraries provide many ways of safely buffering data, and C++'s<space/><link><target>Standard Template Library</target></link><space/>(STL) provides containers that can optionally perform bounds checking if the programmer explicitly calls for checks while accessing data. For example, a<space/><xhtml:code>vector</xhtml:code>'s member function<space/><xhtml:code>at()</xhtml:code><space/>performs a bounds check and throws an<space/><xhtml:code>out_of_range</xhtml:code><space/><link><target>Exception handling</target><part>exception</part></link><space/>if the bounds check fails.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.cplusplus.com/reference/vector/vector/at/<space/></arg><arg name="title">vector::at - C++ Reference<space/></arg><arg name="publisher">Cplusplus.com<space/></arg><arg name="accessdate">2014-03-27</arg></template></extension><space/>However, C++ behaves just like C if the bounds check is not explicitly called. Techniques to avoid buffer overflows also exist for C.</paragraph><paragraph>Many other programming languages provide runtime checking and in some cases even compile-time checking which might send a warning or raise an exception when C or C++ would overwrite data and continue to execute further instructions until erroneous results are obtained which might or might not cause the program to crash. Examples of such languages include<space/><link><target>Ada (programming language)</target><part>Ada</part></link>,<space/><link><target>Eiffel (programming language)</target><part>Eiffel</part></link>,<space/><link><target>Lisp (programming language)</target><part>Lisp</part></link>,<space/><link><target>Modula-2</target></link>,<space/><link><target>Smalltalk</target></link>,<space/><link><target>OCaml</target></link><space/>and such C-derivatives as<space/><link><target>Cyclone (programming language)</target><part>Cyclone</part></link>,<space/><link><target>Rust (programming language)</target><part>Rust</part></link><space/>and<space/><link><target>D (programming language)</target><part>D</part></link>. The<space/><link><target>Java (software platform)</target><part>Java</part></link><space/>and<space/><link><target>.NET Framework</target></link><space/>bytecode environments also require bounds checking on all arrays. Nearly every<space/><link><target>interpreted programming language</target><part>interpreted language</part></link><space/>will protect against buffer overflows, signaling a well-defined error condition. Often where a language provides enough type information to do bounds checking an option is provided to enable or disable it.<space/><link><target>Static code analysis</target></link><space/>can remove many dynamic bound and type checks, but poor implementations and awkward cases can significantly decrease performance. Software engineers must carefully consider the tradeoffs of safety versus performance costs when deciding which language and compiler setting to use.</paragraph><heading level='3'>Use of safe libraries</heading><paragraph>The problem of buffer overflows is common in the C and C++ languages because they expose low level representational details of buffers as containers for data types. Buffer overflows must thus be avoided by maintaining a high degree of correctness in code which performs buffer management. It has also long been recommended to avoid standard library functions which are not bounds checked, such as<space/><xhtml:code><link><target>gets()</target><part>gets</part></link></xhtml:code>,<space/><xhtml:code><link><target>scanf</target></link></xhtml:code><space/>and<space/><xhtml:code><link><target>strcpy</target></link></xhtml:code>. The<space/><link><target>Morris worm</target></link><space/>exploited a<space/><xhtml:code>gets</xhtml:code><space/>call in<space/><link><target>fingerd</target></link>.<extension extension_name='ref'>http://wiretap.area.com/Gopher/Library/Techdoc/Virus/inetvir.823</extension></paragraph><paragraph>Well-written and tested abstract data type libraries which centralize and automatically perform buffer management, including bounds checking, can reduce the occurrence and impact of buffer overflows. The two main building-block data types in these languages in which buffer overflows commonly occur are strings and arrays; thus, libraries preventing buffer overflows in these data types can provide the vast majority of the necessary coverage. Still, failure to use these safe libraries correctly can result in buffer overflows and other vulnerabilities; and naturally, any bug in the library itself is a potential vulnerability. &quot;Safe&quot; library implementations include &quot;The Better String Library&quot;,<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://bstring.sf.net/<space/></arg><arg name="title">The Better String Library</arg></template></extension><space/>Vstr<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.and.org/vstr/<space/></arg><arg name="title">The Vstr Homepage<space/></arg><arg name="accessdate">2007-05-15</arg></template></extension><space/>and Erwin.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.theiling.de/projects/erwin.html<space/></arg><arg name="title">The Erwin Homepage<space/></arg><arg name="accessdate">2007-05-15</arg></template></extension><space/>The<space/><link><target>OpenBSD</target></link><space/>operating system's<space/><link><target>C library</target></link><space/>provides the<space/><link><target>strlcpy</target></link><space/>and<space/><link><target>strlcat</target></link><space/>functions, but these are more limited than full safe library implementations.</paragraph><paragraph>In September 2007, Technical Report 24731, prepared by the C standards committee, was published;<template><target>Citation needed</target><arg name="date">February 2011</arg></template><space/>it specifies a set of functions which are based on the standard C library's string and I/O functions, with additional buffer-size parameters. However, the efficacy of these functions for the purpose of reducing buffer overflows is disputable; it requires programmer intervention on a per function call basis that is equivalent to intervention that could make the analogous older standard library functions buffer overflow safe.<extension extension_name='ref'><template><target>cite web</target><arg name="url">https://www.securecoding.cert.org/confluence/x/QwY<space/></arg><arg name="title">CERT Secure Coding Initiative<space/></arg><arg name="accessdate">2007-07-30</arg></template></extension></paragraph><heading level='3'>Buffer overflow protection</heading><paragraph><template><target>Main</target><arg>Buffer overflow protection</arg></template></paragraph><paragraph>Buffer overflow protection is used to detect the most common buffer overflows by checking that the<space/><link><target>call stack</target><part>stack</part></link><space/>has not been altered when a function returns. If it has been altered, the program exits with a<space/><link><target>segmentation fault</target></link>. Three such systems are Libsafe,<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://directory.fsf.org/libsafe.html<space/></arg><arg name="title">Libsafe at FSF.org<space/></arg><arg name="accessdate">2007-05-20</arg></template></extension><space/>and the<space/><italics><link><target>StackGuard</target></link></italics><extension extension_name='ref'><template><target>cite web</target><arg name="url">https://www.usenix.org/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf<space/></arg><arg name="title">StackGuard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks by Cowan et al.<space/></arg><arg name="format">PDF<space/></arg><arg name="accessdate">2007-05-20</arg></template></extension><space/>and<space/><italics><link><target>ProPolice</target></link></italics><extension extension_name='ref'><template><target>cite web</target><arg name="url">http://wiki.x.org/wiki/ProPolice<space/></arg><arg name="title">ProPolice at X.ORG<space/></arg><arg name="accessdate">2007-05-20<space/></arg><arg name="deadurl">yes<space/></arg><arg name="archiveurl">https://web.archive.org/20070212032750/http://wiki.x.org:80/wiki/ProPolice<space/></arg><arg name="archivedate">12 February 2007<space/></arg></template></extension><space/><link><target>GNU Compiler Collection</target><part>gcc</part></link><space/>patches.</paragraph><paragraph>Microsoft's implementation of<space/><link><target>Data Execution Prevention</target></link><space/>(DEP) mode explicitly protects the pointer to the<space/><link><target>Structured Exception Handler</target></link><space/>(SEH) from being overwritten.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.uninformed.org/?v</arg><arg name="title">Bypassing Windows Hardware-enforced Data Execution Prevention<space/></arg><arg name="accessdate">2007-05-20</arg></template></extension></paragraph><paragraph>Stronger stack protection is possible by splitting the stack in two: one for data and one for function returns. This split is present in the<space/><link><target>Forth (programming language)</target><part>Forth language</part></link>, though it was not a security-based design decision. Regardless, this is not a complete solution to buffer overflows, as sensitive data other than the return address may still be overwritten.</paragraph><heading level='3'>Pointer protection</heading><paragraph>Buffer overflows work by manipulating pointers (including stored addresses). PointGuard was proposed as a compiler-extension to prevent attackers from being able to reliably manipulate pointers and addresses.<extension extension_name='ref'><link type='external' href='http://www.usenix.org/events/sec03/tech/full_papers/cowan/cowan_html/index.html'>PointGuard: Protecting Pointers From Buffer Overflow Vulnerabilities</link></extension><space/>The approach works by having the compiler add code to automatically XOR-encode pointers before and after they are used. Because the attacker (theoretically) does not know what value will be used to encode/decode the pointer, he cannot predict what it will point to if he overwrites it with a new value. PointGuard was never released, but Microsoft implemented a similar approach beginning in Windows XP SP2 and Windows Server 2003 SP1.<extension extension_name='ref'><link type='external' href='http://blogs.msdn.com/michael_howard/archive/2006/01/30/520200.aspx'>Protecting Against Pointer Subterfuge (Kinda!)</link></extension><space/>Rather than implement pointer protection as an automatic feature, Microsoft added an API routine that can be called at the discretion of the programmer. This allows for better performance (because it is not used all of the time), but places the burden on the programmer to know when it is necessary.</paragraph><paragraph>Because XOR is linear, an attacker may be able to manipulate an encoded pointer by overwriting only the lower bytes of an address. This can allow an attack to succeed if the attacker is able to attempt the exploit multiple times or is able to complete an attack by causing a pointer to point to one of several locations (such as any location within a NOP sled).<extension extension_name='ref'><link type='external' href='http://www.usenix.org/publications/login/2005-06/pdfs/alexander0506.pdf'>Defeating Compiler-Level Buffer Overflow Protection</link></extension><space/>Microsoft added a random rotation to their encoding scheme to address this weakness to partial overwrites.<extension extension_name='ref'><link type='external' href='http://blogs.msdn.com/michael_howard/archive/2006/08/16/702707.aspx'>Protecting against Pointer Subterfuge (Redux)</link></extension></paragraph><heading level='3'>Executable space protection</heading><paragraph><template><target>Main</target><arg>Executable space protection</arg></template></paragraph><paragraph>Executable space protection is an approach to buffer overflow protection which prevents execution of code on the stack or the heap. An attacker may use buffer overflows to insert arbitrary code into the memory of a program, but with executable space protection, any attempt to execute that code will cause an exception.</paragraph><paragraph>Some CPUs support a feature called<space/><link><target>NX bit</target><part>NX</part></link><space/>(&quot;No eXecute&quot;) or<space/><link><target>XD bit</target><part>XD</part></link><space/>(&quot;eXecute Disabled&quot;) bit, which in conjunction with software, can be used to mark<space/><link><target>paging</target><part>pages of data</part></link><space/>(such as those containing the stack and the heap) as readable and writeable but not executable.</paragraph><paragraph>Some Unix operating systems (e.g.<space/><link><target>OpenBSD</target></link>,<space/><link><target>OS X</target></link>) ship with executable space protection (e.g.<space/><link><target>W^X</target></link>). Some optional packages include:</paragraph><list type='bullet'><listitem><link><target>PaX</target></link><extension extension_name='ref'><template><target>cite web</target><arg name="title">PaX: Homepage of the PaX team<space/></arg><arg name="url">http://pax.grsecurity.net<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension></listitem><listitem><link><target>Exec Shield</target></link><extension extension_name='ref'><template><target>cite web</target><arg name="title">KernelTrap.Org<space/></arg><arg name="url">http://kerneltrap.org/node/644<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension></listitem><listitem><link><target>Openwall</target></link><extension extension_name='ref'><template><target>cite web</target><arg name="title">Openwall Linux kernel patch 2.4.34-ow1<space/></arg><arg name="url">http://linux.softpedia.com/get/System/Operating-Systems/Kernels/Openwall-Linux-kernel-patch-16454.shtml<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension></listitem></list><paragraph>Newer variants of Microsoft Windows also support executable space protection, called<space/><link><target>Data Execution Prevention</target></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="title">Microsoft Technet: Data Execution Prevention<space/></arg><arg name="url">http://technet2.microsoft.com/WindowsServer/en/Library/b0de1052-4101-44c3-a294-4da1bd1ef2271033.mspx?mfr</arg></template></extension><space/><link><target>proprietary software</target><part>Proprietary</part></link><space/>add-ons include:</paragraph><list type='bullet'><listitem>BufferShield<extension extension_name='ref'><template><target>cite web</target><arg name="title">BufferShield: Prevention of Buffer Overflow Exploitation for Windows<space/></arg><arg name="url">http://www.sys-manage.com/english/products/products_BufferShield.html<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension></listitem><listitem>StackDefender<extension extension_name='ref'><template><target>cite web</target><arg name="title">NGSec Stack Defender<space/></arg><arg name="url">http://www.ngsec.com/ngproducts/stackdefender/<space/></arg><arg name="accessdate">2007-06-03<space/></arg><arg name="archiveurl"><space/>http://web.archive.org/web/20070513235539/http://www.ngsec.com/ngproducts/stackdefender/<space/></arg><arg name="archivedate"><space/>2007-05-13</arg></template></extension></listitem></list><paragraph>Executable space protection does not generally protect against<space/><link><target>return-to-libc attack</target><trail>s</trail></link>, or any other attack which does not rely on the execution of the attackers code. However, on<space/><link><target>64-bit</target></link><space/>systems using<space/><link><target>ASLR</target></link>, as described below, executable space protection makes it far more difficult to execute such attacks.</paragraph><heading level='3'>Address space layout randomization</heading><paragraph><template><target>Main</target><arg>Address space layout randomization</arg></template></paragraph><paragraph>Address space layout randomization (ASLR) is a computer security feature which involves arranging the positions of key data areas, usually including the base of the executable and position of libraries, heap, and stack, randomly in a process' address space.</paragraph><paragraph>Randomization of the<space/><link><target>virtual memory</target></link><space/>addresses at which functions and variables can be found can make exploitation of a buffer overflow more difficult, but not impossible. It also forces the attacker to tailor the exploitation attempt to the individual system, which foils the attempts of<space/><link><target>internet worm</target><trail>s</trail></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="title">PaX at GRSecurity.net<space/></arg><arg name="url">http://pax.grsecurity.net/docs/aslr.txt<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension><space/>A similar but less effective method is to<space/><link><target>rebasing</target><part>rebase</part></link><space/>processes and libraries in the virtual address space.</paragraph><heading level='3'>Deep packet inspection</heading><paragraph><template><target>Main</target><arg>Deep packet inspection</arg></template></paragraph><paragraph>The use of deep packet inspection (DPI) can detect, at the network perimeter, very basic remote attempts to exploit buffer overflows by use of attack signatures and<space/><link><target>heuristic (computer science)</target><part>heuristics</part></link>. These are able to block packets which have the signature of a known attack, or if a long series of No-Operation instructions (known as a nop-sled) is detected, these were once used when the location of the exploit's<space/><link><target>payload (software)</target><part>payload</part></link><space/>is slightly variable.</paragraph><paragraph>Packet scanning is not an effective method since it can only prevent known attacks and there are many ways that a 'nop-sled' can be encoded.<space/><link><target>Shellcode</target></link><space/>used by attackers can be made<space/><link><target>alphanumeric code</target><part>alphanumeric</part></link>,<space/><link><target>metamorphic code</target><part>metamorphic</part></link>, or<space/><link><target>self-modifying code</target><part>self-modifying</part></link><space/>to evade detection by heuristic packet scanners and<space/><link><target>intrusion detection system</target><trail>s</trail></link>.</paragraph><heading level='2'>History</heading><paragraph>Buffer overflows were understood and partially publicly documented as early as 1972, when the Computer Security Technology Planning Study laid out the technique: &quot;The code performing this function does not check the source and destination addresses properly, permitting portions of the monitor to be overlaid by the user. This can be used to inject code into the monitor that will permit the user to seize control of the machine.&quot; (Page 61)<extension extension_name='ref'><template><target>cite web</target><arg name="title">Computer Security Technology Planning Study<space/></arg><arg name="url"><space/>http://csrc.nist.gov/publications/history/ande72.pdf<space/></arg><arg name="format">PDF<space/></arg><arg name="accessdate">2007-11-02</arg></template></extension><space/>Today, the monitor would be referred to as the kernel.</paragraph><paragraph>The earliest documented hostile exploitation of a buffer overflow was in 1988. It was one of several exploits used by the<space/><link><target>Morris worm</target></link><space/>to propagate itself over the Internet. The program exploited was a<space/><link><target>service (computing)</target><part>service</part></link><space/>on<space/><link><target>Unix</target></link><space/>called<space/><link><target>Finger protocol</target><part>finger</part></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="title">"A Tour of The Worm" by Donn Seeley, University of Utah<space/></arg><arg name="url">http://world.std.com/~franl/worm.html<space/></arg><arg name="accessdate">2007-06-03<space/></arg><arg name="archiveurl"><space/>http://web.archive.org/web/20070520233435/http://world.std.com/~franl/worm.html<space/></arg><arg name="archivedate"><space/>2007-05-20</arg></template></extension><space/>Later, in 1995, Thomas Lopatic independently rediscovered the buffer overflow and published his findings on the<space/><link><target>Bugtraq</target></link><space/>security mailing list.<extension extension_name='ref'><template><target>cite web</target><arg name="title">Bugtraq security mailing list archive<space/></arg><arg name="url">http://www.security-express.com/archives/bugtraq/1995_1/0403.html<space/></arg><arg name="accessdate">2007-06-03<space/></arg><arg name="archiveurl"><space/>http://web.archive.org/web/20070901222723/http://www.security-express.com/archives/bugtraq/1995_1/0403.html<space/></arg><arg name="archivedate"><space/>2007-09-01</arg></template></extension><space/>A year later, in 1996,<space/><link><target>Elias Levy</target></link><space/>(also known as Aleph One) published in<space/><italics><link><target>Phrack</target></link></italics><space/>magazine the paper &quot;Smashing the Stack for Fun and Profit&quot;,<extension extension_name='ref'><template><target>cite web</target><arg name="title">"Smashing the Stack for Fun and Profit" by Aleph One<space/></arg><arg name="url">http://www.phrack.com/issues.html?issue</arg><arg name="accessdate">2012-09-05</arg></template></extension><space/>a step-by-step introduction to exploiting stack-based buffer overflow vulnerabilities.</paragraph><paragraph>Since then, at least two major internet worms have exploited buffer overflows to compromise a large number of systems. In 2001, the<space/><link><target>Code Red worm</target></link><space/>exploited a buffer overflow in Microsoft's<space/><link><target>Internet Information Services</target></link><space/>(IIS) 5.0<extension extension_name='ref'><template><target>cite web</target><arg name="title">eEye Digital Security<space/></arg><arg name="url">http://research.eeye.com/html/advisories/published/AL20010717.html<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension><space/>and in 2003 the<space/><link><target>SQL Slammer</target></link><space/>worm compromised machines running<space/><link><target>Microsoft SQL Server 2000</target></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="title">Microsoft Technet Security Bulletin MS02-039<space/></arg><arg name="url">http://www.microsoft.com/technet/security/bulletin/ms02-039.mspx<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension></paragraph><paragraph>In 2003, buffer overflows present in licensed<space/><link><target>Xbox (console)</target><part>Xbox</part></link><space/>games have been exploited to allow unlicensed software, including<space/><link><target>homebrew (video games)</target><part>homebrew games</part></link>, to run on the console without the need for hardware modifications, known as<space/><link><target>modchip</target><trail>s</trail></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.gamesindustry.biz/content_page.php?aid</arg><arg name="archiveurl">http://web.archive.org/web/20070927210513/http://www.gamesindustry.biz/content_page.php?aid</arg><arg name="archivedate">2007-09-27<space/></arg><arg name="title">Hacker breaks Xbox protection without mod-chip<space/></arg><arg name="accessdate">2007-06-03</arg></template></extension><space/>The<space/><link><target>PS2 Independence Exploit</target></link><space/>also used a buffer overflow to achieve the same for the<space/><link><target>PlayStation 2</target></link>. The<space/><link><target>Twilight hack</target></link><space/>accomplished the same with the<space/><link><target>Wii</target></link>, using a buffer overflow in<space/><italics><link><target>The Legend of Zelda: Twilight Princess</target></link></italics>.</paragraph><heading level='2'>See also</heading><paragraph><template><target>Portal</target><arg>Software Testing</arg><arg>Computer Science</arg></template><template><target>colbegin</target><arg name="colwidth">20em</arg></template></paragraph><list type='bullet'><listitem><link><target>Billion laughs</target></link></listitem><listitem><link><target>Buffer over-read</target></link></listitem><listitem><link><target>Computer security</target></link></listitem><listitem><link><target>End-of-file</target></link></listitem><listitem><link><target>Heap overflow</target></link></listitem><listitem><link><target>Ping of death</target></link></listitem><listitem><link><target>Port scanner</target></link></listitem><listitem><link><target>Return-to-libc attack</target></link></listitem><listitem><link><target>Security-focused operating system</target></link></listitem><listitem><link><target>Self-modifying code</target></link></listitem><listitem><link><target>Shellcode</target></link></listitem><listitem><link><target>Stack buffer overflow</target></link></listitem><listitem><link><target>Uncontrolled format string</target></link></listitem></list><paragraph><template><target>colend</target></template></paragraph><heading level='2'>References</heading><paragraph><template><target>Reflist</target><arg name="colwidth">30em</arg><arg name="refs">
<ref name</arg></template></paragraph><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://raykoid666.wordpress.com/2009/11/28/remote-buffer-overflow-from-vulnerability-to-exploit-part-1/'>&quot;Discovering and exploiting a remote buffer overflow vulnerability in an FTP server&quot;</link><space/>by Raykoid666</listitem><listitem><link type='external' href='http://phrack.org/issues/49/14.html#article'>&quot;Smashing the Stack for Fun and Profit&quot;</link><space/>by Aleph One</listitem><listitem><link type='external' href='http://iac.dtic.mil/iatac/download/Vol7_No4.pdf'>An Overview and Example of the Buffer-Overflow Exploit. pps. 16-21.</link></listitem><listitem><link type='external' href='https://www.securecoding.cert.org/'>CERT Secure Coding Standards</link></listitem><listitem><link type='external' href='http://www.cert.org/secure-coding'>CERT Secure Coding Initiative</link></listitem><listitem><link type='external' href='http://www.cert.org/books/secure-coding'>Secure Coding in C and C++</link></listitem><listitem><link type='external' href='http://www.sans.org/reading_room/whitepapers/securecode/386.php'>SANS: inside the buffer overflow attack</link></listitem><listitem><link type='external' href='http://www.awarenetwork.org/etc/alpha/?x=5'>&quot;Advances in adjacent memory overflows&quot;</link><space/>by Nomenumbra</listitem><listitem><link type='external' href='http://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf'>A Comparison of Buffer Overflow Prevention Implementations and Weaknesses</link></listitem><listitem><link type='external' href='http://doc.bughunter.net/buffer-overflow/'>More Security Whitepapers about Buffer Overflows</link><template><target>dead link</target><arg name="date">November 2013</arg></template></listitem><listitem><link type='external' href='http://www.syngress.com/book_catalog/327_SSPC/sample.pdf'>Chapter 12: Writing Exploits III</link><template><target>dead link</target><arg name="date">March 2012</arg></template><space/>from<space/><italics>Sockets, Shellcode, Porting &amp; Coding: Reverse Engineering Exploits and Tool Coding for Security Professionals</italics><space/>by James C. Foster (ISBN 1-59749-005-9). Detailed explanation of how to use Metasploit to develop a buffer overflow exploit from scratch.</listitem><listitem><link type='external' href='http://csrc.nist.gov/publications/history/ande72.pdf'>Computer Security Technology Planning Study</link>, James P. Anderson, ESD-TR-73-51, ESD/AFSC, Hanscom AFB, Bedford, MA 01731 (October 1972) [NTIS AD-758 206]</listitem><listitem><link type='external' href='https://www.exploit-db.com/download_pdf/18346'>&quot;Buffer Overflows: Anatomy of an Exploit&quot;</link><space/>by Nevermore</listitem><listitem><link type='external' href='https://cansecwest.com/csw08/csw08-holtmann.pdf'>Secure Programming with GCC and GLibc</link><space/>(2008), by Marcel Holtmann</listitem></list><paragraph><template><target>Memory management navbox</target></template></paragraph><paragraph><template><target>Authority control</target></template><template><target>DEFAULTSORT:Buffer Overflow</target></template><link><target>Category:Software bugs</target></link><link><target>Category:Computer memory</target></link><link><target>Category:Computer security exploits</target></link></paragraph><paragraph><link><target>ar:</target></link></paragraph></article>