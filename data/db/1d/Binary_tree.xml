<article title='Binary_tree'><paragraph><template><target>distinguish</target><arg>B-tree</arg></template><link><target>Image:binary tree.svg</target><part>right</part><part>192px</part><part>thumb</part><part>A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted.</part></link></paragraph><paragraph>In<space/><link><target>computer science</target></link>, a<space/><bold>binary tree</bold><space/>is a<space/><link><target>tree structure</target><part>tree</part></link><space/><link><target>data structure</target></link><space/>in which each node has at most two<space/><link><target>child node</target><part>children</part></link>, which are referred to as the<space/><italics>left</italics><space/>child and the<space/><italics>right</italics><space/>child. A<space/><link><target>recursive definition</target></link><space/>using just<space/><link><target>set theory</target></link><space/>notions is that a (non-empty) binary tree is a<space/><link><target>tuple</target><part>triple</part></link><space/>(<italics>L</italics>,<space/><italics>S</italics>,<space/><italics>R</italics>), where<space/><italics>L</italics><space/>and<space/><italics>R</italics><space/>are binary trees or the<space/><link><target>empty set</target></link><space/>and<space/><italics>S</italics><space/>is a<space/><link><target>singleton set</target></link>.<extension extension_name='ref' name="GarnierTaylor2009"><template><target>cite book</target><arg name="author1">Rowan Garnier</arg><arg name="author2">John Taylor</arg><arg name="title">Discrete Mathematics: Proofs, Structures and Applications, Third Edition</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">2009</arg><arg name="publisher">CRC Press</arg><arg name="isbn">978-1-4398-1280-8</arg><arg name="page">620</arg></template></extension><space/>Some authors allow the binary tree to be the empty set as well.<extension extension_name='ref' name="Skiena2009"><template><target>cite book</target><arg name="author">Steven S Skiena</arg><arg name="title">The Algorithm Design Manual</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">2009</arg><arg name="publisher">Springer Science & Business Media</arg><arg name="isbn">978-1-84800-070-4</arg><arg name="page">77</arg></template></extension></paragraph><paragraph>From a<space/><link><target>graph theory</target></link><space/>perspective, binary (and K-ary) trees as defined here are actually<space/><link><target>Arborescence (graph theory)</target><part>arborescences</part></link>.<extension extension_name='ref' name="Knuth1997"><template><target>cite book</target><arg name="author">Knuth</arg><arg name="title">The Art Of Computer Programming, Volume 1, 3/E</arg><arg name="year">1997</arg><arg name="publisher">Pearson Education</arg><arg name="isbn">0-201-89683-4</arg><arg name="page">363</arg></template></extension><space/>A binary tree may thus be also called a<space/><bold>bifurcating arborescence</bold><extension extension_name='ref' name="Knuth1997"></extension>a term which actually appears in some very old programming books,<extension extension_name='ref' name="Flores1971"><template><target>cite book</target><arg name="author">Iván Flores</arg><arg name="title">Computer programming system/360</arg><arg name="year">1971</arg><arg name="publisher">Prentice-Hall</arg><arg name="page">39</arg></template></extension><space/>before the modern computer science terminology prevailed. It is also possible to interpret a binary tree as an<space/><link><target>undirected graph</target><part>undirected</part></link>, rather than a<space/><link><target>directed graph</target></link>, in which case a binary tree is an<space/><link><target>ordered tree</target><part>ordered</part></link>,<space/><link><target>rooted tree</target></link>.<extension extension_name='ref'><template><target>cite book</target><arg name="author">Kenneth Rosen</arg><arg name="title">Discrete Mathematics and Its Applications, 7th edition</arg><arg name="year">2011</arg><arg name="publisher">McGraw-Hill Science</arg><arg name="page">749</arg><arg name="isbn">978-0-07-338309-5</arg></template></extension><space/>Some authors use<space/><bold>rooted binary tree</bold><space/>instead of<space/><italics>binary tree</italics><space/>to emphasize the fact that the tree is rooted, but as defined above, a binary tree is always rooted.<extension extension_name='ref' name="Mazur2010"><template><target>cite book</target><arg name="author">David R. Mazur</arg><arg name="title">Combinatorics: A Guided Tour</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">2010</arg><arg name="publisher">Mathematical Association of America</arg><arg name="isbn">978-0-88385-762-5</arg><arg name="page">246</arg></template></extension><space/>A binary tree is a special case of an ordered<space/><link><target>K-ary tree</target></link>, where<space/><italics>k</italics><space/>is 2.</paragraph><paragraph>In computing, binary trees are seldom used solely for their structure. Much more typical is to define a labeling function on the nodes, which associates some value to each node.<extension extension_name='ref' name="Makinson2009b"><template><target>cite book</target><arg name="author">David Makinson</arg><arg name="title">Sets, Logic and Maths for Computing</arg><arg name="year">2009</arg><arg name="publisher">Springer Science & Business Media</arg><arg name="isbn">978-1-84628-845-6</arg><arg name="page">199</arg></template></extension><space/>Binary trees labelled this way are used to implement<space/><link><target>binary search tree</target><trail>s</trail></link><space/>and<space/><link><target>binary heap</target><trail>s</trail></link>, and are used for efficient<space/><link><target>search algorithm</target><part>searching</part></link><space/>and<space/><link><target>Sorting algorithm</target><part>sorting</part></link>. The designation of non-root nodes as left or right child even when there is only one child present matters in some of these applications, in particular it is significant in binary search trees.<extension extension_name='ref' name="Gross2007"><template><target>cite book</target><arg name="author">Jonathan L. Gross</arg><arg name="title">Combinatorial Methods with Computer Applications</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">2007</arg><arg name="publisher">CRC Press</arg><arg name="isbn">978-1-58488-743-0</arg><arg name="page">248</arg></template></extension><space/>In mathematics, what is termed<space/><italics>binary tree</italics><space/>can vary significantly from author to author. Some use the definition commonly used in computer science,<extension extension_name='ref' name="oem"></extension><space/>but others define it as every non-leaf having exactly two children and don't necessarily order (as left/right) the children either.<extension extension_name='ref' name="Foulds1992"><template><target>cite book</target><arg name="author">L.R. Foulds</arg><arg name="title">Graph Theory Applications</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">1992</arg><arg name="publisher">Springer Science & Business Media</arg><arg name="isbn">978-0-387-97599-3</arg><arg name="page">32</arg></template></extension></paragraph><heading level='2'>Definitions</heading><heading level='3'>Recursive definition</heading><paragraph><template><target>cleanup-rewrite</target><arg>section</arg><arg name="date">July 2014</arg></template>Another way of defining a<space/><italics>full</italics><space/>binary tree is a<space/><link><target>recursive definition</target></link>. A full binary tree is either:<extension extension_name='ref' name="Rosen2011"><template><target>cite book</target><arg name="author">Kenneth Rosen</arg><arg name="title">Discrete Mathematics and Its Applications 7th edition</arg><arg name="year">2011</arg><arg name="publisher">McGraw-Hill Science</arg><arg name="pages">352–353</arg><arg name="isbn">978-0-07-338309-5</arg></template></extension></paragraph><list type='bullet'><listitem>A single vertex.</listitem><listitem>A graph formed by taking two (full) binary trees, adding a vertex, and adding an edge directed from the new vertex to the root of each binary tree.</listitem></list><paragraph>This also does not establish the order of children, but does fix a specific root node.</paragraph><paragraph>To actually define a binary tree in general, we must allow for the possibility that only one of children may be empty. An artifact, which in some textbooks is called an<space/><italics>extended binary tree</italics><space/>is needed for that purpose. An extended binary tree is thus recursively defined as:<extension extension_name='ref' name="Rosen2011"></extension></paragraph><list type='bullet'><listitem>the<space/><link><target>empty set</target></link><space/>is an extended binary tree</listitem><listitem>if T<xhtml:sub>1</xhtml:sub><space/>and T<xhtml:sub>2</xhtml:sub><space/>are extended binary trees, then denote by T<xhtml:sub>1</xhtml:sub><space/>T<xhtml:sub>2</xhtml:sub><space/>the extended binary tree obtained by adding a root<space/><italics>r</italics><space/>connected to the left to T<xhtml:sub>1</xhtml:sub><space/>and to the right to T<xhtml:sub>2</xhtml:sub><space/>by adding edges when these sub-trees are non-empty.</listitem></list><paragraph>Another way of imagining this construction (and understanding the terminology) is to consider instead of the empty set a different type of nodefor instance square nodes if the regular ones are circles.<extension extension_name='ref' name="HuShing2002"><template><target>cite book</target><arg name="author1">Te Chiang Hu</arg><arg name="author2">Man-tak Shing</arg><arg name="title">Combinatorial Algorithms</arg><arg name="year">2002</arg><arg name="publisher">Courier Dover Publications</arg><arg name="isbn">978-0-486-41962-6</arg><arg name="page">162</arg></template></extension></paragraph><heading level='3'>Using graph theory concepts</heading><paragraph>A binary tree is a<space/><link><target>rooted tree</target></link><space/>that is also an<space/><link><target>ordered tree</target></link><space/>(a.k.a. plane tree) in which every node has at most two children. A rooted tree naturally imparts a notion of levels (distance from the root), thus for every node a notion of children may be defined as the nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes possible to distinguish left child from right child.<extension extension_name='ref' name="HsuLin2008"><template><target>cite book</target><arg name="author1">Lih-Hsing Hsu</arg><arg name="author2">Cheng-Kuan Lin</arg><arg name="title">Graph Theory and Interconnection Networks</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">2008</arg><arg name="publisher">CRC Press</arg><arg name="isbn">978-1-4200-4482-9</arg><arg name="page">66</arg></template></extension><space/>But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child.</paragraph><paragraph>The necessary distinction can be made by first partitioning the edges, i.e., defining the binary tree as triplet (V, E<xhtml:sub>1</xhtml:sub>, E<xhtml:sub>2</xhtml:sub>), where (V, E<xhtml:sub>1</xhtml:sub><space/>E<xhtml:sub>2</xhtml:sub>) is a rooted tree (equivalently arborescence) and E<xhtml:sub>1</xhtml:sub><space/>E<xhtml:sub>2</xhtml:sub><space/>is empty, and also requiring that for all<space/><italics>j</italics><space/>{ 1, 2 } every node has at most one E<xhtml:sub><italics>j</italics></xhtml:sub><space/>child.<extension extension_name='ref' name="FlumGrohe2006"><template><target>cite book</target><arg name="author1">J. Flum</arg><arg name="author2">M. Grohe</arg><arg name="title">Parameterized Complexity Theory</arg><arg name="year">2006</arg><arg name="publisher">Springer</arg><arg name="isbn">978-3-540-29953-0</arg><arg name="page">245</arg></template></extension><space/>A more informal way of making the distinction is to say, quoting the<space/><link><target>Encyclopedia of Mathematics</target></link>, that &quot;every node has a left child, a right child, neither, or both&quot; and to specify that these &quot;are all different&quot; binary trees.<extension extension_name='ref' name="oem"><template><target>SpringerEOM</target><arg name="id">Binary_tree&oldid</arg><arg name="title">Binary tree</arg></template><space/>also in print as<space/><template><target>cite book</target><arg name="author">Michiel Hazewinkel</arg><arg name="title">Encyclopaedia of Mathematics. Supplement I</arg><arg name="url">http://books.google.com/books?id</arg><arg name="year">1997</arg><arg name="publisher">Springer Science & Business Media</arg><arg name="isbn">978-0-7923-4709-5</arg><arg name="page">124</arg></template></extension></paragraph><heading level='2'>Types of binary trees</heading><paragraph>Tree terminology is not well-standardized and so varies in the literature.</paragraph><list type='bullet'><listitem>A<space/><bold>rooted</bold><space/>binary<space/><link><target>tree data structure</target><part>tree</part></link><space/>has a<space/><link><target>root node</target></link><space/>and every node has at most two children.</listitem><listitem>A<space/><bold>full</bold><space/>binary tree (sometimes referred to as a<space/><bold>proper</bold><extension extension_name='ref'><template><target>cite book</target><arg name="last1">Tamassia</arg><arg name="first1">Michael T. Goodrich, Roberto</arg><arg name="title">Algorithm design : foundations, analysis, and Internet examples</arg><arg name="date">2011</arg><arg name="publisher">Wiley-India</arg><arg name="location">New Delhi</arg><arg name="isbn">978-81-265-0986-7</arg><arg name="page">76</arg><arg name="edition">2</arg><arg name="ref">Goodrich</arg></template></extension><space/>or<space/><bold>plane</bold><space/>binary tree)<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://xlinux.nist.gov/dads//HTML/fullBinaryTree.html<space/></arg><arg name="title">full binary tree<space/></arg><arg name="publisher"><space/>[[NIST]]</arg></template></extension><extension extension_name='ref'>Richard Stanley, Enumerative Combinatorics, volume 2, p.36</extension><space/>is a tree in which every node in the tree has either 0 or 2 children.</listitem></list><paragraph><link><target>File:Waldburg Ahnentafel.jpg</target><part>thumb</part><part>An<space/><link><target>ancestry chart</target></link><space/>which maps to a perfect depth-4 binary tree.</part></link></paragraph><list type='bullet'><listitem>A<space/><bold><template><target>visible anchor</target><arg>perfect</arg></template></bold><space/>binary tree is a binary tree in which all interior nodes have two children<space/><italics>and</italics><space/>all leaves have the same<space/><italics>depth</italics><space/>or same<space/><italics>level</italics>.<extension extension_name='ref'><template><target>cite web</target><arg name="url">http://www.nist.gov/dads/HTML/perfectBinaryTree.html</arg><arg name="title">perfect binary tree<space/></arg><arg name="publisher"><space/>[[NIST]]</arg></template></extension><space/>(This is ambiguously also called a<space/><bold>complete</bold><space/>or<space/><bold>full</bold><space/>binary tree.<template><target>cn</target><arg name="date">March 2015</arg></template>) An example of a perfect binary tree is the<space/><link><target>ancestry chart</target></link><space/>of a person to a given depth, as each person has exactly two biological parents (one mother and one father).</listitem><listitem>In a<space/><bold><template><target>visible anchor</target><arg>complete</arg></template></bold><space/>binary tree every level,<space/><italics>except possibly the last</italics>, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2<xhtml:sup><italics>h</italics></xhtml:sup><space/>nodes at the last level<space/><italics>h</italics>.<extension extension_name='ref' name="complete binary tree"><template><target>cite web</target><arg name="url">http://www.nist.gov/dads/HTML/completeBinaryTree.html</arg><arg name="title">complete binary tree</arg><arg name="publisher"><space/>NIST</arg></template></extension><space/>An alternative definition is a perfect tree whose rightmost leaves (perhaps all) have been removed. A binary tree is called an<space/><bold>almost complete</bold><space/>binary tree or<space/><bold>nearly complete</bold><space/>binary tree if the last level is not completely filled.<template><target>clarify</target><arg>According to this text, a "nearly complete" binary tree is in fact "complete."</arg><arg name="date">March 2015</arg></template><space/>A complete binary tree is used as a specialized data structure called a<space/><link><target>binary heap</target></link>.<extension extension_name='ref' name="complete binary tree"></extension></listitem><listitem>In the<space/><bold>infinite complete</bold><space/>binary tree, every node has two children (and so the set of levels is<space/><link><target>countably infinite</target></link>). The set of all nodes is countably infinite, but the set of all infinite paths from the root is uncountable, having the<space/><link><target>cardinality of the continuum</target></link>. These paths correspond by an order-preserving<space/><link><target>bijection</target></link><space/>to the points of the<space/><link><target>Cantor set</target></link>, or (using the example of a<space/><link><target>SternBrocot tree</target></link>) to the set of positive<space/><link><target>irrational number</target><trail>s</trail></link>.</listitem><listitem>A<space/><bold>balanced</bold><space/>binary tree has the minimum possible<space/><link><target>Binary tree#Properties of binary trees</target><part>maximum height</part></link><space/>(a.k.a. depth) for the leaf nodes, because for any given number of leaf nodes the leaf nodes are placed at the greatest height possible.<template><target>clarify</target><arg name="date">March 2015</arg></template></listitem></list><paragraph><xhtml:tt><list type='ident'><listitem>&amp;nbsp;<bold>h</bold>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bold>Balanced</bold>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<bold>Unbalanced,&amp;nbsp;h&amp;nbsp;=&amp;nbsp;(n&amp;nbsp;+&amp;nbsp;1)/2&amp;nbsp;-&amp;nbsp;1</bold></listitem><listitem>&amp;nbsp;0:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ABCDE&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ABCDE</listitem><listitem>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\</listitem><listitem>&amp;nbsp;1:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ABCD&amp;nbsp;&amp;nbsp;&amp;nbsp;E&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ABCD&amp;nbsp;&amp;nbsp;&amp;nbsp;E</listitem><listitem>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\</listitem><listitem>&amp;nbsp;2:&amp;nbsp;&amp;nbsp;AB&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CD&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ABC&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;D</listitem><listitem>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;\&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;\&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;&amp;nbsp;\</listitem><listitem>&amp;nbsp;3:&amp;nbsp;A&amp;nbsp;&amp;nbsp;B&amp;nbsp;&amp;nbsp;C&amp;nbsp;&amp;nbsp;D&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;AB&amp;nbsp;&amp;nbsp;&amp;nbsp;C</listitem><listitem>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/&amp;nbsp;&amp;nbsp;\</listitem><listitem>&amp;nbsp;4:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A&amp;nbsp;&amp;nbsp;&amp;nbsp;B</listitem></list></xhtml:tt></paragraph><list type='ident'><listitem>One common balanced tree structure is a binary tree structure in which the left and right subtrees of every node differ in height by no more than 1.<extension extension_name='ref'>Aaron M. Tenenbaum, et al. Data Structures Using C, Prentice Hall, 1990 ISBN 0-13-199746-7</extension><space/>One may also consider binary trees where no leaf is much farther away from the root than any other leaf. (Different balancing schemes allow different definitions of &quot;much farther&quot;.<extension extension_name='ref'>Paul E. Black (ed.), entry for<space/><italics>data structure</italics><space/>in ''<link><target>Dictionary of Algorithms and Data Structures</target></link>. U.S.<space/><link><target>National Institute of Standards and Technology</target></link>. 15 December 2004.<space/><link type='external' href='http://xw2k.nist.gov/dads//HTML/balancedtree.html'>Online version</link><space/>Accessed 2010-12-19.</extension>)</listitem></list><list type='bullet'><listitem>A<space/><bold>degenerate</bold><space/>(or<space/><bold>pathological</bold>) tree is where each parent node has only one associated child node.<template><target>cn</target><arg name="date">March 2015</arg></template><space/>This means that performance-wise<template><target>clarify</target><arg name="date">March 2015</arg></template>, the tree will behave like a<space/><link><target>linked list</target></link><space/>data structure.</listitem></list><heading level='2'>Properties of binary trees</heading><list type='bullet'><listitem>The number of nodes<space/><extension extension_name='math'>n</extension><space/>in a full binary tree, is at least<space/><extension extension_name='math'>n = 2h+1</extension><space/>and at most<space/><extension extension_name='math'>n = 2^{h+1} - 1</extension>, where<space/><extension extension_name='math'>h</extension><space/>is the height of the tree. A tree consisting of only a root node has a height of 0.</listitem><listitem>The number of leaf nodes<space/><extension extension_name='math'>l</extension><space/>in a perfect binary tree, is<space/><extension extension_name='math'>l = (n + 1) / 2</extension><space/>because the number of non-leaf (a.k.a. internal) nodes<space/><extension extension_name='math'>n - l = \sum_{k=0}^{\log_2(l)-1} 2^k = 2^{\log_2(l)} - 1 = l - 1</extension>.</listitem><listitem>This means that a perfect binary tree with<space/><extension extension_name='math'>l</extension><space/>leaves has<space/><extension extension_name='math'>n = 2l - 1</extension><space/>nodes.</listitem><listitem>In a<space/><bold>balanced</bold><space/>full binary tree,<space/><extension extension_name='math'>h = \lceil \log_2(l)\rceil + 1 = \lceil \log_2((n + 1) / 2)\rceil + 1 = \lceil \log_2(n + 1)\rceil</extension><space/>(see<space/><link><target>Floor and ceiling functions</target><part>ceiling function</part></link>).</listitem><listitem>In a<space/><bold>perfect</bold><space/>full binary tree,<space/><extension extension_name='math'>l = 2^{h}</extension><space/>thus<space/><extension extension_name='math'>n = 2^{h+1} - 1</extension>.</listitem><listitem>The maximum possible number of null links (i.e., absent children of the nodes) in a<space/><bold>complete</bold><space/>binary tree of<space/><italics>n</italics><space/>nodes is (<italics>n</italics>+1), where only 1 node exists in bottom-most level to the far left.</listitem><listitem>The number of internal nodes in a<space/><bold>complete</bold><space/>binary tree of<space/><italics>n</italics><space/>nodes is<space/><extension extension_name='math'>\lfloor n/2\rfloor<space/></extension>.</listitem><listitem>For any non-empty binary tree with<space/><italics>n</italics><xhtml:sub>0</xhtml:sub><space/>leaf nodes and<space/><italics>n</italics><xhtml:sub>2</xhtml:sub><space/>nodes of degree 2,<space/><italics>n</italics><xhtml:sub>0</xhtml:sub><space/>=<space/><italics>n</italics><xhtml:sub>2</xhtml:sub><space/>+ 1.<extension extension_name='ref'><template><target>cite book</target><arg name="last">Mehta<space/></arg><arg name="first">Dinesh<space/></arg><arg name="author2">Sartaj Sahni<space/></arg><arg name="title">Handbook of Data Structures and Applications</arg><arg name="publisher">[[Chapman and Hall]]</arg><arg name="isbn"><space/>1-58488-435-5</arg><arg name="year">2004<space/></arg><arg name="authorlink2">Sartaj Sahni<space/></arg></template></extension></listitem></list><heading level='2'>Combinatorics</heading><paragraph><template><target>unreferenced section</target><arg name="date">July 2014</arg></template>In<space/><link><target>combinatorics</target></link><space/>one considers the problem of counting the number of full binary trees of a given size. Here the trees have no values attached to their nodes (this would just multiply the number of possible trees by an easily determined factor), and trees are distinguished only by their structure; however the left and right child of any node are distinguished (if they are different trees, then interchanging them will produce a tree distinct from the original one). The size of the tree is taken to be the number<space/><italics>n</italics><space/>of internal nodes (those with two children); the other nodes are leaf nodes and there are<space/><template><target>nowrap</target><arg>''n'' + 1</arg></template><space/>of them. The number of such binary trees of size<space/><italics>n</italics><space/>is equal to the number of ways of fully parenthesizing a string of<space/><template><target>nowrap</target><arg>''n'' + 1</arg></template><space/>symbols (representing leaves) separated by<space/><italics>n</italics><space/>binary operators (representing internal nodes), so as to determine the argument subexpressions of each operator. For instance for<space/><template><target>nowrap</target><arg name="''n'' {{">}} 3</arg></template><space/>one has to parenthesize a string like<space/><template><target>nowrap</target><arg><space/><math>X*X*X*X</math></arg></template>, which is possible in five ways:</paragraph><list type='ident'><listitem><extension extension_name='math'>((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X)).</extension></listitem></list><paragraph>The correspondence to binary trees should be obvious, and the addition of redundant parentheses (around an already parenthesized expression or around the full expression) is disallowed (or at least not counted as producing a new possibility).</paragraph><paragraph>There is a unique binary tree of size 0 (consisting of a single leaf), and any other binary tree is characterized by the pair of its left and right children; if these have sizes<space/><italics>i</italics><space/>and<space/><italics>j</italics><space/>respectively, the full tree has size<space/><template><target>nowrap</target><arg>''i'' + ''j'' + 1</arg></template>. Therefore the number<space/><extension extension_name='math'>C_n</extension><space/>of binary trees of size<space/><italics>n</italics><space/>has the following recursive description<space/><extension extension_name='math'>C_0=1</extension>, and<space/><extension extension_name='math'>\textstyle C_n=\sum_{i=0}^{n-1}C_iC_{n-1-i}</extension><space/>for any positive integer<space/><italics>n</italics>. It follows that<space/><extension extension_name='math'>C_n</extension><space/>is the<space/><link><target>Catalan number</target></link><space/>of index<space/><italics>n</italics>.</paragraph><paragraph>The above parenthesized strings should not be confused with the set of words of length 2<italics>n</italics><space/>in the<space/><link><target>Dyck language</target></link>, which consist only of parentheses in such a way that they are properly balanced. The number of such strings satisfies the same recursive description (each Dyck word of length 2<italics>n</italics><space/>is determined by the Dyck subword enclosed by the initial '(' and its matching ')' together with the Dyck subword remaining after that closing parenthesis, whose lengths 2<italics>i</italics><space/>and 2<italics>j</italics><space/>satisfy<space/><template><target>nowrap</target><arg name="''i'' + ''j'' + 1 {{">}} ''n''</arg></template>); this number is therefore also the Catalan number<space/><extension extension_name='math'>C_n</extension>. So there are also five Dyck words of length 10:</paragraph><list type='ident'><listitem><extension extension_name='math'>()()(),\qquad ()(()),\qquad (())(),\qquad (()()),\qquad ((()))</extension>.</listitem></list><paragraph>These Dyck words do not correspond in an obvious way to binary trees. A bijective correspondence can nevertheless be defined as follows: enclose the Dyck word in an extra pair of parentheses, so that the result can be interpreted as a<space/><link><target>Lisp (programming language)</target><part>Lisp</part></link><space/>list expression (with the empty list () as only occurring atom); then the<space/><link><target>Lisp (programming language)#S-expressions represent lists</target><part>dotted-pair</part></link><space/>expression for that proper list is a fully parenthesized expression (with NIL as symbol and '.' as operator) describing the corresponding binary tree (which is in fact the internal representation of the proper list).</paragraph><paragraph>The ability to represent binary trees as strings of symbols and parentheses implies that binary trees can represent the elements of a<space/><link><target>free magma</target></link><space/>on a singleton set.</paragraph><heading level='2'>Methods for storing binary trees</heading><paragraph>Binary trees can be constructed from<space/><link><target>programming language</target></link><space/>primitives in several ways.</paragraph><heading level='3'>Nodes and references</heading><paragraph>In a language with<space/><link><target>record (computer science)</target><part>records</part></link><space/>and<space/><link><target>reference (computer science)</target><part>references</part></link>, binary trees are typically constructed by having a tree node structure which contains some data and references to its left child and its right child. Sometimes it also contains a reference to its unique parent. If a node has fewer than two children, some of the child pointers may be set to a special null value, or to a special<space/><link><target>sentinel node</target></link>.</paragraph><paragraph>This method of storing binary trees wastes a fair bit of memory, as the pointers will be null (or point to the sentinel) more than half the time; a more conservative representation alternative is<space/><link><target>threaded binary tree</target></link>.<extension extension_name='ref' name="Samanta2004"><template><target>cite book</target><arg name="author">D. Samanta</arg><arg name="title">Classic Data Structures</arg><arg name="year">2004</arg><arg name="publisher">PHI Learning Pvt. Ltd.</arg><arg name="isbn">978-81-203-1874-8</arg><arg name="pages">264–265</arg></template></extension></paragraph><paragraph>In languages with<space/><link><target>tagged union</target><trail>s</trail></link><space/>such as<space/><link><target>ML (programming language)</target><part>ML</part></link>, a tree node is often a tagged union of two types of nodes, one of which is a 3-tuple of data, left child, and right child, and the other of which is a &quot;leaf&quot; node, which contains no data and functions much like the null value in a language with pointers. For example, the following line of code in<space/><link><target>OCaml</target></link><space/>(an ML dialect) defines a binary tree that stores a character in each node.<extension extension_name='ref' name="Scott2009"><template><target>cite book</target><arg name="author">Michael L. Scott</arg><arg name="title">Programming Language Pragmatics</arg><arg name="year">2009</arg><arg name="publisher">Morgan Kaufmann</arg><arg name="isbn">978-0-08-092299-7</arg><arg name="page">347</arg><arg name="edition">3rd</arg></template></extension></paragraph><preblock><preline><extension extension_name='source' lang="ocaml">type chr_tree = Empty | Node of char * chr_tree * chr_tree</extension></preline></preblock><heading level='3'>Arrays</heading><paragraph>Binary trees can also be stored in breadth-first order as an<space/><link><target>implicit data structure</target></link><space/>in<space/><link><target>array data structure</target><part>arrays</part></link>, and if the tree is a complete binary tree, this method wastes no space. In this compact arrangement, if a node has an index<space/><italics>i</italics>, its children are found at indices<space/><extension extension_name='math'>2i + 1</extension><space/>(for the left child) and<space/><extension extension_name='math'>2i +2</extension><space/>(for the right), while its parent (if any) is found at index<space/><italics><extension extension_name='math'>\left \lfloor \frac{i-1}{2} \right \rfloor</extension></italics><space/>(assuming the root has index zero). This method benefits from more compact storage and better<space/><link><target>locality of reference</target></link>, particularly during a preorder traversal. However, it is expensive to grow and wastes space proportional to 2<xhtml:sup><italics>h</italics></xhtml:sup><space/>-<space/><italics>n</italics><space/>for a tree of depth<space/><italics>h</italics><space/>with<space/><italics>n</italics><space/>nodes.</paragraph><paragraph>This method of storage is often used for<space/><link><target>binary heap</target><trail>s</trail></link>. No space is wasted because nodes are added in breadth-first order.</paragraph><paragraph><xhtml:center><link><target>Image:Binary tree in array.svg</target><part>300px</part><part>A small complete binary tree stored in an array</part></link></xhtml:center></paragraph><heading level='2'>Encodings</heading><heading level='3'>Succinct encodings</heading><paragraph>A<space/><link><target>succinct data structure</target></link><space/>is one which occupies close to minimum possible space, as established by<space/><link><target>information theory</target><part>information theoretical</part></link><space/>lower bounds. The number of different binary trees on<space/><extension extension_name='math'>n</extension><space/>nodes is<space/><extension extension_name='math'>\mathrm{C}_{n}</extension>, the<space/><extension extension_name='math'>n</extension>th<space/><link><target>Catalan number</target></link><space/>(assuming we view trees with identical<space/><italics>structure</italics><space/>as identical). For large<space/><extension extension_name='math'>n</extension>, this is about<space/><extension extension_name='math'>4^{n}</extension>; thus we need at least about<space/><extension extension_name='math'>\log_{2}4^{n} = 2n</extension><space/>bits to encode it. A succinct binary tree therefore would occupy<space/><extension extension_name='math'>2n+o(n)</extension><space/>bits.</paragraph><paragraph>One simple representation which meets this bound is to visit the nodes of the tree in preorder, outputting &quot;1&quot; for an internal node and &quot;0&quot; for a leaf.<space/><link type='external' href='http://theory.csail.mit.edu/classes/6.897/spring03/scribe_notes/L12/lecture12.pdf'></link><space/>If the tree contains data, we can simply simultaneously store it in a consecutive array in preorder. This function accomplishes this:</paragraph><preblock><preline><bold>function</bold><space/>EncodeSuccinct(<italics>node</italics><space/>n,<space/><italics>bitstring</italics><space/>structure,<space/><italics>array</italics><space/>data) {</preline><preline><space/><space/><space/><space/><bold>if</bold><space/>n =<space/><italics>nil</italics><space/><bold>then</bold></preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>append 0 to structure;</preline><preline><space/><space/><space/><space/><bold>else</bold></preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>append 1 to structure;</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>append n.data to data;</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>EncodeSuccinct(n.left, structure, data);</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>EncodeSuccinct(n.right, structure, data);</preline><preline>}</preline></preblock><paragraph>The string<space/><italics>structure</italics><space/>has only<space/><extension extension_name='math'>2n + 1</extension><space/>bits in the end, where<space/><extension extension_name='math'>n</extension><space/>is the number of (internal) nodes; we don't even have to store its length. To show that no information is lost, we can convert the output back to the original tree like this:</paragraph><preblock><preline><bold>function</bold><space/>DecodeSuccinct(<italics>bitstring</italics><space/>structure,<space/><italics>array</italics><space/>data) {</preline><preline><space/><space/><space/><space/>remove first bit of<space/><italics>structure</italics><space/>and put it in<space/><italics>b</italics></preline><preline><space/><space/><space/><space/><bold>if</bold><space/>b = 1<space/><bold>then</bold></preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>create a new node<space/><italics>n</italics></preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>remove first element of data and put it in n.data</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>n.left = DecodeSuccinct(structure, data)</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/>n.right = DecodeSuccinct(structure, data)</preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><bold>return</bold><space/>n</preline><preline><space/><space/><space/><space/><bold>else</bold></preline><preline><space/><space/><space/><space/><space/><space/><space/><space/><bold>return</bold><space/>nil</preline><preline>}</preline></preblock><paragraph>More sophisticated succinct representations allow not only compact storage of trees but even useful operations on those trees directly while they're still in their succinct form.</paragraph><heading level='3'>Encoding general trees as binary trees</heading><paragraph>There is a one-to-one mapping between general ordered trees and binary trees, which in particular is used by<space/><link><target>Lisp (programming language)</target><part>Lisp</part></link><space/>to represent general ordered trees as binary trees. To convert a general ordered tree to binary tree, we only need to represent the general tree in left child-right sibling way. The result of this representation will be automatically binary tree, if viewed from a different perspective. Each node<space/><italics>N</italics><space/>in the ordered tree corresponds to a node<space/><italics>N'<space/></italics><space/>in the binary tree; the<space/><italics>left</italics><space/>child of<space/><italics>N'<space/></italics><space/>is the node corresponding to the first child of<space/><italics>N</italics>, and the<space/><italics>right</italics><space/>child of<space/><italics>N'<space/></italics><space/>is the node corresponding to<space/><italics>N</italics><space/>'s next sibling --- that is, the next node in order among the children of the parent of<space/><italics>N</italics>. This binary tree representation of a general order tree is sometimes also referred to as a<space/><link><target>left child-right sibling binary tree</target></link><space/>(LCRS tree), or a<space/><link><target>doubly chained tree</target></link>, or a<space/><link><target>Filial-Heir chain</target></link>.</paragraph><paragraph>One way of thinking about this is that each node's children are in a<space/><link><target>linked list</target></link>, chained together with their<space/><italics>right</italics><space/>fields, and the node only has a pointer to the beginning or head of this list, through its<space/><italics>left</italics><space/>field.</paragraph><paragraph>For example, in the tree on the left, A has the 6 children {B,C,D,E,F,G}. It can be converted into the binary tree on the right.</paragraph><paragraph><xhtml:center><link><target>Image:N-ary to binary.svg</target><part>400x240px</part><part>An example of converting an n-ary tree to a binary tree</part></link></xhtml:center></paragraph><paragraph>The binary tree can be thought of as the original tree tilted sideways, with the black left edges representing<space/><italics>first child</italics><space/>and the blue right edges representing<space/><italics>next sibling</italics>. The leaves of the tree on the left would be written in Lisp as:</paragraph><list type='ident'><listitem>(((N O) I J) C D ((P) (Q)) F (M))</listitem></list><paragraph>which would be implemented in memory as the binary tree on the right, without any letters on those nodes that have a left child.</paragraph><heading level='2'>Common operations</heading><paragraph><link><target>File:BinaryTreeRotations.svg</target><part>thumb</part><part>300px</part><part><link><target>Tree rotation</target><trail>s</trail></link><space/>are very common internal operations on<space/><link><target>Self-balancing binary search tree</target><part>self-balancing binary trees</part></link>.</part></link>There are a variety of different operations that can be performed on binary trees. Some are<space/><link><target>mutator method</target><part>mutator</part></link><space/>operations, while others simply return useful information about the tree.</paragraph><heading level='3'>Insertion</heading><paragraph>Nodes can be inserted into binary trees in between two other nodes or added after a<space/><link><target>leaf node</target></link>. In binary trees, a node that is inserted is specified as to which child it is.</paragraph><heading level='4'>Leaf nodes</heading><paragraph>To add a new node after leaf node A, A assigns the new node as one of its children and the new node assigns node A as its parent.</paragraph><heading level='4'>Internal nodes</heading><paragraph><link><target>File:Insertion of binary tree node.svg</target><part>thumb</part><part>360px</part><part>The process of inserting a node into a binary tree</part></link>Insertion on<space/><link><target>internal node</target><trail>s</trail></link><space/>is slightly more complex than on leaf nodes. Say that the internal node is node A and that node B is the child of A. (If the insertion is to insert a right child, then B is the right child of A, and similarly with a left child insertion.) A assigns its child to the new node and the new node assigns its parent to A. Then the new node assigns its child to B and B assigns its parent as the new node.</paragraph><heading level='3'>Deletion</heading><paragraph>Deletion is the process whereby a node is removed from the tree. Only certain nodes in a binary tree can be removed unambiguously.<extension extension_name='ref' name="rice"><template><target>cite web</target><arg name="url">http://www.clear.rice.edu/comp212/03-spring/lectures/22/</arg><arg name="title">Binary Tree Structure</arg><arg name="author">Dung X. Nguyen</arg><arg name="year">2003</arg><arg name="work"><space/></arg><arg name="publisher">rice.edu</arg><arg name="accessdate">December 28, 2010</arg></template></extension></paragraph><heading level='4'>Node with zero or one children</heading><paragraph><link><target>File:Deletion of internal binary tree node.svg</target><part>thumb</part><part>360px</part><part>The process of deleting an internal node in a binary tree</part></link>Suppose that the node to delete is node A. If A has no children, deletion is accomplished by setting the child of A's parent to<space/><link><target>null pointer</target><part>null</part></link>. If A has one child, set the parent of A's child to A's parent and set the child of A's parent to A's child.</paragraph><heading level='4'>Node with two children</heading><paragraph>In a binary tree, a node with two children cannot be deleted unambiguously.<extension extension_name='ref' name="rice"></extension><space/>However, in certain binary trees (including<space/><link><target>binary search tree</target><trail>s</trail></link>) these nodes<space/><italics>can</italics><space/>be deleted, though with a rearrangement of the tree structure.</paragraph><heading level='3'>Traversal</heading><paragraph><template><target>Main</target><arg>Tree traversal</arg></template></paragraph><paragraph>Pre-order, in-order, and post-order traversal visit each node in a tree by recursively visiting each node in the left and right subtrees of the root.</paragraph><heading level='4'>Depth-first order</heading><paragraph>In depth-first order, we always attempt to visit the node farthest from the root node that we can, but with the caveat that it must be a child of a node we have already visited. Unlike a depth-first search on graphs, there is no need to remember all the nodes we have visited, because a tree cannot contain cycles. Pre-order is a special case of this. See<space/><link><target>depth-first search</target></link><space/>for more information.</paragraph><heading level='4'>Breadth-first order</heading><paragraph>Contrasting with depth-first order is breadth-first order, which always attempts to visit the node closest to the root that it has not already visited. See<space/><link><target>breadth-first search</target></link><space/>for more information. Also called a<space/><italics>level-order traversal</italics>.</paragraph><paragraph>In a complete binary tree, a node's breadth-index (<italics>i - (2<xhtml:sup>d</xhtml:sup><space/>- 1)</italics>) can be used as traversal instructions from the root. Reading bitwise from left to right, starting at bit<space/><italics>d - 1</italics>, where<space/><italics>d</italics><space/>is the node's distance from the root (<italics>d = floor(log2(i+1))</italics>) and the node in question is not the root itself (<italics>d &gt; 0</italics>). When the breadth-index is masked at bit<space/><italics>d - 1</italics>, the bit values<space/><xhtml:tt>0</xhtml:tt><space/>and<space/><xhtml:tt>1</xhtml:tt><space/>mean to step either left or right, respectively. The process continues by successively checking the next bit to the right until there are no more. The rightmost bit indicates the final traversal from the desired node's parent to the node itself. There is a time-space trade-off between iterating a complete binary tree this way versus each node having pointer/s to its sibling/s.</paragraph><heading level='2'>See also</heading><paragraph><template><target>columns-list</target><arg name="colwidth">30em</arg><arg>
* [[2–3 tree]]
* [[2–3–4 tree]]
* [[AA tree]]
* [[Ahnentafel]]
* [[AVL tree]]
* [[B-tree]]
* [[Binary space partitioning]]
* [[Huffman tree]]
* [[K-ary tree]]
* [[Kraft's inequality]]
* [[Optimal binary search tree]]
* [[Random binary tree]]
* [[Recursion (computer science)]]
* [[Red–black tree]]
* [[Rope (computer science)]]
* [[Self-balancing binary search tree]]
* [[Splay tree]]
* [[Strahler number]]
* [[Tree of primitive Pythagorean triples#Alternative methods of generating the tree]]
* [[Unrooted binary tree]]
</arg></template></paragraph><heading level='2'>References</heading><heading level='3'>Citations</heading><paragraph><template><target>Reflist</target><arg>33em</arg></template></paragraph><heading level='3'>Bibliography</heading><list type='bullet'><listitem><link><target>Donald Knuth</target></link>.<space/><italics><link><target>The Art of Computer Programming</target></link><space/>vol 1. Fundamental Algorithms</italics>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89683-4. Section 2.3, especially subsections 2.3.12.3.2 (pp.&amp;nbsp;318348).</listitem></list><heading level='2'>External links</heading><paragraph><template><target>commons category</target><arg>Binary trees</arg></template></paragraph><list type='bullet'><listitem><link type='external' href='http://www.findstat.org/BinaryTrees'>binary trees</link><space/>entry in the<space/><link type='external' href='http://www.findstat.org/'>FindStat</link><space/>database</listitem><listitem><link type='external' href='http://www.gamedev.net/page/resources/_/technical/general-programming/trees-part-2-binary-trees-r1433'>Gamedev.net introduction on binary trees</link></listitem><listitem><link type='external' href='http://www.brpreiss.com/books/opus4/html/page355.html'>Binary Tree Proof by Induction</link></listitem><listitem><link type='external' href='http://piergiu.wordpress.com/2010/02/21/balanced-binary-search-tree-on-array/'>Balanced binary search tree on array How to create bottom-up an Ahnentafel list, or a balanced binary search tree on array</link></listitem></list><paragraph><template><target>CS-Trees</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Binary Tree</target></template><link><target>Category:Binary trees</target><part></part></link><link><target>Category:Data structures</target></link></paragraph></article>