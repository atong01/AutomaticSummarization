<article title='Algorithms_for_calculating_variance'><paragraph><bold>Algorithms for calculating variance</bold><space/>play a major role in<space/><link><target>computational statistics</target></link>. A key problem in the design of good<space/><link><target>algorithm</target><trail>s</trail></link><space/>for this problem is that formulas for the<space/><link><target>variance</target></link><space/>may involve sums of squares, which can lead to<space/><link><target>numerical instability</target></link><space/>as well as to<space/><link><target>arithmetic overflow</target></link><space/>when dealing with large values.</paragraph><heading level='2'>Nave algorithm</heading><paragraph>A formula for calculating the variance of an entire<space/><link><target>statistical population</target><part>population</part></link><space/>of size<space/><italics>N</italics><space/>is:</paragraph><list type='ident'><listitem><extension extension_name='math'>\sigma^2 = \bar{(x^2)} - \bar x^2 = \displaystyle\frac {\sum_{i=1}^N x_i^2 - (\sum_{i=1}^N x_i)^2/N}{N}. \!</extension></listitem></list><paragraph>Using<space/><link><target>Bessel's correction</target></link><space/>to calculate an<space/><link><target>estimator bias</target><part>unbiased</part></link><space/>estimate of the population variance from a finite<space/><link><target>statistical sample</target><part>sample</part></link><space/>of<space/><italics>n</italics><space/>observations, the formula is:</paragraph><list type='ident'><listitem><extension extension_name='math'>s^2 = \displaystyle\frac {\sum_{i=1}^n x_i^2 - (\sum_{i=1}^n x_i)^2/n}{n-1}. \!</extension></listitem></list><paragraph>Therefore, a naive algorithm to calculate the estimated variance is given by the following:</paragraph><paragraph><xhtml:div style="margin-left: 35px; width: 600px"><paragraph><template><target>framebox</target><arg>blue</arg></template></paragraph><list type='bullet'><listitem>Let<space/><template><target>math</target><arg>''n'' ← 0, Sum ← 0, SumSq ← 0</arg></template></listitem><listitem>For each datum<space/><template><target>mvar</target><arg>x</arg></template>:<list type='bullet'><listitem><template><target>math</target><arg>''n'' ← ''n'' + 1</arg></template></listitem><listitem><template><target>math</target><arg>Sum ← Sum + ''x''</arg></template></listitem><listitem><template><target>math</target><arg>SumSq ← SumSq + ''x'' × ''x''</arg></template></listitem></list></listitem><listitem><template><target>math</target><arg name="Var {{">}} (SumSq − (Sum × Sum) {{frac}} n) {{frac}} (n − 1)</arg></template></listitem></list><paragraph><template><target>frame-footer</target></template></paragraph></xhtml:div></paragraph><paragraph>This algorithm can easily be adapted to compute the variance of a finite population: simply divide by<space/><italics>N</italics><space/>instead of<space/><italics>n</italics>&amp;nbsp;&amp;nbsp;1 on the last line.</paragraph><paragraph>Because<space/><template><target>math</target><arg>SumSq</arg></template><space/>and<space/><template><target>math</target><arg>(Sum×Sum){{frac}}''n''</arg></template><space/>can be very similar numbers,<space/><link><target>Loss of significance</target><part>cancellation</part></link><space/>can lead to the<space/><link><target>precision (arithmetic)</target><part>precision</part></link><space/>of the result to be much less than the inherent precision of the<space/><link><target>floating-point</target></link><space/>arithmetic used to perform the computation. Thus this algorithm should not be used in practice.<extension extension_name='ref' name="Einarsson2005"><template><target>cite book</target><arg name="author">Bo Einarsson</arg><arg name="title">Accuracy and Reliability in Scientific Computing</arg><arg name="url">http://books.google.com/books?id</arg><arg name="accessdate">17 February 2013</arg><arg name="date">1 August 2005</arg><arg name="publisher">SIAM</arg><arg name="isbn">978-0-89871-584-2</arg><arg name="page">47</arg></template></extension><extension extension_name='ref' name="Chan1983"><template><target>cite journal</target><arg name="url">http://cpsc.yale.edu/sites/default/files/files/tr222.pdf</arg><arg name="author">T.F.Chan, G.H. Golub and R.J. LeVeque</arg><arg name="title">"Algorithms for computing the sample variance: Analysis and recommendations", The American Statistician, 37</arg><arg name="pages">242–247</arg><arg name="year">1983</arg></template></extension><space/>This is particularly bad if the standard deviation is small relative to the mean. However, the algorithm can be improved by adopting the method of the<space/><link><target>assumed mean</target></link>.</paragraph><heading level='3'>Computing shifted data</heading><paragraph>We can use a property of the variance to avoid the catastrophic cancellation in this formula,namely the variance is<space/><link><target>Invariant (mathematics)</target><part>invariant</part></link><space/>with respect to changes in a<space/><link><target>location parameter</target></link></paragraph><list type='ident'><listitem><extension extension_name='math'>\operatorname{Var}(X-k)=\operatorname{Var}(X).</extension></listitem></list><preblock><preline><space/><space/></preline></preblock><paragraph>with<space/><extension extension_name='math'>k</extension><space/>any constant, which leads to the new formula</paragraph><list type='ident'><listitem><extension extension_name='math'>s^2 = \displaystyle\frac {\sum_{i=1}^n (x_i-K)^2 - (\sum_{i=1}^n (x_i-K))^2/n}{n-1}. \!</extension></listitem></list><preblock><preline><space/><space/></preline></preblock><paragraph>the closer<space/><extension extension_name='math'>K</extension><space/>is to the mean value the more accurate the result will be, but just choosing a value inside thesamples range will guarantee the desired stability. If the values<space/><extension extension_name='math'>(x_i - K)</extension><space/>are small then there are no problems with the sum of its squares, on the contrary, if they are large it necessarily means that the variance is large as well. In any case the second term in the formula is always smaller than the first one therefore no cancellation may occur.<extension extension_name='ref' name="Chan1983"></extension></paragraph><paragraph>If we take just the first sample as<space/><extension extension_name='math'>K</extension><space/>the algorithm can be written in<space/><link><target>Python (programming language)</target><part>Python programming language</part></link><space/>as</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def shifted_data_variance(data):</paragraph><preblock><preline><space/><space/>if len(data) == 0:</preline><preline><space/><space/><space/><space/><space/>return 0</preline><preline><space/><space/>K = data[0]</preline><preline><space/><space/>n = 0</preline><preline><space/><space/>Sum = 0</preline><preline><space/><space/>Sum_sqr = 0</preline><preline><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/>n = n + 1</preline><preline><space/><space/><space/><space/><space/>Sum += x - K</preline><preline><space/><space/><space/><space/><space/>Sum_sqr += (x - K) * (x - K)</preline><preline><space/><space/>variance = (Sum_sqr - (Sum * Sum)/n)/(n - 1)</preline><preline><space/><space/># use n instead of (n-1) if want to compute the exact variance of the given data</preline><preline><space/><space/># use (n-1) if data are samples of a larger population</preline><preline><space/><space/>return variance</preline></preblock></extension>this formula facilitates as well the incremental computation, that can be expressed as<extension extension_name='source' lang="python"><paragraph>K = 0n = 0Ex = 0Ex2 = 0</paragraph><preblock><preline></preline></preblock><paragraph>def add_variable(x):</paragraph><preblock><preline><space/><space/><space/>if (n == 0):</preline><preline><space/><space/><space/><space/><space/>K = x</preline><preline><space/><space/><space/>n = n + 1</preline><preline><space/><space/><space/>Ex += x - K</preline><preline><space/><space/><space/>Ex2 += (x - K) * (x - K)</preline><preline></preline></preblock><paragraph>def remove_variable(x):</paragraph><preblock><preline><space/><space/><space/>n = n - 1</preline><preline><space/><space/><space/>Ex -= (x - K)</preline><preline><space/><space/><space/>Ex2 -= (x - K) * (x - K)</preline><preline></preline></preblock><paragraph>def get_meanvalue():</paragraph><preblock><preline><space/><space/>return K + Ex / n</preline></preblock><paragraph>def get_variance():</paragraph><preblock><preline><space/><space/><space/>return (Ex2 - (Ex*Ex)/n) / (n-1)</preline></preblock></extension></paragraph><heading level='2'>Two-pass algorithm</heading><paragraph>An alternative approach, using a different formula for the variance, first computes the sample mean,</paragraph><list type='ident'><listitem><extension extension_name='math'>\bar x = \displaystyle \frac {\sum_{j=1}^n x_j}{n}</extension>,</listitem></list><paragraph>and then computes the sum of the squares of the differences from the mean,</paragraph><list type='ident'><listitem><extension extension_name='math'>\mathrm{variance} = s^2 = \displaystyle\frac {\sum_{i=1}^n (x_i - \bar x)^2}{n-1} \!</extension>,</listitem></list><paragraph>where s is the standard deviation. This is given by the following pseudocode:</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def two_pass_variance(data):</paragraph><preblock><preline><space/><space/><space/>n = 0</preline><preline><space/><space/><space/>sum1 = 0</preline><preline><space/><space/><space/>sum2 = 0</preline><preline><space/><space/><space/></preline><preline><space/><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/><space/><space/>n = n + 1</preline><preline><space/><space/><space/><space/><space/><space/><space/>sum1 = sum1 + x</preline><preline><space/><space/><space/></preline><preline><space/><space/><space/>mean = sum1 / n</preline></preblock><preblock><preline><space/><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/><space/><space/>sum2 = sum2 + (x - mean)*(x - mean)</preline><preline><space/><space/><space/></preline><preline><space/><space/><space/>variance = sum2 / (n - 1)</preline><preline><space/><space/><space/>return variance</preline></preblock></extension></paragraph><paragraph>This algorithm is numerically stable if<space/><italics>n</italics><space/>is small.<extension extension_name='ref' name="Einarsson2005"></extension><extension extension_name='ref'><template><target>cite book</target><arg name="first">Nicholas<space/></arg><arg name="last">Higham<space/></arg><arg name="title">Accuracy and Stability of Numerical Algorithms (2 ed) (Problem 1.10)</arg><arg name="publisher">SIAM</arg><arg name="year">2002</arg></template></extension><space/>However, the results of both of these simple algorithms (I and II) can depend inordinately on the ordering of the data and can give poor results for very large data sets due to repeated roundoff error in the accumulation of the sums. Techniques such as<space/><link><target>compensated summation</target></link><space/>can be used to combat this error to a degree.</paragraph><heading level='3'>Compensated variant</heading><paragraph>The compensated-summation version of the algorithm above reads:<extension extension_name='ref' name=":0"></extension></paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def compensated_variance(data):</paragraph><preblock><preline><space/><space/><space/>n = 0</preline><preline><space/><space/><space/>sum1 = 0</preline><preline><space/><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/><space/><space/>n = n + 1</preline><preline><space/><space/><space/><space/><space/><space/><space/>sum1 = sum1 + x</preline><preline><space/><space/><space/>mean = sum1/n</preline><preline><space/><space/><space/><space/></preline><preline><space/><space/><space/>sum2 = 0</preline><preline><space/><space/><space/>sum3 = 0</preline><preline><space/><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/><space/><space/>sum2 = sum2 + (x - mean)**2</preline><preline><space/><space/><space/><space/><space/><space/><space/>sum3 = sum3 + (x - mean)</preline><preline><space/><space/><space/>variance = (sum2 - sum3**2/n)/(n - 1)</preline><preline><space/><space/><space/>return variance</preline></preblock></extension></paragraph><heading level='2'>Online algorithm</heading><paragraph>It is often useful to be able to compute the variance in a single pass, inspecting each value<space/><extension extension_name='math'>x_i</extension><space/>only once; for example, when the data are being collected without enough storage to keep all the values, or when costs of memory access dominate those of computation. For such an<space/><link><target>online algorithm</target></link>, a<space/><link><target>recurrence relation</target></link><space/>is required between quantities from which the required statistics can be calculated in a numerically stable fashion.</paragraph><paragraph>The following formulas can be used to update the<space/><link><target>mean</target></link><space/>and (estimated) variance of the sequence, for an additional element<space/><extension extension_name='math'>x_{\mathrm{new}}</extension>. Here,<space/><italics><template><target>overline</target><arg>x</arg></template><xhtml:sub>n</xhtml:sub></italics><space/>denotes the sample mean of the first<space/><italics>n</italics><space/>samples (<italics>x</italics><xhtml:sub>1</xhtml:sub>, ...,<space/><italics>x<xhtml:sub>n</xhtml:sub></italics>),<space/><italics>s</italics><xhtml:sup>2</xhtml:sup><xhtml:sub><italics>n</italics></xhtml:sub><space/>their sample variance, and<space/><italics></italics><xhtml:sup>2</xhtml:sup><xhtml:sub><italics>n</italics></xhtml:sub><space/>their population variance.</paragraph><list type='ident'><listitem><extension extension_name='math'>\bar x_n = \frac{(n-1) \, \bar x_{n-1} + x_n}{n} = \bar x_{n-1} + \frac{x_n - \bar x_{n-1}}{n} \!</extension></listitem></list><list type='ident'><listitem><extension extension_name='math'>s^2_n = \frac{(n-2)}{(n-1)} \, s^2_{n-1} + \frac{(x_n - \bar x_{n-1})^2}{n}, \quad n&gt;1<space/></extension></listitem></list><list type='ident'><listitem><extension extension_name='math'>\sigma^2_n = \frac{(n-1) \, \sigma^2_{n-1} + (x_n - \bar x_{n-1})(x_n - \bar x_{n})}{n}.</extension></listitem></list><paragraph>These formulas suffer from numerical instability. A better quantity for updating is the sum of squares of differences from the (current) mean,<space/><extension extension_name='math'>\textstyle\sum_{i=1}^n (x_i - \bar x_n)^2</extension>, here denoted<space/><extension extension_name='math'>M_{2,n}</extension>:</paragraph><list type='ident'><listitem><extension extension_name='math'>M_{2,n}\! = M_{2,n-1} + (x_n - \bar x_{n-1})(x_n - \bar x_n)</extension></listitem><listitem><extension extension_name='math'>s^2_n = \frac{M_{2,n}}{n-1}</extension></listitem><listitem><extension extension_name='math'>\sigma^2_n = \frac{M_{2,n}}{n}</extension></listitem></list><paragraph>A numerically stable algorithm for the sample variance is given below. It also computes the mean.This algorithm is due to Knuth,<extension extension_name='ref'><link><target>Donald E. Knuth</target></link><space/>(1998).<space/><italics><link><target>The Art of Computer Programming</target></link></italics>, volume 2:<space/><italics>Seminumerical Algorithms</italics>, 3rd edn., p. 232. Boston: Addison-Wesley.</extension><space/>who cites Welford,<extension extension_name='ref'>B. P. Welford (1962).<link type='external' href='http://www.jstor.org/stable/1266577'>&quot;Note on a method for calculating corrected sums of squares and products&quot;</link>.<space/><italics><link><target>Technometrics</target></link></italics><space/>4(3):419420.</extension><space/>and it has been thoroughly analyzed.<extension extension_name='ref'>Chan, Tony F.; Golub, Gene H.; LeVeque, Randall J. (1983). Algorithms for Computing the Sample Variance: Analysis and Recommendations. The American Statistician 37, 242-247. http://www.jstor.org/stable/2683386</extension><extension extension_name='ref'>Ling, Robert F. (1974). Comparison of Several Algorithms for Computing Sample Means and Variances. Journal of the American Statistical Association, Vol. 69, No. 348, 859-866.<space/><template><target>doi</target><arg>10.2307/2286154</arg></template></extension><space/>It is also common to denote<space/><extension extension_name='math'>M_k = \bar x_k</extension><space/>and<space/><extension extension_name='math'>S_k = M_{2,k}</extension>.<extension extension_name='ref'>http://www.johndcook.com/standard_deviation.html</extension></paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def online_variance(data):</paragraph><preblock><preline><space/><space/><space/>n = 0</preline><preline><space/><space/><space/>mean = 0.0</preline><preline><space/><space/><space/>M2 = 0.0</preline><preline><space/><space/><space/><space/></preline><preline><space/><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/><space/><space/>n = n + 1</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta = x - mean</preline><preline><space/><space/><space/><space/><space/><space/><space/>mean = mean + delta/n</preline><preline><space/><space/><space/><space/><space/><space/><space/>M2 = M2 + delta*(x - mean)</preline></preblock><preblock><preline><space/><space/><space/>if n &lt; 2:</preline><preline><space/><space/><space/><space/><space/><space/><space/>return float('nan');</preline><preline><space/><space/><space/>else:</preline><preline><space/><space/><space/><space/><space/><space/><space/>return M2 / (n - 1)</preline></preblock></extension></paragraph><paragraph>This algorithm is much less prone to loss of precision due to<space/><link><target>Catastrophic cancellation</target><part>massive cancellation</part></link>, but might not be as efficient because of the division operation inside the loop. For a particularly robust two-pass algorithm for computing the variance, first compute and subtract an estimate of the mean, and then use this algorithm on the residuals.</paragraph><paragraph>The<space/><link><target>Algorithms for calculating variance#Parallel algorithm</target><part>parallel algorithm</part></link><space/>below illustrates how to merge multiple sets of statistics calculated online.</paragraph><heading level='2'>Weighted incremental algorithm</heading><paragraph>The algorithm can be extended to handle unequal sample weights, replacing the simple counter<space/><italics>n</italics><space/>with the sum of weights seen so far. West (1979)<extension extension_name='ref'>D. H. D. West (1979).<space/><italics><link><target>Communications of the ACM</target></link></italics>, 22, 9, 532-535:<space/><italics>Updating Mean and Variance Estimates: An Improved Method</italics></extension><space/>suggests this incremental algorithm:</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def weighted_incremental_variance(dataWeightPairs):</paragraph><preblock><preline><space/><space/><space/>sumweight = 0</preline><preline><space/><space/><space/>mean = 0</preline><preline><space/><space/><space/>M2 = 0</preline></preblock><preblock><preline><space/><space/><space/>for x, weight in dataWeightPairs: # Alternatively &quot;for x, weight in zip(data, weights):&quot;</preline><preline><space/><space/><space/><space/><space/><space/><space/>temp = weight + sumweight</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta = x - mean</preline><preline><space/><space/><space/><space/><space/><space/><space/>R = delta * weight / temp</preline><preline><space/><space/><space/><space/><space/><space/><space/>mean = mean + R</preline><preline><space/><space/><space/><space/><space/><space/><space/>M2 = M2 + sumweight * delta * R # Alternatively, &quot;M2 = M2 + weight * delta * (xmean)&quot;</preline><preline><space/><space/><space/><space/><space/><space/><space/>sumweight = temp</preline></preblock><preblock><preline><space/><space/><space/>variance_n = M2/sumweight</preline><preline><space/><space/><space/>variance = variance_n * len(dataWeightPairs)/(len(dataWeightPairs) - 1)</preline></preblock></extension></paragraph><heading level='2'>Parallel algorithm</heading><paragraph>Chan et al.<extension extension_name='ref' name=":0"><template><target>Citation</target><arg name="last1"><space/>Chan<space/></arg><arg name="first1"><space/>Tony F.<space/></arg><arg name="author1-link"><space/>Tony F. Chan
<space/></arg><arg name="last2"><space/>Golub<space/></arg><arg name="first2"><space/>Gene H.<space/></arg><arg name="author2-link"><space/>Gene H. Golub
<space/></arg><arg name="last3"><space/>LeVeque<space/></arg><arg name="first3"><space/>Randall J.
<space/></arg><arg name="contribution"><space/>Updating Formulae and a Pairwise Algorithm for Computing Sample Variances.
<space/></arg><arg name="title"><space/>Technical Report STAN-CS-79-773
<space/></arg><arg name="publisher"><space/>Department of Computer Science, Stanford University
<space/></arg><arg name="year"><space/>1979
<space/></arg><arg name="contribution-url">http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf<space/></arg></template>.</extension><space/>note that the above online algorithm III is a special case of an algorithm that works for any partition of the sample<space/><extension extension_name='math'>X</extension><space/>into sets<space/><extension extension_name='math'>X_A</extension>,<space/><extension extension_name='math'>X_B</extension>:</paragraph><list type='ident'><listitem><extension extension_name='math'>\delta\! = \bar x_B - \bar x_A</extension></listitem><listitem><extension extension_name='math'>\bar x_X = \bar x_A + \delta\cdot\frac{n_B}{n_X}</extension></listitem><listitem><extension extension_name='math'>M_{2,X} = M_{2,A} + M_{2,B} + \delta^2\cdot\frac{n_A n_B}{n_X}</extension>.</listitem></list><paragraph>This may be useful when, for example, multiple processing units may be assigned to discrete parts of the input.</paragraph><paragraph>Chan's method for estimating the mean is numerically unstable when<space/><extension extension_name='math'>n_A \approx n_B</extension><space/>and both are large, because the numerical error in<space/><extension extension_name='math'>\bar x_B - \bar x_A</extension><space/>is not scaled down in the way that it is in the<space/><extension extension_name='math'>n_B = 1</extension><space/>case. In such cases, prefer<space/><extension extension_name='math'>\bar x_X = \frac{n_A \bar x_A + n_B \bar x_B}{n_A + n_B}</extension>.</paragraph><heading level='2'>Example</heading><paragraph>Assume that all floating point operations use the standard<space/><link><target>IEEE 754#Double-precision 64 bit</target><part>IEEE 754 double-precision</part></link><space/>arithmetic. Consider the sample (4, 7, 13, 16) from an infinite population. Based on this sample, the estimated population mean is 10, and the unbiased estimate of population variance is 30. Both Algorithm I and Algorithm II compute these values correctly. Next consider the sample (10<xhtml:sup>8</xhtml:sup>&amp;nbsp;+&amp;nbsp;4, 10<xhtml:sup>8</xhtml:sup>&amp;nbsp;+&amp;nbsp;7, 10<xhtml:sup>8</xhtml:sup>&amp;nbsp;+&amp;nbsp;13, 10<xhtml:sup>8</xhtml:sup>&amp;nbsp;+&amp;nbsp;16), which gives rise to the same estimated variance as the first sample. Algorithm II computes this variance estimate correctly, but Algorithm I returns 29.333333333333332 instead of 30. While this loss of precision may be tolerable and viewed as a minor flaw of Algorithm I, it is easy to find data that reveal a major flaw in the naive algorithm: Take the sample to be (10<xhtml:sup>9</xhtml:sup>&amp;nbsp;+&amp;nbsp;4, 10<xhtml:sup>9</xhtml:sup>&amp;nbsp;+&amp;nbsp;7, 10<xhtml:sup>9</xhtml:sup>&amp;nbsp;+&amp;nbsp;13, 10<xhtml:sup>9</xhtml:sup>&amp;nbsp;+&amp;nbsp;16). Again the estimated population variance of 30 is computed correctly by Algorithm II, but the naive algorithm now computes it as 170.66666666666666. This is a serious problem with Algorithm I and is due to<space/><link><target>catastrophic cancellation</target></link><space/>in the subtraction of two similar numbers at the final stage of the algorithm.</paragraph><heading level='2'>Higher-order statistics</heading><paragraph>Terriberry<extension extension_name='ref'><template><target>Citation</target><arg name="last">Terriberry
<space/></arg><arg name="first">Timothy B.
<space/></arg><arg name="year">2007
<space/></arg><arg name="title">Computing Higher-Order Moments Online
<space/></arg><arg name="url">http://people.xiph.org/~tterribe/notes/homs.html
<space/></arg></template></extension><space/>extends Chan's formulae to calculating the third and fourth<space/><link><target>central moment</target><trail>s</trail></link>, needed for example when estimating<space/><link><target>skewness</target></link><space/>and<space/><link><target>kurtosis</target></link>:</paragraph><list type='ident'><listitem><extension extension_name='math'>M_{3,X} = M_{3,A} + M_{3,B} + \delta^3\frac{n_A n_B (n_A - n_B)}{n_X^2} + 3\delta\frac{n_AM_{2,B} - n_BM_{2,A}}{n_X}</extension></listitem><listitem><extension extension_name='math'>\begin{align}
M_{4,X} = M_{4,A} + M_{4,B} &amp; + \delta^4\frac{n_A n_B \left(n_A^2 - n_A n_B + n_B^2\right)}{n_X^3} \\
 &amp; + 6\delta^2\frac{n_A^2 M_{2,B} + n_B^2 M_{2,A}}{n_X^2} + 4\delta\frac{n_AM_{3,B} - n_BM_{3,A}}{n_X} \\
\end{align}</extension></listitem></list><paragraph>Here the<space/><extension extension_name='math'>M_k</extension><space/>are again the sums of powers of differences from the mean<space/><extension extension_name='math'>\Sigma(x - \overline{x})^k</extension>, giving</paragraph><list type='ident'><listitem>skewness:<space/><extension extension_name='math'>g_1 = \frac{\sqrt{n} M_3}{M_2^{3/2}},</extension></listitem><listitem>kurtosis:<space/><extension extension_name='math'>g_2 = \frac{n M_4}{M_2^2}-3.</extension></listitem></list><paragraph>For the incremental case (i.e.,<space/><extension extension_name='math'>B = \{x\}</extension>), this simplifies to:</paragraph><list type='ident'><listitem><extension extension_name='math'>\delta\! = x - m</extension></listitem><listitem><extension extension_name='math'>m' = m + \frac{\delta}{n}</extension></listitem><listitem><extension extension_name='math'>M_2' = M_2 + \delta^2 \frac{ n-1}{n}</extension></listitem></list><list type='ident'><listitem><extension extension_name='math'>M_3' = M_3 + \delta^3 \frac{ (n - 1) (n - 2)}{n^2} - \frac{3\delta M_2}{n}</extension></listitem></list><list type='ident'><listitem><extension extension_name='math'>M_4' = M_4 + \frac{\delta^4 (n - 1) (n^2 - 3n + 3)}{n^3} + \frac{6\delta^2 M_2}{n^2} - \frac{4\delta M_3}{n}</extension></listitem></list><paragraph>By preserving the value<space/><extension extension_name='math'>\delta / n</extension>, only one division operation is needed and the higher-order statistics can thus be calculated for little incremental cost.</paragraph><paragraph>An example of the online algorithm for kurtosis implemented as described is:<extension extension_name='source' lang="python"><paragraph>def online_kurtosis(data):</paragraph><preblock><preline><space/><space/><space/>n = 0</preline><preline><space/><space/><space/>mean = 0</preline><preline><space/><space/><space/>M2 = 0</preline><preline><space/><space/><space/>M3 = 0</preline><preline><space/><space/><space/>M4 = 0</preline></preblock><preblock><preline><space/><space/><space/>for x in data:</preline><preline><space/><space/><space/><space/><space/><space/><space/>n1 = n</preline><preline><space/><space/><space/><space/><space/><space/><space/>n = n + 1</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta = x - mean</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta_n = delta / n</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta_n2 = delta_n * delta_n</preline><preline><space/><space/><space/><space/><space/><space/><space/>term1 = delta * delta_n * n1</preline><preline><space/><space/><space/><space/><space/><space/><space/>mean = mean + delta_n</preline><preline><space/><space/><space/><space/><space/><space/><space/>M4 = M4 + term1 * delta_n2 * (n*n - 3*n + 3) + 6 * delta_n2 * M2 - 4 * delta_n * M3</preline><preline><space/><space/><space/><space/><space/><space/><space/>M3 = M3 + term1 * delta_n * (n - 2) - 3 * delta_n * M2</preline><preline><space/><space/><space/><space/><space/><space/><space/>M2 = M2 + term1</preline></preblock><preblock><preline><space/><space/><space/>kurtosis = (n*M4) / (M2*M2) - 3</preline><preline><space/><space/><space/>return kurtosis</preline></preblock></extension></paragraph><paragraph>Pbay<extension extension_name='ref'><template><target>Citation</target><arg name="last">Pébay
<space/></arg><arg name="first">Philippe
<space/></arg><arg name="year">2008
<space/></arg><arg name="contribution">Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments
<space/></arg><arg name="title">Technical Report SAND2008-6212
<space/></arg><arg name="publisher">Sandia National Laboratories
<space/></arg><arg name="contribution-url">http://infoserve.sandia.gov/sand_doc/2008/086212.pdf
<space/></arg></template></extension>further extends these results to arbitrary-order<space/><link><target>central moment</target><trail>s</trail></link>, for the incremental and the pairwise cases. One can also find there similar formulas for<space/><link><target>covariance</target></link>.</paragraph><paragraph>Choi and Sweetman<extension extension_name='ref' name="Choi2010"><template><target>Citation</target><arg name="last1"><space/>Choi<space/></arg><arg name="first1"><space/>Muenkeun
<space/></arg><arg name="last2"><space/>Sweetman<space/></arg><arg name="first2"><space/>Bert
<space/></arg><arg name="year">2010
<space/></arg><arg name="title">Efficient Calculation of Statistical Moments for Structural Health Monitoring
<space/></arg><arg name="url">http://www.rms-group.org/RMS_Papers/TAMUG_Papers/MK/Efficient_Moments_2010.pdf
<space/></arg></template></extension>offer two alternative methods to compute the skewness and kurtosis, each of which can save substantial computer memory requirements and CPU time in certain applications. The first approach is to compute the statistical moments by separating the data into bins and then computing the moments from the geometry of the resulting histogram, which effectively becomes a<space/><link><target>one-pass algorithm</target></link><space/>for higher moments. One benefit is that the statistical moment calculations can be carried out to arbitrary accuracy such that the computations can be tuned to the precision of, e.g., the data storage format or the original measurement hardware. A relative histogram of a random variable can be constructed inthe conventional way: the range of potential values isdivided into bins and the number of occurrences within each bin arecounted and plotted such that the area of each rectangle equalsthe portion of the sample values within that bin:</paragraph><list type='ident'><listitem><extension extension_name='math'><space/>H(x_k)=\frac{h(x_k)}{A}</extension></listitem></list><paragraph>where<space/><extension extension_name='math'>h(x_k)</extension><space/>and<space/><extension extension_name='math'>H(x_k)</extension><space/>represent the frequency andthe relative frequency at bin<space/><extension extension_name='math'>x_k</extension><space/>and<space/><extension extension_name='math'>A= \sum_{k=1}^{K} h(x_k)
\,\Delta x_k</extension><space/>is the total area of the histogram. After thisnormalization, the<space/><extension extension_name='math'>n</extension><space/>raw moments and central moments of<space/><extension extension_name='math'>x(t)</extension>can be calculated from the relative histogram:</paragraph><list type='ident'><listitem><extension extension_name='math'>
 m_n^{(h)} = \sum_{k=1}^{K} x_k^n \, H(x_k) \Delta x_k
 = \frac{1}{A} \sum_{k=1}^{K} x_k^n \, h(x_k) \Delta x_k
</extension></listitem></list><list type='ident'><listitem><extension extension_name='math'>
 \theta_n^{(h)}= \sum_{k=1}^{K} \Big(x_k-m_1^{(h)}\Big)^n \, H(x_k)\Delta x_k
 = \frac{1}{A} \sum_{k=1}^{K} \Big(x_k-m_1^{(h)}\Big)^n \, h(x_k) \Delta x_k
</extension></listitem></list><paragraph>where the superscript<space/><extension extension_name='math'>^{(h)}</extension><space/>indicates the moments arecalculated from the histogram. For constant bin width<space/><extension extension_name='math'>\Delta
x_k=\Delta x</extension><space/>these two expressions can be simplified using<space/><extension extension_name='math'>I= A/\Delta x</extension>:</paragraph><list type='ident'><listitem><extension extension_name='math'>
 m_n^{(h)}= \frac{1}{I} {\sum_{k=1}^{K} x_k^n \, h(x_k)}
</extension></listitem></list><list type='ident'><listitem><extension extension_name='math'>
 \theta_n^{(h)}= \frac{1}{I}{\sum_{k=1}^{K} \Big(x_k-m_1^{(h)}\Big)^n \, h(x_k)}
</extension></listitem></list><paragraph>The second approach from Choi and Sweetman<extension extension_name='ref' name="Choi2010"></extension>is an analytical methodology to combine statistical moments from individual segments of a time-history such that the resulting overall moments are those of the complete time-history. This methodology could be used for parallel computation of statistical moments with subsequent combination of those moments, or for combination of statistical moments computed at sequential times.</paragraph><paragraph>If<space/><extension extension_name='math'>Q</extension><space/>sets of statistical moments are known:<extension extension_name='math'>(\gamma_{0,q},\mu_{q},\sigma^2_{q},\alpha_{3,q},\alpha_{4,q})
\quad<space/></extension><space/>for<space/><extension extension_name='math'>q=1,2,...,Q<space/></extension>, then each<space/><extension extension_name='math'>\gamma_n</extension><space/>canbe expressed in terms of the equivalent<space/><extension extension_name='math'>n</extension><space/>raw moments:</paragraph><list type='ident'><listitem><extension extension_name='math'>
 \gamma_{n,q}= m_{n,q} \gamma_{0,q} \qquad \quad \textrm{for} \quad n=1,2,3,4 \quad \text{ and } \quad q = 1,2, \dots ,Q
</extension></listitem></list><paragraph>where<space/><extension extension_name='math'>\gamma_{0,q}</extension><space/>is generally taken to be the duration of the<space/><extension extension_name='math'>q^{th}</extension><space/>time-history, or the number of points if<space/><extension extension_name='math'>\Delta t</extension><space/>is constant.</paragraph><paragraph>The benefit of expressing the statistical moments interms of<space/><extension extension_name='math'>\gamma</extension><space/>is that the<space/><extension extension_name='math'>Q</extension><space/>sets can be combined byaddition, and there is no upper limit on the value of<space/><extension extension_name='math'>Q</extension>.</paragraph><list type='ident'><listitem><extension extension_name='math'>
 \gamma_{n,c}= \sum_{q=1}^{Q}\gamma_{n,q} \quad \quad \textrm{for} \quad n=0,1,2,3,4
</extension></listitem></list><paragraph>where the subscript<space/><extension extension_name='math'>_c</extension><space/>represents the concatenatedtime-history or combined<space/><extension extension_name='math'>\gamma</extension>. These combined values of<extension extension_name='math'>\gamma</extension><space/>can then be inversely transformed into raw momentsrepresenting the complete concatenated time-history</paragraph><list type='ident'><listitem><extension extension_name='math'>
 m_{n,c}=\frac{\gamma_{n,c}}{\gamma_{0,c}} \quad \textrm{for} \quad n=1,2,3,4
</extension></listitem></list><paragraph>Known relationships between the raw moments (<extension extension_name='math'>m_n</extension>) and the central moments (<extension extension_name='math'><space/>\theta_n = E[(x-\mu)^n])</extension>)are then used to compute the central moments of the concatenated time-history. Finally, the statistical moments of the concatenated history are computed from the central moments:</paragraph><list type='ident'><listitem><extension extension_name='math'>
 \mu_c=m_{1,c}
 \ \ \ \ \ \sigma^2_c=\theta_{2,c}
 \ \ \ \ \ \alpha_{3,c}=\frac{\theta_{3,c}}{\sigma_c^3}
 \ \ \ \ \ \alpha_{4,c}={\frac{\theta_{4,c}}{\sigma_c^4}}-3
</extension></listitem></list><heading level='2'>Covariance</heading><paragraph>Very similar algorithms can be used to compute the<space/><link><target>covariance</target></link>. The naive algorithm is:</paragraph><list type='ident'><listitem><extension extension_name='math'>\operatorname{Cov}(X,Y) = \displaystyle\frac {\sum_{i=1}^n x_i y_i - (\sum_{i=1}^n x_i)(\sum_{i=1}^n y_i)/n}{n}. \!</extension></listitem></list><paragraph>For the algorithm above, one could use the following Python code:<extension extension_name='source' lang="python"><paragraph>def naive_covariance(data1, data2):</paragraph><preblock><preline><space/><space/><space/>n = len(data1)</preline><preline><space/><space/><space/>sum12 = 0</preline><preline><space/><space/><space/>sum1 = sum(data1)</preline><preline><space/><space/><space/>sum2 = sum(data2)</preline></preblock><preblock><preline><space/><space/><space/>for i in range(n):</preline><preline><space/><space/><space/><space/><space/><space/><space/>sum12 += data1[i]*data2[i]</preline></preblock><preblock><preline><space/><space/><space/>covariance = (sum12 - sum1*sum2 / n) / n</preline><preline><space/><space/><space/>return covariance</preline></preblock></extension></paragraph><paragraph>As for the variance, the covariance of two random variables is also shift-invariant, so given that<space/><extension extension_name='math'>K_x</extension><space/>and<space/><extension extension_name='math'>K_y</extension><space/>are whatever two constant values it can be written:</paragraph><list type='ident'><listitem><extension extension_name='math'>\operatorname{Cov}(X,Y) = \operatorname{Cov}(X-k_x,Y-k_y) = \displaystyle\frac {\sum_{i=1}^n (x_i-K_x) (y_i-K_y) - (\sum_{i=1}^n (x_i-K_x))(\sum_{i=1}^n (y_i-K_y))/n}{n}. \!</extension></listitem></list><paragraph>and again choosing a value inside the range of values will stabilize the formula against catastrophic cancellation as well as make it more robust against big sums. Taking the first value of each data set, the algorithm can be written as:</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def shifted_data_covariance(dataX, dataY):</paragraph><preblock><preline><space/><space/>n = len(dataX)</preline><preline><space/><space/>if (n &lt; 2):</preline><preline><space/><space/><space/><space/>return 0</preline><preline><space/><space/>Kx = dataX[0]</preline><preline><space/><space/>Ky = dataY[0]</preline><preline><space/><space/>Ex = 0</preline><preline><space/><space/>Ey = 0</preline><preline><space/><space/>Exy = 0</preline><preline><space/><space/>for i in range(n):</preline><preline><space/><space/><space/><space/><space/>Ex += dataX[i] - Kx</preline><preline><space/><space/><space/><space/><space/>Ey += dataY[i] - Ky</preline><preline><space/><space/><space/><space/><space/>Exy += (dataX[i] - Kx) * (dataY[i] - Ky)</preline><preline><space/><space/>return (Exy - Ex * Ey / n) / n</preline></preblock></extension></paragraph><paragraph>The two-pass algorithm first computes the sample means, and then the covariance:</paragraph><list type='ident'><listitem><extension extension_name='math'>\bar x = \displaystyle \sum_{i=1}^n x_i/n</extension></listitem><listitem><extension extension_name='math'>\bar y = \displaystyle \sum_{i=1}^n y_i/n</extension></listitem><listitem><extension extension_name='math'>\operatorname{Cov}(X,Y) = \displaystyle\frac {\sum_{i=1}^n (x_i - \bar x)(y_i - \bar y)}{n}. \!</extension></listitem></list><paragraph>The two-pass algorithm may be written as:<extension extension_name='source' lang="python"><paragraph>def two_pass_covariance(data1, data2):</paragraph><preblock><preline><space/><space/><space/>n = len(data1)</preline></preblock><preblock><preline><space/><space/><space/>mean1 = sum(data1) / n</preline><preline><space/><space/><space/>mean2 = sum(data2) / n</preline></preblock><preblock><preline><space/><space/><space/>covariance = 0</preline></preblock><preblock><preline><space/><space/><space/>for i in range(n):</preline><preline><space/><space/><space/><space/><space/><space/><space/>a = data1[i] - mean1</preline><preline><space/><space/><space/><space/><space/><space/><space/>b = data2[i] - mean2</preline><preline><space/><space/><space/><space/><space/><space/><space/>covariance += a*b / n</preline></preblock><preblock><preline><space/><space/><space/>return covariance</preline></preblock></extension></paragraph><paragraph>A slightly more accurate compensated version performs the full naive algorithm on the residuals. The final sums<space/><extension extension_name='math'>\textstyle\sum x_i</extension><space/>and<space/><extension extension_name='math'>\textstyle\sum y_i</extension><space/><italics>should</italics><space/>be zero, but the second pass compensates for any small error.</paragraph><paragraph>A slight modification of the online algorithm for computing the variance yields an online algorithm for the covariance:</paragraph><paragraph><extension extension_name='source' lang="python"><paragraph>def online_covariance(data1, data2):</paragraph><preblock><preline><space/><space/><space/>mean1 = mean2 = 0.</preline><preline><space/><space/><space/>M12 = 0.</preline><preline><space/><space/><space/>n = len(ls1)</preline><preline><space/><space/><space/>for i in range(n):</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta1 = (data1[i] - mean1) / (i + 1)</preline><preline><space/><space/><space/><space/><space/><space/><space/>mean1 += delta1</preline><preline><space/><space/><space/><space/><space/><space/><space/>delta2 = (data2[i] - mean2) / (i + 1)</preline><preline><space/><space/><space/><space/><space/><space/><space/>mean2 += delta2</preline><preline><space/><space/><space/><space/><space/><space/><space/>M12 += i * delta1 * delta2 - M12 / (i + 1)</preline><preline><space/><space/><space/>return n / (n - 1.) * M12</preline></preblock></extension>A stable one-pass algorithm exists, similar to the one above, that computes co-moment<space/><extension extension_name='math'>\textstyle C_n = \sum_{i=1}^n (x_i - \bar x_n)(y_i - \bar y_n)</extension>:</paragraph><list type='ident'><listitem><extension extension_name='math'>\bar x_n = \bar x_{n-1} + \frac{x_n - \bar x_{n-1}}{n} \!</extension></listitem><listitem><extension extension_name='math'>\bar y_n = \bar y_{n-1} + \frac{y_n - \bar y_{n-1}}{n} \!</extension></listitem><listitem><extension extension_name='math'>C_n = C_{n-1} + (x_n - \bar x_n)(y_n - \bar y_{n-1}) = C_{n-1} + (y_n - \bar y_n)(x_n - \bar x_{n-1})</extension></listitem></list><paragraph>The apparent asymmetry in that last equation is due to the fact that<space/><extension extension_name='math'>\textstyle (x_n - \bar x_n) = \frac{n-1}{n}(x_n - \bar x_{n-1})</extension>, so both update terms are equal to<space/><extension extension_name='math'>\textstyle \frac{n-1}{n}(x_n - \bar x_{n-1})(y_n - \bar y_{n-1})</extension>. Even greater accuracy can be achieved by first computing the means, then using the stable one-pass algorithm on the residuals.</paragraph><paragraph>Thus we can compute the covariance as</paragraph><list type='ident'><listitem><extension extension_name='math'>\begin{align}
\operatorname{Cov}_N(X,Y) = \frac{C_N}{N} &amp;= \frac{\operatorname{Cov}_{N-1}(X,Y)\cdot(N-1) + (x_n - \bar x_n)(y_n - \bar y_{n-1})}{N}\\
 &amp;= \frac{\operatorname{Cov}_{N-1}(X,Y)\cdot(N-1) + (y_n - \bar y_n)(x_n - \bar x_{n-1})}{N}\\
 &amp;= \frac{\operatorname{Cov}_{N-1}(X,Y)\cdot(N-1) + \frac{N-1}{N}(x_n - \bar x_{n-1})(y_n - \bar y_{n-1})}{N}.
\end{align}</extension></listitem></list><paragraph>Likewise, there is a formula for combining the covariances of two sets that can be used to parallelize the computation:</paragraph><list type='ident'><listitem><extension extension_name='math'>C_X = C_A + C_B + (\bar x_A - \bar x_B)(\bar y_A - \bar y_B)\cdot\frac{n_A n_B}{n_X}</extension>.</listitem></list><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Algebraic formula for the variance</target></link></listitem><listitem><link><target>Kahan summation algorithm</target></link></listitem></list><heading level='2'>References</heading><paragraph><extension extension_name='references'></extension></paragraph><heading level='2'>External links</heading><list type='bullet'><listitem><template><target>MathWorld</target><arg name="title">Sample Variance Computation</arg><arg name="urlname">SampleVarianceComputation</arg></template></listitem></list><paragraph><template><target>DEFAULTSORT:Algorithms For Calculating Variance</target></template><link><target>Category:Statistical algorithms</target></link><link><target>Category:Statistical deviation and dispersion</target></link><link><target>Category:Articles with example pseudocode</target></link><link><target>Category:Articles with example Python code</target></link></paragraph></article>