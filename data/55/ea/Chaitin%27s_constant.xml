<article title='Chaitin%27s_constant'><paragraph><template><target>Use dmy dates</target><arg name="date">July 2012</arg></template><template><target>more footnotes</target><arg name="date">November 2011</arg></template><template><target>about</target><arg>the &Omega; constant from information theory</arg><arg>the &Omega; constant from analysis</arg><arg>Omega constant</arg></template><link><target>File:OmegaChaitin.png</target><part>thumb</part><part>Chaitin's constant<space/><link><target>metaphor</target></link></part></link></paragraph><paragraph>In the<space/><link><target>computer science</target></link><space/>subfield of<space/><link><target>algorithmic information theory</target></link>, a<space/><bold>Chaitin constant</bold><space/>(<bold>Chaitin omega number</bold>)<extension extension_name='ref'><link><target>mathworld.wolfram.com</target></link>,<space/><link type='external' href='http://mathworld.wolfram.com/ChaitinsConstant.html'>Chaitin's Constant</link>. Retrieved 28 May 2012</extension><space/>or<space/><bold>halting probability</bold><space/>is a<space/><link><target>real number</target></link><space/>that informally represents the<space/><link><target>probability</target></link><space/>that a randomly constructed program will halt. These numbers are formed from a construction due to<space/><link><target>Gregory Chaitin</target></link>.</paragraph><paragraph>Although there are infinitely many halting probabilities, it is common to use the letter to refer to them as if there were only one. Because depends on the program encoding used, it is sometimes called<space/><bold>Chaitin's construction</bold><space/>instead of<space/><bold>Chaitin's constant</bold><space/>when not referring to any specific encoding.</paragraph><paragraph>Each halting probability is a<space/><link><target>normal number</target><part>normal</part></link><space/>and<space/><link><target>transcendental number</target><part>transcendental</part></link><space/>real number that is not<space/><link><target>computable number</target><part>computable</part></link>, which means that there is no<space/><link><target>algorithm</target></link><space/>to compute its digits. Indeed, each halting probability is<space/><link><target>Algorithmically random sequence</target><part>Martin-Lf random</part></link>, meaning there is not even any algorithm which can reliably guess its digits.</paragraph><heading level='2'>Background</heading><paragraph>The definition of a halting probability relies on the existence of<space/><bold>prefix-free universal computable functions.</bold><space/>Such a function, intuitively, represents a programming language with the property that no valid program can be obtained as a proper extension of another valid program.</paragraph><paragraph>Suppose that<space/><italics>F</italics><space/>is a partial function that takes one argument, a finite binary string, and possibly returns a single binary string as output. The function<space/><italics>F</italics><space/>is called<space/><bold><link><target>Computable function</target><part>computable</part></link></bold><space/>if there is a<space/><link><target>Turing machine</target></link><space/>that computes it (in the sense that for any finite binary string<space/><italics>x</italics><space/>such that<space/><italics>F(x) = y</italics><space/>the Turing machine halts with<space/><italics>y</italics><space/>on its tape when given the input<space/><italics>x</italics>).</paragraph><paragraph>The function<space/><italics>F</italics><space/>is called<space/><bold><link><target>Computational universality</target><part>universal</part></link></bold><space/>if the following property holds: for every computable function<space/><italics>f</italics><space/>of a single variable there is a string<space/><italics>w</italics><space/>such that for all<space/><italics>x</italics>,<space/><italics>F</italics>(<italics>w</italics>&amp;nbsp;<italics>x</italics>) =<space/><italics>f</italics>(<italics>x</italics>); here<space/><italics>w</italics>&amp;nbsp;<italics>x</italics><space/>represents the<space/><link><target>concatenation</target></link><space/>of the two strings<space/><italics>w</italics><space/>and<space/><italics>x</italics>. This means that<space/><italics>F</italics><space/>can be used to simulate any computable function of one variable. Informally,<space/><italics>w</italics><space/>represents a &quot;script&quot; for the computable function<space/><italics>f</italics>, and<space/><italics>F</italics><space/>represents an &quot;interpreter&quot; that parses the script as a prefix of its input and then executes it on the remainder of input.</paragraph><paragraph>The<space/><bold>domain</bold><space/>of<space/><italics>F</italics><space/>is the set of all inputs<space/><italics>p</italics><space/>on which it is defined. For<space/><italics>F</italics><space/>that are universal, such a<space/><italics>p</italics><space/>can generally be seen both as the concatenation of a program part and a data part, and as a single program for the function<space/><italics>F</italics>.</paragraph><paragraph>The function<space/><italics>F</italics><space/>is called<space/><bold>prefix-free</bold><space/>if there are no two elements<space/><italics>p</italics>,<space/><italics>p&amp;prime;</italics><space/>in its domain such that<space/><italics>p&amp;prime;</italics><space/>is a proper extension of<space/><italics>p</italics>. This can be rephrased as: the domain of<space/><italics>F</italics><space/>is a<space/><link><target>prefix-free code</target></link><space/>(instantaneous code) on the set of finite binary strings. A simple way to enforce prefix-free-ness is to use machines whose means of input is a binary stream from which bits can be read one at a time. There is no end-of-stream marker; the end of input is determined by when the universal machine decides to stop reading more bits. Here, the difference between the two notions of program mentioned in the last paragraph becomes clear; one is easily recognized by some grammar, while the other requires arbitrary computation to recognize.</paragraph><paragraph>The domain of any universal computable function is a<space/><link><target>computably enumerable set</target></link><space/>but never a<space/><link><target>computable set</target></link>. The domain is always<space/><link><target>Turing equivalent</target></link><space/>to the<space/><link><target>halting problem</target></link>.</paragraph><heading level='2'>Definition</heading><paragraph>Let<space/><italics>P</italics><xhtml:sub>F</xhtml:sub><space/>be the domain of a prefix-free universal computable function<space/><italics>F</italics>. The constant<space/><xhtml:sub>F</xhtml:sub><space/>is then defined as</paragraph><list type='ident'><listitem><extension extension_name='math'>\Omega_F = \sum_{p \in P_F} 2^{-|p|}</extension>,</listitem></list><paragraph>where<space/><extension extension_name='math'>\left|p\right|</extension><space/>denotes the length of a string<space/><italics>p</italics>.This is an<space/><link><target>series (mathematics)</target><part>infinite sum</part></link><space/>which has one summand for every<space/><italics>p</italics><space/>in the domain of<space/><italics>F</italics>. The requirement that the domain be prefix-free, together with<space/><link><target>Kraft's inequality</target></link>, ensures that this sum converges to a<space/><link><target>real number</target></link><space/>between 0 and 1. If<space/><italics>F</italics><space/>is clear from context then<space/><xhtml:sub>F</xhtml:sub><space/>may be denoted simply , although different prefix-free universal computable functions lead to different values of .</paragraph><heading level='2'>Relationship to the halting problem</heading><paragraph>Knowing the first<space/><extension extension_name='math'>N</extension><space/>bits of<space/><extension extension_name='math'>\Omega</extension>, one could calculate the<space/><link><target>halting problem</target></link><space/>for all programs of a size up to<space/><extension extension_name='math'>N</extension>. Let the program<space/><extension extension_name='math'>p</extension><space/>for which the halting problem is to be solved be<space/><italics>N</italics><space/>bits long. In<space/><link><target>Dovetailing (computer science)</target><part>dovetailing</part></link><space/>fashion, all programs of all lengths are run, until enough have halted to jointly contribute enough probability to match these first<space/><italics>N</italics><space/>bits. If the program<space/><extension extension_name='math'>p</extension><space/>hasn't halted yet, then it never will, since its contribution to the halting probability would affect the first N bits.Thus, the halting problem would be solved for<space/><extension extension_name='math'>p</extension>.</paragraph><paragraph>Because many outstanding problems in number theory, such as<space/><link><target>Goldbach's conjecture</target></link><space/>are equivalent to solving the halting problem for special programs (which would basically search for counter-examples and halt if one is found), knowing enough bits of Chaitin's constant would also imply knowing the answer to these problems. But as the halting problem is not generally solvable, and therefore calculating any but the first few bits of Chaitin's constant is not possible, this just reduces hard problems to impossible ones, much like trying to build an<space/><link><target>Oracle machine#Oracles and halting problems</target><part>oracle machine for the halting problem</part></link><space/>would be.</paragraph><heading level='2'>Interpretation as a probability</heading><paragraph>The<space/><link><target>Cantor space</target></link><space/>is the collection of all infinite sequences of 0s and 1s. A halting probability can be interpreted as the<space/><link><target>measure theory</target><part>measure</part></link><space/>of a certain subset of Cantor space under the usual<space/><link><target>probability measure</target></link><space/>on Cantor space. It is from this interpretation that halting probabilities take their name.</paragraph><paragraph>The probability measure on Cantor space, sometimes called the fair-coin measure, is defined so that for any binary string<space/><italics>x</italics><space/>the set of sequences that begin with<space/><italics>x</italics><space/>has measure 2<xhtml:sup>|<italics>x</italics>|</xhtml:sup>. This implies that for each natural number<space/><italics>n</italics>, the set of sequences<space/><italics>f</italics><space/>in Cantor space such that<space/><italics>f</italics>(<italics>n</italics>) = 1 has measure 1/2, and the set of sequences whose<space/><italics>n</italics>th element is 0 also has measure 1/2.</paragraph><paragraph>Let<space/><italics>F</italics><space/>be a prefix-free universal computable function. The domain<space/><italics>P</italics><space/>of<space/><italics>F</italics><space/>consists of an infinite set of binary strings</paragraph><list type='ident'><listitem><extension extension_name='math'>P = \{p_1,p_2,\ldots\}</extension>.</listitem></list><paragraph>Each of these strings<space/><italics>p</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>determines a subset<space/><italics>S</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>of Cantor space; the set<space/><italics>S</italics><xhtml:sub><italics>i</italics></xhtml:sub><space/>contains all sequences in cantor space that begin with<space/><italics>p</italics><xhtml:sub><italics>i</italics></xhtml:sub>. These sets are disjoint because<space/><italics>P</italics><space/>is a prefix-free set. The sum</paragraph><list type='ident'><listitem><extension extension_name='math'>\sum_{p \in P} 2^{-|p|}</extension></listitem></list><paragraph>represents the measure of the set<space/></paragraph><list type='ident'><listitem><extension extension_name='math'>\bigcup_{i \in \mathbb{N}} S_i</extension>.</listitem></list><paragraph>In this way,<space/><xhtml:sub><italics>F</italics></xhtml:sub><space/>represents the probability that a randomly selected infinite sequence of 0s and 1s begins with a bit string (of some finite length) that is in the domain of<space/><italics>F</italics>. It is for this reason that<space/><xhtml:sub><italics>F</italics></xhtml:sub><space/>is called a halting probability.</paragraph><heading level='2'>Properties</heading><paragraph>Each Chaitin constant has the following properties:</paragraph><list type='bullet'><listitem>It is<space/><link><target>algorithmic randomness</target><part>algorithmically random</part></link>. This means that the shortest program to output the first<space/><italics>n</italics><space/>bits of must be of size at least<space/><italics>n</italics>-O(1). This is because, as in the Goldbach example, those<space/><italics>n</italics><space/>bits enable us to find out exactly which programs halt among all those of length at most<space/><italics>n</italics>.</listitem><listitem>It is a<space/><link><target>normal number</target></link>, which means that its digits are equidistributed as if they were generated by tossing a fair coin.</listitem><listitem>It is not a<space/><link><target>computable number</target></link>; there is no computable function that enumerates its binary expansion, as discussed below.</listitem><listitem>The set of rational numbers<space/><italics>q</italics><space/>such that<space/><italics>q</italics><space/>&lt; is<space/><link><target>computably enumerable set</target><part>computably enumerable</part></link>; a real number with such a property is called a<space/><bold>left-c.e. real number</bold><space/>in<space/><link><target>recursion theory</target></link>.</listitem><listitem>The set of rational numbers<space/><italics>q</italics><space/>such that<space/><italics>q</italics><space/>&gt; is not computably enumerable.</listitem><listitem><space/>is an<space/><link><target>arithmetical number</target></link>.</listitem><listitem>It is<space/><link><target>Turing equivalent</target></link><space/>to the<space/><link><target>halting problem</target></link><space/>and thus at level<space/><extension extension_name='math'>\Delta^0_2</extension><space/>of the<space/><link><target>arithmetical hierarchy</target></link>.</listitem></list><paragraph>Not every set that is Turing equivalent to the halting problem is a halting probability. A<space/><link><target>equivalence relation#Comparing equivalence relations</target><part>finer</part></link><space/>equivalence relation,<space/><bold>Solovay equivalence</bold>, can be used to characterize the halting probabilities among the left-c.e. reals.</paragraph><heading level='2'>Uncomputability</heading><paragraph>A real number is called computable if there is an algorithm which, given<space/><italics>n</italics>, returns the first<space/><italics>n</italics><space/>digits of the number. This is equivalent to the existence of a program that enumerates the digits of the real number.</paragraph><paragraph>No halting probability is computable. The proof of this fact relies on an algorithm which, given the first<space/><italics>n</italics><space/>digits of , solves Turing's<space/><link><target>halting problem</target></link><space/>for programs of length up to<space/><italics>n</italics>. Since the halting problem is<space/><link><target>Undecidable problem</target><part>undecidable</part></link>, cannot be computed.</paragraph><paragraph>The algorithm proceeds as follows. Given the first<space/><italics>n</italics><space/>digits of and a<space/><italics>k</italics><italics>n</italics>, the algorithm enumerates the domain of<space/><italics>F</italics><space/>until enough elements of the domain have been found so that the probability they represent is within 2<xhtml:sup>(k+1)</xhtml:sup><space/>of . After this point, no additional program of length<space/><italics>k</italics><space/>can be in the domain, because each of these would add 2<xhtml:sup><italics>k</italics></xhtml:sup><space/>to the measure, which is impossible. Thus the set of strings of length<space/><italics>k</italics><space/>in the domain is exactly the set of such strings already enumerated.</paragraph><heading level='2'>Incompleteness theorem for halting probabilities</heading><paragraph><template><target>main</target><arg>Chaitin's incompleteness theorem</arg></template></paragraph><paragraph>For each specific consistent effectively represented<space/><link><target>axiomatic system</target></link><space/>for the<space/><link><target>natural numbers</target></link>, such as<space/><link><target>Peano axioms</target><part>Peano arithmetic</part></link>, there exists a constant<space/><italics>N</italics><space/>such that no bit of after the<space/><italics>N</italics>th can be proven to be 1 or 0 within that system. The constant<space/><italics>N</italics><space/>depends on how the<space/><link><target>formal system</target></link><space/>is effectively represented, and thus does not directly reflect the complexity of the axiomatic system. This incompleteness result is similar to<space/><link><target>Gdel's incompleteness theorem</target></link><space/>in that it shows that no consistent formal theory for arithmetic can be complete.</paragraph><heading level='2'>Super Omega</heading><paragraph>As mentioned above, the first n bits of<space/><link><target>Gregory Chaitin</target></link>'s constant Omega are random or incompressible in the sense that we cannot compute them by a halting algorithm with fewer than n-O(1) bits. However, consider the short but never halting algorithm which systematically lists and runs all possible programs; whenever one of them halts its probability gets added to the output (initialized by zero). After finite time the first n bits of the output will never change any more (it does not matter that this time itself is not computable by a halting program). So there is a short non-halting algorithm whose output converges (after finite time) onto the first n bits of Omega. In other words, the<space/><link><target>enumerable</target></link><space/>first n bits of Omega are highly compressible in the sense that they are<space/><link><target>limit-computable</target></link><space/>by a very short algorithm; they are not<space/><link><target>random</target></link><space/>with respect to the set of enumerating algorithms.<space/><link><target>Jrgen Schmidhuber</target></link><space/>(2000) constructed a limit-computable &quot;Super Omega&quot; which in a sense is much more random than the original limit-computable Omega, as one cannot significantly compress the Super Omega by any enumerating non-halting algorithm.</paragraph><paragraph>For an alternative &quot;Super Omega&quot;, the<space/><link><target>universality probability</target></link><space/>of a<space/><link><target>prefix-free_code</target><part>prefix-free</part></link><space/><link><target>Universal Turing Machine</target></link><space/>(<link><target>Universal Turing Machine</target><part>UTM</part></link>) - namely, the probability that it remains universal even when every input of it (as a<space/><link><target>binary string</target></link>) is prefixed by a random binary string - can be seen as the non-halting probability of a machine with oracle the third iteration of the<space/><link><target>halting problem</target></link>(i.e., 0``` = 0^{(3)})<extension extension_name='ref'><template><target>cite journal</target><arg name="author">Barmpalias, G. and Dowe D.L.<space/></arg><arg name="title">[http://dx.doi.org/10.1098/rsta.2011.0319 Universality probability of a prefix-free machine]<space/></arg><arg name="journal">Philosophical Transactions of the Royal Society A<space/></arg><arg name="volume">370<space/></arg><arg name="issue">1<space/></arg><arg name="pages">3488–3511 (Theme Issue 'The foundations of computation, physics and mentality: the Turing legacy' compiled and edited by Barry Cooper and Samson Abramsky)<space/></arg><arg name="date">2012<space/></arg></template></extension></paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Incompleteness theorem</target></link></listitem><listitem><link><target>Kolmogorov complexity</target></link></listitem></list><heading level='2'>References</heading><paragraph><extension extension_name='references'></extension></paragraph><list type='bullet'><listitem>Cristian S. Calude (2002).<space/><italics>Information and Randomness: An Algorithmic Perspective</italics>, second edition. Springer. ISBN 3-540-43466-6</listitem><listitem>Cristian S. Calude, Michael J. Dinneen, and Chi-Kou Shu.<space/><italics><link type='external' href='http://www.cs.auckland.ac.nz/~cristian/Calude361_370.pdf'>Computing a Glimpse of Randomness</link>.</italics></listitem><listitem>R. Downey, and D. Hirschfeldt (2010),<space/><italics>Algorithmic Randomness and Complexity</italics>, monograph in preparation, Springer-Verlag. Preliminary version can be found<space/><link type='external' href='http://www.mcs.vuw.ac.nz/~downey'>online</link>.</listitem><listitem>Ming Li and Paul Vitnyi (1997).<space/><italics>An Introduction to Kolmogorov Complexity and Its Applications</italics>. Springer.<space/><link type='external' href='http://citeseer.ist.psu.edu/li97introduction.html'>Introduction chapter full-text</link>.</listitem><listitem><link><target>Jrgen Schmidhuber</target></link><space/>(2000). Algorithmic Theories of Everything (arXiv: quant-ph/ 0011122). Journal reference: J. Schmidhuber (2002). Hierarchies of generalized Kolmogorov complexities and nonenumerable universal measures computable in the limit. International Journal of Foundations of Computer Science 13(4):587-612.</listitem></list><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://www.plus.maths.org.uk/issue37/features/omega/index.html'>Omega and why maths has no TOEs</link><space/>article based on one written by<space/><link><target>Gregory Chaitin</target></link><space/>which appeared in the August 2004 edition of Mathematics Today, on the occasion of the 50th anniversary of Alan Turing's death.</listitem><listitem><link type='external' href='http://www.umcs.maine.edu/~chaitin/sciamer3.pdf'>''The Limits of Reason''</link>, Gregory Chaitin, originally appeared in Scientific American, March 2006.</listitem><listitem><link type='external' href='http://www.idsia.ch/~juergen/kolmogorov.html'>Limit-computable Super Omega more random than Omega</link><space/>and generalizations of algorithmic information, by<space/><link><target>Jrgen Schmidhuber</target></link></listitem></list><paragraph><link><target>Category:Algorithmic information theory</target></link><link><target>Category:Theory of computation</target></link><link><target>Category:Real transcendental numbers</target></link></paragraph></article>