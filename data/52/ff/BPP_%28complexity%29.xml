<article title='BPP_%28complexity%29'><paragraph><template><target>unsolved</target><arg>computer science</arg><arg name="Is '''P''' {{">}} '''BPP''' ?</arg></template></paragraph><paragraph>In<space/><link><target>computational complexity theory</target></link>,<space/><bold>BPP</bold>, which stands for<space/><bold>bounded-error probabilistic polynomial time</bold><space/>is the class of<space/><link><target>decision problem</target><trail>s</trail></link><space/>solvable by a<space/><link><target>probabilistic Turing machine</target></link><space/>in<space/><link><target>polynomial time</target></link><space/>with an error<space/><link><target>probability</target></link><space/>bounded away from 1/3 for all instances.<bold>BPP</bold><space/>is one of the largest<space/><italics>practical</italics><space/>classes of problems, meaning most problems of interest in<space/><bold>BPP</bold><space/>have efficient<space/><link><target>probabilistic algorithm</target><trail>s</trail></link><space/>that can be run quickly on real modern machines.<space/><bold>BPP</bold><space/>also contains<space/><bold>P</bold>, the class of problems solvable in polynomial time with a deterministic machine, since a deterministic machine is a special case of a probabilistic machine.</paragraph><table class="wikitable" style="float:right; text-align:center; margin: 1em 0 1em 1em;"><tablerow><tablehead colspan="3">BPP algorithm (1 run)</tablehead></tablerow><tablerow><tablecell></tablecell><tablecell colspan="2">Answer produced</tablecell></tablerow><tablerow><tablecell>Correct<xhtml:br></xhtml:br>answer</tablecell><tablecell>YES</tablecell><tablecell>NO</tablecell></tablerow><tablerow><tablecell>YES</tablecell><tablecell><space/>2/3</tablecell><tablecell><space/>1/3</tablecell></tablerow><tablerow><tablecell>NO</tablecell><tablecell><space/>1/3</tablecell><tablecell><space/>2/3</tablecell></tablerow><tablerow><tablehead colspan="3">BPP algorithm (<italics>k</italics><space/>runs)</tablehead></tablerow><tablerow><tablecell></tablecell><tablecell colspan="2">Answer produced</tablecell></tablerow><tablerow><tablecell>Correct<xhtml:br></xhtml:br>answer</tablecell><tablecell>YES</tablecell><tablecell>NO</tablecell></tablerow><tablerow><tablecell>YES</tablecell><tablecell>&gt; 1 2<xhtml:sup><italics>ck</italics></xhtml:sup></tablecell><tablecell>&lt; 2<xhtml:sup><italics>ck</italics></xhtml:sup></tablecell></tablerow><tablerow><tablecell>NO</tablecell><tablecell>&lt; 2<xhtml:sup><italics>ck</italics></xhtml:sup></tablecell><tablecell>&gt; 1 2<xhtml:sup><italics>ck</italics></xhtml:sup></tablecell></tablerow><tablerow><tablecell colspan="3" style="font-size:85%">for some constant<space/><italics>c</italics><space/>&gt; 0</tablecell></tablerow></table><paragraph>Informally, a problem is in<space/><bold>BPP</bold><space/>if there is an algorithm for it that has the following properties:</paragraph><list type='bullet'><listitem>It is allowed to flip coins and make random decisions</listitem><listitem>It is guaranteed to run in polynomial time</listitem><listitem>On any given run of the algorithm, it has a probability of at most 1/3 of giving the wrong answer, whether the answer is YES or NO.</listitem></list><heading level='2'>Definition</heading><paragraph>A language<space/><italics>L</italics><space/>is in<space/><bold>BPP</bold><space/>if and only if there exists a probabilistic Turing machine<space/><italics>M</italics>, such that</paragraph><list type='bullet'><listitem><italics>M</italics><space/>runs for polynomial time on all inputs</listitem><listitem>For all<space/><italics>x</italics><space/>in<space/><italics>L</italics>,<space/><italics>M</italics><space/>outputs 1 with probability greater than or equal to 2/3</listitem><listitem>For all<space/><italics>x</italics><space/>not in<space/><italics>L</italics>,<space/><italics>M</italics><space/>outputs 1 with probability less than or equal to 1/3</listitem></list><paragraph>Unlike the complexity class<space/><bold><link><target>ZPP (complexity)</target><part>ZPP</part></link></bold>, the machine<space/><italics>M</italics><space/>is required to run for polynomial time on all inputs, regardless of the outcome of the random coin flips.</paragraph><paragraph>Alternatively,<space/><bold>BPP</bold><space/>can be defined using only deterministic Turing machines. A language<space/><italics>L</italics><space/>is in<space/><bold>BPP</bold><space/>if and only if there exists a polynomial<space/><italics>p</italics><space/>and deterministic Turing machine<space/><italics>M</italics>, such that</paragraph><list type='bullet'><listitem><italics>M</italics><space/>runs for polynomial time on all inputs</listitem><listitem>For all<space/><italics>x</italics><space/>in<space/><italics>L</italics>, the fraction of strings<space/><italics>y</italics><space/>of length<space/><italics>p</italics>(|<italics>x</italics>|) which satisfy<space/><italics>M(x,y)</italics><space/>= 1 is greater than or equal to 2/3</listitem><listitem>For all<space/><italics>x</italics><space/>not in<space/><italics>L</italics>, the fraction of strings<space/><italics>y</italics><space/>of length<space/><italics>p</italics>(|<italics>x</italics>|) which satisfy<space/><italics>M(x,y)</italics><space/>= 1 is less than or equal to 1/3</listitem></list><paragraph>In this definition, the string<space/><italics>y</italics><space/>corresponds to the output of the random coin flips that the probabilistic Turing machine would have made. For some applications this definition is preferable since it does not mention probabilistic Turing machines.</paragraph><paragraph>In practice, an error probability of 1/3 might not be acceptable, however, the choice of 1/3 in the definition is arbitrary. It can be any<space/><link><target>mathematical constant</target><part>constant</part></link><space/>between 0 and 1/2 (exclusive) and the set<space/><bold>BPP</bold><space/>will be unchanged. It does not even have to be constant: the same class of problems is defined by allowing error as high as 1/2<space/><italics>n</italics><xhtml:sup><italics>c</italics></xhtml:sup><space/>on the one hand, or requiring error as small as 2<xhtml:sup><italics>n<xhtml:sup>c</xhtml:sup></italics></xhtml:sup><space/>on the other hand, where<space/><italics>c</italics><space/>is any positive constant, and<space/><italics>n</italics><space/>is the length of input. The idea is that there is a probability of error, but if the algorithm is run many times, the chance that the majority of the runs are wrong<space/><link><target>exponential decay</target><part>drops off exponentially</part></link><space/>as a consequence of the<space/><link><target>Chernoff bound</target></link>.<extension extension_name='ref'><link type='external' href='http://www.cs.sfu.ca/~kabanets/cmpt710/lec16.pdf'></link></extension><space/>This makes it possible to create a highly accurate algorithm by merely running the algorithm several times and taking a &quot;majority vote&quot; of the answers. For example, if one defined the class with the restriction that the algorithm can be wrong with probability at most 1/2<xhtml:sup>100</xhtml:sup>, this would result in the same class of problems.</paragraph><heading level='2'>Problems</heading><paragraph><template><target>unsolved</target><arg>computer science</arg><arg name="Is '''P''' {{">}} '''BPP''' ?</arg></template>Besides the problems in<space/><bold>P</bold>, which are obviously in<space/><bold>BPP</bold>, many problems were known to be in<space/><bold>BPP</bold><space/>but not known to be in<space/><bold>P</bold>. The number of such problems is decreasing, and it is conjectured that<space/><bold>P</bold><space/>=<space/><bold>BPP</bold>.</paragraph><paragraph>For a long time, one of the most famous problems that was known to be in<space/><bold>BPP</bold><space/>but not known to be in<space/><bold>P</bold><space/>was the problem of<space/><link><target>primality test</target><part>determining</part></link><space/>whether a given number is<space/><link><target>prime number</target><part>prime</part></link>. However, in the 2002 paper<space/><italics><link><target>AKS primality test</target><part>PRIMES is in '''P'''</part></link></italics>,<space/><link><target>Manindra Agrawal</target></link><space/>and his students<space/><link><target>Neeraj Kayal</target></link><space/>and<space/><link><target>Nitin Saxena</target></link><space/>found a deterministic polynomial-time algorithm for this problem, thus showing that it is in<space/><bold>P</bold>.</paragraph><paragraph>An important example of a problem in<space/><bold>BPP</bold><space/>(in fact in<space/><bold><link><target>RP (complexity)</target><part>co-RP</part></link></bold>) still not known to be in<space/><bold>P</bold><space/>is<space/><link><target>polynomial identity testing</target></link>, the problem of determining whether a polynomial is identically equal to the zero polynomial, when you have access to the value of the polynomial for any given input, but not to the coefficients. In other words, is there an assignment of values to the variables such that when a nonzero polynomial is evaluated on these values, the result is nonzero? It suffices to choose each variable's value uniformly at random from a finite subset of at least<space/><italics>d</italics><space/>values to achieve bounded error probability, where<space/><italics>d</italics><space/>is the total degree of the polynomial.<extension extension_name='ref'>Madhu Sudan and Shien Jin Ong. Massachusetts Institute of Technology: 6.841/18.405J Advanced Complexity Theory:<space/><link type='external' href='http://people.csail.mit.edu/madhu/ST03/scribe/lect06.pdf'>Lecture 6: Randomized Algorithms, Properties of BPP</link>. February 26, 2003.</extension></paragraph><heading level='2'>Related classes</heading><paragraph>If the access to randomness is removed from the definition of<space/><bold>BPP</bold>, we get the complexity class<space/><bold>P</bold>. In the definition of the class, if we replace the ordinary<space/><link><target>Turing machine</target></link><space/>with a<space/><link><target>quantum computer</target></link>, we get the class<space/><bold><link><target>BQP</target></link></bold>.</paragraph><paragraph>Adding<space/><link><target>postselection</target></link><space/>to<space/><bold>BPP</bold>, or allowing computation paths to have different lengths, gives the class<space/><bold>BPP</bold><xhtml:sub>path</xhtml:sub>.<extension extension_name='ref'><link type='external' href='http://qwiki.stanford.edu/index.php/Complexity_Zoo:B#bpppath'></link></extension><space/><bold>BPP</bold><xhtml:sub>path</xhtml:sub><space/>is known to contain<space/><bold>NP</bold>, and it is contained in its quantum counterpart<space/><bold><link><target>PostBQP</target></link></bold>.</paragraph><paragraph>A<space/><link><target>Monte Carlo algorithm</target></link><space/>is a<space/><link><target>randomized algorithm</target></link><space/>which is likely to be correct. Problems in the class<space/><bold>BPP</bold><space/>have Monte Carlo algorithms with polynomial bounded running time. This is compared to a<space/><link><target>Las Vegas algorithm</target></link><space/>which is a randomized algorithm which either outputs the correct answer, or outputs &quot;fail&quot; with low probability. Las Vegas algorithms with polynomial bound running times are used to define the class<space/><bold><link><target>ZPP (complexity)</target><part>ZPP</part></link></bold>. Alternatively,<space/><bold>ZPP</bold><space/>contains probabilistic algorithms that are always correct and have expected polynomial running time. This is weaker than saying it is a polynomial time algorithm, since it may run for super-polynomial time, but with very low probability.</paragraph><heading level='2'>Complexity-theoretic properties</heading><paragraph><link><target>File:Randomized Complexity Classes.svg</target><part>thumb</part><part>BPP in relation to other probabilistic complexity classes</part></link></paragraph><paragraph>It is known that<space/><bold>BPP</bold><space/>is closed under<space/><link><target>Complement (complexity)</target><part>complement</part></link>; that is,<space/><bold>BPP</bold><space/>=<space/><bold>co-BPP</bold>.<space/><bold>BPP</bold><space/>is<space/><link><target>low (complexity)</target><part>low</part></link><space/>for itself, meaning that a<space/><bold>BPP</bold><space/>machine with the power to solve<space/><bold>BPP</bold><space/>problems instantly (a<space/><bold>BPP</bold><space/><link><target>oracle machine</target></link>) is not any more powerful than the machine without this extra power. In symbols,<space/><bold>BPP</bold><xhtml:sup><bold>BPP</bold></xhtml:sup><space/>=<space/><bold>BPP</bold>.</paragraph><paragraph>The relationship between<space/><bold>BPP</bold><space/>and<space/><bold><link><target>NP (complexity)</target><part>NP</part></link></bold><space/>is unknown: it is not known whether<space/><bold>BPP</bold><space/>is a<space/><link><target>subset</target></link><space/>of<space/><bold><link><target>NP (complexity)</target><part>NP</part></link></bold>,<space/><bold>NP</bold><space/>is a subset of<space/><bold>BPP</bold><space/>or neither. If<space/><bold>NP</bold><space/>is contained in<space/><bold>BPP</bold>, which is considered unlikely since it would imply practical solutions for<space/><link><target>NP-complete</target></link><space/>problems, then<space/><bold>NP</bold><space/>=<space/><bold>RP</bold><space/>and<space/><bold><link><target>PH (complexity)</target><part>PH</part></link></bold><space/><bold>BPP</bold>.<extension extension_name='ref'><link type='external' href='http://weblog.fortnow.com/2005/12/pulling-out-quantumness.html'></link></extension></paragraph><paragraph>It is known that<space/><bold><link><target>RP (complexity)</target><part>RP</part></link></bold><space/>is a subset of<space/><bold>BPP</bold>, and<space/><bold>BPP</bold><space/>is a subset of<space/><bold><link><target>PP (complexity)</target><part>PP</part></link></bold>. It is not known whether those two are strict subsets, since we don't even know if<space/><bold>P</bold><space/>is a strict subset of<space/><bold>PSPACE</bold>.<space/><bold>BPP</bold><space/>is contained in the second level of the<space/><link><target>polynomial hierarchy</target></link><space/>and therefore it is contained in<space/><bold>PH</bold>. More precisely, the<space/><link><target>SipserLautemann theorem</target></link><space/>states that<space/><extension extension_name='math'>\ BPP \subseteq \Sigma_2 \cap \Pi_2<space/></extension>. As a result,<space/><bold>P</bold><space/>=<space/><bold>NP</bold><space/>leads to<space/><bold>P</bold><space/>=<space/><bold>BPP</bold><space/>since<space/><bold>PH</bold><space/>collapses to<space/><bold>P</bold><space/>in this case. Thus either<space/><bold>P</bold><space/>=<space/><bold>BPP</bold><space/>or<space/><bold>P</bold><space/><bold>NP</bold><space/>or both.</paragraph><paragraph><link><target>Adleman's theorem</target></link><space/>states that membership in any language in<space/><bold>BPP</bold><space/>can be determined by a family of polynomial-size<space/><link><target>Boolean circuit</target><trail>s</trail></link>, which means<space/><bold>BPP</bold><space/>is contained in<space/><bold><link><target>P/poly</target></link></bold>.<extension extension_name='ref'><template><target>cite conference</target><arg name="author"><space/>[[Leonard Adleman|Adleman, L. M.]]<space/></arg><arg name="title"><space/>Two theorems on random polynomial time<space/></arg><arg name="booktitle"><space/>Proceedings of the Nineteenth Annual IEEE Symposium on Foundations of Computing<space/></arg><arg name="year"><space/>1978<space/></arg><arg name="pages"><space/>75–83</arg></template></extension><space/>Indeed, as a consequence of the proof of this fact, every<space/><bold>BPP</bold><space/>algorithm operating on inputs of bounded length can be derandomized into a deterministic algorithm using a fixed string of random bits. Finding this string may be expensive, however.</paragraph><heading level='3'>Relativization</heading><paragraph>Relative to oracles, we know that there exist oracles A and B, such that<space/><bold>P</bold><xhtml:sup>A</xhtml:sup><space/>=<space/><bold>BPP</bold><xhtml:sup>A</xhtml:sup><space/>and<space/><bold>P</bold><xhtml:sup>B</xhtml:sup><space/><bold>BPP</bold><xhtml:sup>B</xhtml:sup>. Moreover, relative to a<space/><link><target>random oracle</target></link><space/>with probability 1,<space/><bold>P</bold><space/>=<space/><bold>BPP</bold><space/>and<space/><bold>BPP</bold><space/>is strictly contained in<space/><bold>NP</bold><space/>and<space/><bold>co-NP</bold>.<extension extension_name='ref'><template><target>Citation</target><arg name="last1">Bennett<space/></arg><arg name="first1">Charles H.<space/></arg><arg name="author1-link">Charles H. Bennett (computer scientist)<space/></arg><arg name="last2">Gill<space/></arg><arg name="first2">John<space/></arg><arg name="title">Relative to a Random Oracle A, P^A !</arg><arg name="year">1981<space/></arg><arg name="journal">SIAM Journal on Computing<space/></arg><arg name="issn">1095-7111<space/></arg><arg name="volume">10<space/></arg><arg name="issue">1<space/></arg><arg name="pages">96–113<space/></arg><arg name="doi">10.1137/0210008</arg></template></extension></paragraph><paragraph>There is even an oracle in which BPP=EXP<xhtml:sup>NP</xhtml:sup><space/>(and hence P&amp;lt;NP&amp;lt;BPP=EXP=NEXP),<extension extension_name='ref'><template><target>Citation</target><arg name="last">Heller<space/></arg><arg name="first">Hans<space/></arg><arg name="title">On relativized exponential and probabilistic complexity classes<space/></arg><arg name="year">1986<space/></arg><arg name="journal">Information and Control<space/></arg><arg name="volume">71<space/></arg><arg name="issue">3<space/></arg><arg name="pages">231–243<space/></arg><arg name="doi">10.1016/S0019-9958(86)80012-2</arg></template></extension><space/>which can be iteratively constructed as follows. For a fixed<space/><link><target>E (complexity)</target><part>E</part></link><xhtml:sup>NP</xhtml:sup><space/>(relativized) complete problem, the oracle will give correct answers with high probability if queried with the problem instance followed by a random string of length<space/><italics>kn</italics><space/>(<italics>n</italics><space/>is instance length;<space/><italics>k</italics><space/>is an appropriate small constant). Start with<space/><italics>n</italics>=1. For every instance of the problem of length<space/><italics>n</italics><space/>fix oracle answers (see lemma below) to fix the instance output. Next, provide the instance outputs for queries consisting of the instance followed by<space/><italics>kn</italics>-length string, and then treat output for queries of length (<italics>k</italics>+1)<italics>n</italics><space/>as fixed, and proceed with instances of length<space/><italics>n</italics>+1.</paragraph><paragraph><bold>Lemma:</bold><space/>Given a problem (specifically, an oracle machine code and time constraint) in relativized E<xhtml:sup>NP</xhtml:sup>, for every partially constructed oracle and input of length<space/><italics>n</italics>, the output can be fixed by specifying 2<xhtml:sup><italics>O</italics>(<italics>n</italics>)</xhtml:sup><space/>oracle answers.<xhtml:br></xhtml:br><bold>Proof:</bold><space/>The machine is simulated, and the oracle answers (that are not already fixed) are fixed step-by-step. There is at most one oracle query per deterministic computation step. For the relativized NP oracle, if possible fix the output to be yes by choosing a computation path and fixing the answers of the base oracle; otherwise no fixing is necessary, and either way there is at most 1 answer of the base oracle per step. Since there are 2<xhtml:sup><italics>O</italics>(<italics>n</italics>)</xhtml:sup><space/>steps, the lemma follows.</paragraph><paragraph>The lemma ensures that (for a large enough<space/><italics>k</italics>), it is possible to do the construction while leaving enough strings for the relativized E<xhtml:sup>NP</xhtml:sup><space/>answers. Also, we can ensure that for the relativized E<xhtml:sup>NP</xhtml:sup>, linear time suffices, even for function problems (if given a function oracle and linear output size) and with exponentially small (with linear exponent) error probability. Also for a<space/><link><target>ZPP (complexity)</target><part>ZPP</part></link>=EXP oracle (and hence ZPP=BPP=EXP&amp;lt;NEXP), one would fix the answers in the relativized E computation to a special nonanswer, thus ensuring that no fake answers are given.</paragraph><heading level='2'>Derandomization</heading><paragraph>The existence of certain strong<space/><link><target>pseudorandom number generators</target></link><space/>is<space/><link><target>conjecture</target><trail>d</trail></link><space/>by most experts of the field. This conjecture implies that randomness does not give additional computational power to polynomial time computation, that is,<space/><bold>P</bold><space/>=<space/><bold>RP</bold><space/>=<space/><bold>BPP</bold>. Note that ordinary generators are not sufficient to show this result; any probabilistic algorithm implemented using a typical random number generator will always produce incorrect results on certain inputs irrespective of the seed (though these inputs might be rare).<template><target>citation needed</target><arg name="date">September 2015</arg></template></paragraph><paragraph><link><target>Lszl Babai</target></link>,<space/><link><target>Lance Fortnow</target></link>,<space/><link><target>Noam Nisan</target></link>, and<space/><link><target>Avi Wigderson</target></link><space/>showed that unless<space/><bold><link><target>EXPTIME</target></link></bold><space/>collapses to<space/><bold><link><target>MA (complexity)</target><part>MA</part></link></bold>,<space/><bold>BPP</bold><space/>is contained in<extension extension_name='ref' name="Babai"><template><target>cite journal</target><arg name="last1"><space/>Babai<space/></arg><arg name="first1"><space/>László<space/></arg><arg name="last2"><space/>Fortnow<space/></arg><arg name="first2"><space/>Lance<space/></arg><arg name="last3"><space/>Nisan<space/></arg><arg name="first3"><space/>Noam<space/></arg><arg name="last4"><space/>Wigderson<space/></arg><arg name="first4"><space/>Avi<space/></arg><arg name="year"><space/>1993<space/></arg><arg name="title"><space/>'''BPP''' has subexponential time simulations unless '''EXPTIME''' has publishable proofs<space/></arg><arg name="url"><space/></arg><arg name="journal"><space/>Computational Complexity<space/></arg><arg name="volume"><space/>3<space/></arg><arg name="issue"><space/></arg><arg name="pages"><space/>307–318<space/></arg><arg name="doi">10.1007/bf01275486</arg></template></extension><space/></paragraph><list type='ident'><listitem><extension extension_name='math'>\mathbf{i.o.-SUBEXP} = \bigcap\nolimits_{\varepsilon&gt;0} \mathbf{i.o.-DTIME} \left (2^{n^\varepsilon} \right).</extension><space/></listitem></list><paragraph>The class<space/><bold>i.o.-SUBEXP</bold>, which stands for infinitely often<space/><bold>SUBEXP</bold>, contains problems which have<space/><link><target>sub-exponential time</target></link><space/>algorithms for infinitely many input sizes. They also showed that<space/><bold>P</bold><space/>=<space/><bold>BPP</bold><space/>if the exponential-time hierarchy, which is defined in terms of the<space/><link><target>polynomial hierarchy</target></link><space/>and<space/><bold>E</bold><space/>as<space/><bold>E<xhtml:sup>PH</xhtml:sup></bold>, collapses to<space/><bold>E</bold>; however, note that the exponential-time hierarchy is usually conjectured<space/><italics>not</italics><space/>to collapse.</paragraph><paragraph><link><target>Russell Impagliazzo</target></link><space/>and Avi Wigderson showed that if any problem in<space/><bold><link><target>E (complexity)</target><part>E</part></link></bold>, where<space/></paragraph><list type='ident'><listitem><extension extension_name='math'>\mathbf{E} = \mathbf{DTIME} \left( 2^{O(n)} \right),</extension><space/></listitem></list><paragraph>has circuit complexity 2<xhtml:sup>(<italics>n</italics>)</xhtml:sup><space/>then<space/><bold>P</bold><space/>=<space/><bold>BPP</bold>.<extension extension_name='ref'>Russell Impagliazzo and Avi Wigderson (1997). &quot;<bold>P</bold>&amp;nbsp;=&amp;nbsp;<bold>BPP</bold><space/>if E requires exponential circuits: Derandomizing the XOR Lemma&quot;.<space/><italics>Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing</italics>, pp. 220229.<space/><template><target>doi</target><arg>10.1145/258533.258590</arg></template></extension></paragraph><heading level='2'>References</heading><paragraph><extension extension_name='references'></extension></paragraph><list type='bullet'><listitem><xhtml:span id="Kabanets">Valentine Kabanets (2003). &quot;CMPT 710 Complexity Theory: Lecture 16&quot;.<space/><link><target>Simon Fraser University</target></link>.</xhtml:span></listitem><listitem><template><target>cite book</target><arg name="author"><space/>[[Christos Papadimitriou]]<space/></arg><arg name="year"><space/>1993<space/></arg><arg name="title"><space/>Computational Complexity<space/></arg><arg name="publisher"><space/>Addison Wesley<space/></arg><arg name="edition"><space/>1st<space/></arg><arg name="isbn"><space/>0-201-53082-1</arg></template><space/>Pages 257259 of section 11.3: Random Sources. Pages 269271 of section 11.4: Circuit complexity.</listitem><listitem><template><target>cite book</target><arg name="author"><space/>[[Michael Sipser]]<space/></arg><arg name="year"><space/>1997<space/></arg><arg name="title"><space/>Introduction to the Theory of Computation<space/></arg><arg name="publisher"><space/>PWS Publishing<space/></arg><arg name="isbn"><space/>0-534-94728-X</arg></template><space/>Section 10.2.1: The class BPP, pp.&amp;nbsp;336339.</listitem></list><heading level='2'>External links</heading><list type='bullet'><listitem><link type='external' href='http://www.cs.princeton.edu/courses/archive/fall03/cs597E/'>Princeton CS 597E: Derandomization paper list</link></listitem><listitem><link type='external' href='http://www.courses.fas.harvard.edu/~cs225/'>Harvard CS 225: Pseudorandomness</link></listitem></list><paragraph><template><target>ComplexityClasses</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Bpp</target></template><link><target>Category:Probabilistic complexity classes</target></link></paragraph></article>