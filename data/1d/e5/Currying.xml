<article title='Currying'><paragraph><template><target>about</target><arg>the mathematical technique</arg><arg>the cooking process of this name</arg><arg>Curry</arg><arg>the leather finishing process</arg><arg>Currier</arg></template>In<space/><link><target>mathematics</target></link><space/>and<space/><link><target>computer science</target></link>,<space/><bold>currying</bold><space/>is the technique of translating the evaluation of a<space/><link><target>function (mathematics)</target><part>function</part></link><space/>that takes multiple<space/><link><target>parameter (computer science)</target><part>arguments</part></link><space/>(or a<space/><link><target>tuple</target></link><space/>of arguments) into evaluating a sequence of functions, each with a single argument. It was introduced by<space/><link><target>Moses Schnfinkel</target></link><extension extension_name='ref'><template><target>cite journal</target><arg name="first">Christopher</arg><arg name="last">Strachey</arg><arg name="authorlink">Christopher Strachey</arg><arg name="title">Fundamental Concepts in Programming Languages</arg><arg name="journal">[[Higher-Order and Symbolic Computation]]</arg><arg name="volume">13</arg><arg name="pages">11–49</arg><arg name="year">2000</arg><arg name="quote">There is a device originated by Schönfinkel, for reducing operators with several operands to the successive application of single operand operators.</arg><arg name="doi">10.1023/A:1010000313106</arg><arg name="ref">harv</arg></template><space/>(Reprinted lecture notes from 1967.)</extension><extension extension_name='ref'><template><target>cite journal</target><arg name="first">John C.</arg><arg name="last">Reynolds</arg><arg name="authorlink">John C. Reynolds</arg><arg name="title">Definitional Interpreters for Higher-Order Programming Languages<space/></arg><arg name="journal">[[Higher-Order and Symbolic Computation]]</arg><arg name="volume">11</arg><arg name="issue">4</arg><arg name="page">374</arg><arg name="doi">10.1023/A:1010027404223</arg><arg name="quote">In the last line we have used a trick called Currying (after the logician H. Curry) to solve the problem of introducing a binary operation into a language where all functions must accept a single argument. (The referee comments that although "Currying" is tastier, "Schönfinkeling” might be more accurate.)</arg><arg name="year">1998</arg><arg name="ref">harv</arg></template></extension><extension extension_name='ref'>Kenneth Slonneger and Barry L. Kurtz.<space/><italics>Formal Syntax and Semantics of Programming Languages</italics>. p.&amp;nbsp;144.</extension>and later developed by<space/><link><target>Haskell Curry</target></link>.<extension extension_name='ref'>Henk Barendregt, Erik Barendsen, &quot;<link type='external' href='ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf'>Introduction to Lambda Calculus</link>&quot;, March 2000, page&amp;nbsp;8.</extension><extension extension_name='ref'><template><target>cite book</target><arg name="last">Curry</arg><arg name="first">Haskell</arg><arg name="author2">Feys, Robert</arg><arg name="title">Combinatory logic</arg><arg name="publisher">North-Holland Publishing Company<space/></arg><arg name="volume">I</arg><arg name="edition">2</arg><arg name="year">1958</arg><arg name="location">Amsterdam, Netherlands</arg></template></extension></paragraph><paragraph><bold>Uncurrying</bold><space/>is the<space/><link><target>Duality (mathematics)</target><part>dual</part></link><space/>transformation to currying, and can be seen as a form of<space/><link><target>defunctionalization</target></link>. It takes a function<space/><italics>f</italics>(<italics>x</italics>) that returns another function<space/><italics>g</italics>(<italics>y</italics>) as a result, and yields a new function<space/><template><target>nowrap</target><arg name="1">''f''′(''x'', ''y'')</arg></template><space/>that takes a number of additional parameters and applies them to the function returned by function<space/><italics>f</italics>. The process can be iterated.</paragraph><heading level='2'>Motivation</heading><paragraph>There are analytical techniques that can only be applied to<space/><link><target>function (mathematics)</target><part>function</part><trail>s</trail></link><space/>with a single argument. Practical functions frequently take more arguments than this.<space/><link><target>Gottlob Frege</target><part>Frege</part></link><space/>showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying.<extension extension_name='ref'><link type='external' href='http://www.cs.nott.ac.uk/~gmh/faq.html#currying'>Frequently Asked Questions for comp.lang.functional: Currying</link><space/>by<space/><link><target>Graham Hutton</target></link></extension></paragraph><paragraph>Currying is similar to the process of calculating a function of multiple variables for some given values on paper.</paragraph><paragraph>For example, given the function<space/><extension extension_name='math'>f(x,y) = y / x</extension>:</paragraph><list type='ident'><listitem>To evaluate<space/><extension extension_name='math'>f(2,3)</extension>, first replace<space/><extension extension_name='math'>x</extension><space/>with<space/><extension extension_name='math'>2</extension></listitem></list><list type='ident'><listitem>Since the result is a function of<space/><extension extension_name='math'>y</extension>, this new function<space/><extension extension_name='math'>g(y)</extension><space/>can be defined as<space/><extension extension_name='math'>g(y) = f(2,y) = y/2</extension></listitem></list><list type='ident'><listitem>Next, replace the<space/><extension extension_name='math'>y</extension><space/>argument with<space/><extension extension_name='math'>3</extension>, producing<space/><extension extension_name='math'>g(3) = f(2,3) = 3/2</extension></listitem></list><paragraph>On paper, using classical notation, this is usually done all in one step. However, each argument can be replaced sequentially as well. Each replacement results in a function taking exactly one argument. This produces a chain of functions as in<space/><link><target>lambda calculus</target></link>, and multi-argument functions are usually represented in curried form.</paragraph><paragraph>Some<space/><link><target>programming language</target><trail>s</trail></link><space/>almost always use curried functions to achieve multiple arguments; notable examples are<space/><link><target>ML programming language</target><part>ML</part></link><space/>and<space/><link><target>Haskell (programming language)</target><part>Haskell</part></link>, where in both cases all functions have exactly one argument.</paragraph><paragraph>If we let<space/><italics>f</italics><space/>be a function</paragraph><list type='ident'><listitem><extension extension_name='math'>f(x,y) = \frac{y}{x}</extension></listitem></list><paragraph>then the function<space/><italics>h</italics><space/>where</paragraph><list type='ident'><listitem><extension extension_name='math'>h(x) = y \mapsto f(x,y)</extension></listitem></list><paragraph>is a curried version of<space/><extension extension_name='math'>f</extension>. Here,<space/><extension extension_name='math'>y \mapsto z</extension><space/>is a function that<space/><link><target>map (higher-order function)</target><part>map</part><trail>s</trail></link><space/>an argument<space/><italics>y</italics><space/>to result<space/><italics>z</italics>. In particular,</paragraph><list type='ident'><listitem><extension extension_name='math'>g(y) = h(2) = y \mapsto f(2,y)</extension></listitem></list><paragraph>is the curried equivalent of the example above.<space/></paragraph><paragraph>Note that currying, while similar,<space/><link><target>#Contrast with partial function application</target><part>is not the same operation as partial function application</part></link>.</paragraph><heading level='2'>Definition</heading><paragraph>Given a function<space/><extension extension_name='math'>f</extension><space/>of type<space/><extension extension_name='math'>f \colon (X \times Y) \to Z<space/></extension>,<space/><bold>currying</bold><space/>it makes a function<space/><extension extension_name='math'>\text{curry}(f) \colon X \to (Y \to Z)<space/></extension>. That is,<space/><extension extension_name='math'>\text{curry}(f)<space/></extension><space/>takes an argument of type<space/><extension extension_name='math'>X<space/></extension><space/>and returns a function of type<space/><extension extension_name='math'>Y \to Z<space/></extension>.<space/><bold>Uncurrying</bold><space/>is the reverse transformation, and is most easily understood in terms of its right adjoint,<space/><link><target>apply</target></link>.</paragraph><paragraph>The operator is often considered<space/><link><target>right-associative</target></link>, so the curried function type<space/><extension extension_name='math'>X \to (Y \to Z)</extension><space/>is often written as<space/><extension extension_name='math'>X \to Y \to Z</extension>. Conversely,<space/><link><target>function application</target></link><space/>is considered to be left-associative, so that<space/><extension extension_name='math'>f \; \langle x, y \rangle</extension><space/>is equivalent to<space/><extension extension_name='math'>\text{curry}(f) \; x \; y</extension>.</paragraph><paragraph>Curried functions may be used in any language that supports<space/><link><target>closure (computer science)</target><part>closure</part><trail>s</trail></link>; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.</paragraph><heading level='2'>Mathematical view</heading><paragraph>In<space/><link><target>theoretical computer science</target></link>, currying provides a way to study functions with multiple arguments in very simple theoretical models such as the<space/><link><target>lambda calculus</target></link><space/>in which functions only take a single argument.</paragraph><paragraph>In a set-theoretic paradigm, currying is the natural correspondence between the set<space/><extension extension_name='math'>A^{B\times C}</extension><space/>of functions from<space/><extension extension_name='math'>B\times C</extension><space/>to<space/><extension extension_name='math'>A</extension>, and the set<space/><extension extension_name='math'>\left(A^C\right)^B</extension><space/>of functions from<space/><extension extension_name='math'>B</extension><space/>to the set of functions from<space/><extension extension_name='math'>C</extension><space/>to<space/><extension extension_name='math'>A</extension>. In<space/><link><target>category theory</target></link>, currying can be found in the<space/><link><target>universal property</target></link><space/>of an<space/><link><target>exponential object</target></link>, which gives rise to the following adjunction in<space/><link><target>cartesian closed category</target><part>cartesian closed categories</part></link>: There is a<space/><link><target>Natural transformation</target><part>natural</part></link><space/><link><target>isomorphism</target></link><space/>between the<space/><link><target>morphism (category theory)</target><part>morphism</part><trail>s</trail></link><space/>from a<space/><link><target>product (category theory)</target><part>binary product</part></link><space/><extension extension_name='math'>f \colon (X \times Y) \to Z<space/></extension><space/>and the morphisms to an exponential object<space/><extension extension_name='math'>g \colon X \to Z^Y<space/></extension>. In other words, currying is the statement that<space/><link><target>Product (category theory)</target><part>product</part></link><space/>and<space/><link><target>Hom functor</target><part>Hom</part></link><space/>are<space/><link><target>adjoint functors</target></link>; that is, there is a<space/><link><target>natural transformation</target></link>:<space/></paragraph><list type='ident'><listitem><extension extension_name='math'><space/>\hom(A\times B, C) \cong \hom(A, C^B) .</extension></listitem></list><paragraph>This is the key property of being a<space/><link><target>Cartesian closed category</target></link>, and more generally, a<space/><link><target>closed monoidal category</target></link>.<extension extension_name='ref'><template><target>nlab</target><arg name="id">currying</arg><arg name="title">Currying</arg></template></extension><space/>The latter, though more rarely discussed, is interesting, as it is the suitable setting for<space/><link><target>quantum computation</target></link>,<extension extension_name='ref'>Samson Abramsky and Bob Coecke, &quot;A Categorical Semantics for Quantum Protocols&quot;, &quot;<link type='external' href='http://arxiv.org/abs/quantph/0402130/'></link>.</extension><space/>whereas the former is sufficient for classical logic. The difference is that the<space/><link><target>Cartesian product</target></link><space/>can be interpreted simply as a pair of items (or a list), whereas the<space/><link><target>tensor product</target></link>, used to define a<space/><link><target>monoidal category</target></link>, is suitable for describing<space/><link><target>entangled quantum states</target></link>.<extension extension_name='ref'>John c. Baez and Mike Stay, &quot;<link type='external' href='http://math.ucr.edu/home/baez/rosetta/rose3.pdf'>Physics, Topology, Logic and Computation: A Rosetta Stone</link>&quot;, (2009)<space/><link type='external' href='http://arxiv.org/abs/0903.0340/'>ArXiv 0903.0340</link><space/>in<space/><italics>New Structures for Physics</italics>, ed. Bob Coecke,<space/><italics>Lecture Notes in Physics</italics><space/>vol.<space/><bold>813</bold>, Springer, Berlin, 2011, pp. 95-174.</extension></paragraph><paragraph>Under the<space/><link><target>CurryHoward correspondence</target></link>, the existence of currying and uncurrying is equivalent to the logical theorem<space/><extension extension_name='math'>(A \and B) \to C \Leftrightarrow A \to (B \to C)</extension>, as<space/><link><target>tuple</target><trail>s</trail></link><space/>(<link><target>product type</target></link>) corresponds to conjunction in logic, and function type corresponds to implication.</paragraph><paragraph>Curry is a<space/><link><target>continuous function</target></link><space/>in the<space/><link><target>Scott topology</target></link>.<extension extension_name='ref'><template><target>cite book</target><arg name="last1">Barendregt<space/></arg><arg name="first1">H.P.<space/></arg><arg name="authorlink1">Henk Barendregt<space/></arg><arg name="title">The Lambda Calculus<space/></arg><arg name="year">1984<space/></arg><arg name="publisher">North-Holland<space/></arg><arg name="isbn">0-444-87508-5</arg></template><space/><italics>(See theorems 1.2.13, 1.2.14)</italics></extension></paragraph><heading level='2'>Naming</heading><paragraph>The name &quot;currying&quot;, coined by<space/><link><target>Christopher Strachey</target></link><space/>in 1967, is a reference to logician<space/><link><target>Haskell Curry</target></link>. The alternative name &quot;Schnfinkelisation&quot; has been proposed as a reference to<space/><link><target>Moses Schnfinkel</target></link>.<extension extension_name='ref'>I. Heim and A. Kratzer (1998).<space/><italics>Semantics in Generative Grammar</italics>. Blackwell.</extension><space/>In the mathematical context, the principle can be traced back to work in 1893 by<space/><link><target>Gottlob Frege</target><part>Frege</part></link>.</paragraph><heading level='2'>Contrast with partial function application</heading><paragraph><template><target>main</target><arg>Partial application</arg></template>Currying and partial function application are often conflated.<extension extension_name='ref'><link type='external' href='http://www.uncarved.com/blog/not_currying.mrk'>Partial Function Application is not Currying</link></extension><space/>One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose<space/><link><target>arity</target></link><space/>is greater than two.<extension extension_name='ref'><link type='external' href='http://slid.es/gsklee/functional-programming-in-5-minutes'>Functional Programming in 5 Minutes</link></extension></paragraph><paragraph>Given a function of type<space/><extension extension_name='math'>f \colon (X \times Y \times Z) \to N<space/></extension>, currying produces<space/><extension extension_name='math'>\text{curry}(f) \colon X \to (Y \to (Z \to N))<space/></extension>. That is, while an evaluation of the first function might be represented as<space/><extension extension_name='math'>f(1, 2, 3)</extension>, evaluation of the curried function would be represented as<space/><extension extension_name='math'>f_\text{curried}(1)(2)(3)</extension>, applying each argument in turn to a single-argument function returned by the previous invocation. Note that after calling<space/><extension extension_name='math'>f_\text{curried}(1)</extension>, we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.</paragraph><paragraph>In contrast,<space/><bold>partial function application</bold><space/>refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. Given the definition of<space/><extension extension_name='math'>f</extension><space/>above, we might fix (or 'bind') the first argument, producing a function of type<space/><extension extension_name='math'>\text{partial}(f) \colon (Y \times Z) \to N</extension>. Evaluation of this function might be represented as<space/><extension extension_name='math'>f_\text{partial}(2, 3)</extension>. Note that the result of partial function application in this case is a function that takes two arguments.</paragraph><paragraph>Intuitively, partial function application says &quot;if you fix the first<space/><link><target>parameter (computer science)</target><part>argument</part><trail>s</trail></link><space/>of the function, you get a function of the remaining arguments&quot;. For example, if function<space/><italics>div</italics><space/>stands for the division operation<space/><italics>x</italics>/<italics>y</italics>, then<space/><italics>div</italics><space/>with the parameter<space/><italics>x</italics><space/>fixed at 1 (i.e.,<space/><italics>div</italics><space/>1) is another function: the same as the function<space/><italics>inv</italics><space/>that returns the multiplicative inverse of its argument, defined by<space/><italics>inv</italics>(<italics>y</italics>) =&amp;nbsp;1/<italics>y</italics>.</paragraph><paragraph>The practical motivation for partial application is that very often the functions obtained by supplying some but not all of the arguments to a function are useful; for example, many languages have a function or operator similar to<space/><xhtml:code>plus_one</xhtml:code>. Partial application makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.</paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Lazy evaluation</target></link></listitem><listitem><link><target>Closure (computer science)</target></link></listitem><listitem><link><target>smn theorem</target><part>s<xhtml:sub>mn</xhtml:sub><space/>theorem</part></link></listitem><listitem><link><target>Closed monoidal category</target></link></listitem></list><heading level='2'>Notes</heading><paragraph><template><target>reflist</target><arg>2</arg></template></paragraph><heading level='2'>References</heading><list type='bullet'><listitem><template><target>cite journal</target><arg name="last">Schönfinkel</arg><arg name="first">Moses</arg><arg name="title">Über die Bausteine der mathematischen Logik</arg><arg name="journal">[[Math. Ann.]]</arg><arg name="volume">92</arg><arg name="year">1924</arg><arg name="pages">305–316</arg><arg name="doi">10.1007/BF01448013</arg><arg name="issue">3–4</arg><arg name="ref">harv</arg></template></listitem><listitem><template><target>Cite journal</target><arg name="last"><space/>Heim
<space/></arg><arg name="first"><space/>Irene
<space/></arg><arg name="author-link"><space/>
<space/></arg><arg name="last2"><space/>Kratzer
<space/></arg><arg name="first2"><space/>Angelika
<space/></arg><arg name="author2-link"><space/>
<space/></arg><arg name="title"><space/>Semantics in a Generative Grammar
<space/></arg><arg name="place"><space/>Malden
<space/></arg><arg name="publisher"><space/>Blackwall Publishers
<space/></arg><arg name="year"><space/>1998
<space/></arg><arg name="volume"><space/>
<space/></arg><arg name="edition"><space/>
<space/></arg><arg name="url">
<space/></arg><arg name="doi"><space/>
<space/></arg><arg name="id"><space/>
<space/></arg><arg name="isbn">
<space/></arg><arg name="ref"><space/>harv
<space/></arg><arg name="postscript"><space/>{{inconsistent citations}}<space/></arg></template></listitem></list><heading level='2'>External links</heading><paragraph><template><target>Wiktionary</target><arg>currying</arg></template></paragraph><list type='bullet'><listitem><link type='external' href='http://c2.com/cgi/wiki?CurryingSchonfinkelling'>Currying Schonfinkelling</link><space/>at the<space/><link><target>Portland Pattern Repository</target></link></listitem><listitem><link type='external' href='http://lambda-the-ultimate.org/node/2266'>Currying != Generalized Partial Application!</link><space/>- post at Lambda-the-Ultimate.org</listitem></list><paragraph><link><target>Category:Higher-order functions</target></link><link><target>Category:Functional programming</target></link><link><target>Category:Lambda calculus</target></link><link><target>Category:Articles with example Java code</target></link></paragraph></article>