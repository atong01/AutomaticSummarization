<article title='Computer_program'><paragraph><template><target>for</target><arg>the TV programme</arg><arg>The Computer Programme</arg></template></paragraph><table class="infobox" style="width:25em"><tablerow><tablecell><paragraph><extension extension_name='source' lang="pascal"><paragraph>program hello;begin</paragraph><preblock><preline><space/>writeln('Hello, World!');</preline></preblock><paragraph>end.</paragraph></extension></paragraph></tablecell></tablerow><tablerow><tablecell>Source code of a<space/><link><target>&quot;Hello, World!&quot; program</target></link><space/>written in the<space/><link><target>Pascal (programming language)</target><part>Pascal programming language</part></link>.</tablecell></tablerow></table><paragraph>A<space/><bold>computer program</bold><space/>is a collection of<space/><link><target>instruction set</target><part>instructions</part></link>,<extension extension_name='ref' name="aup-ch4-p132"><template><target>cite book</target><arg name="last"><space/>Rochkind
<space/></arg><arg name="first"><space/>Marc J.
<space/></arg><arg name="title"><space/>Advanced Unix Programming, Second Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>2004
<space/></arg><arg name="page"><space/>1.1.2
</arg></template></extension><space/>performing a specific task when<space/><link><target>execution (computing)</target><part>executed</part></link><space/>by a<space/><link><target>computer</target></link>. A computer requires programs to function, and typically executes the program's instructions in a<space/><link><target>central processing unit</target></link>.<extension extension_name='ref' name="osc-ch3-p58"><template><target>cite book</target><arg name="last"><space/>Silberschatz
<space/></arg><arg name="first"><space/>Abraham
<space/></arg><arg name="title"><space/>Operating System Concepts, Fourth Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1994
<space/></arg><arg name="page"><space/>58
<space/></arg><arg name="isbn"><space/>0-201-50480-4
</arg></template></extension></paragraph><paragraph>A computer program is usually written by a<space/><link><target>computer programmer</target></link><space/>in a<space/><link><target>programming language</target></link>. From the program in its human-readable form of<space/><link><target>source code</target></link>, a<space/><link><target>compiler</target></link><space/>can derive<space/><link><target>machine code</target></link>a form consisting of instructions that the computer can directly execute. Alternatively, a computer program may be executed with the aid of an<space/><link><target>interpreter (computing)</target><part>interpreter</part></link>.</paragraph><paragraph>A part of a computer program that performs a well-defined task is known as an<space/><link><target>algorithm</target></link>. A collection of computer programs,<space/><link><target>Library (computing)</target><part>libraries</part></link><space/>and related<space/><link><target>Data (computing)</target><part>data</part></link><space/>are referred to as<space/><link><target>software</target></link>. Computer programs may be categorized along functional lines, such as<space/><link><target>application software</target></link><space/>or<space/><link><target>system software</target></link>.</paragraph><heading level='2'>History</heading><paragraph><template><target>See also</target><arg>History of computing</arg><arg>History of programming languages</arg><arg>History of software</arg></template></paragraph><heading level='3'>Early programmable machines</heading><paragraph>The earliest programmable machines preceded the<space/><link><target>History of computing hardware</target><part>invention of the digital computer</part></link>. In 1801,<space/><link><target>Joseph-Marie Jacquard</target></link><space/>devised a<space/><link><target>Jacquard loom</target><part>loom</part></link><space/>that would weave a pattern by following a series of perforated cards. Patterns, including flowers and leaves, could be weaved and repeated by arranging the cards.<extension extension_name='ref' name="eniac-ch1-p16"><template><target>cite book</target><arg name="last"><space/>McCartney
<space/></arg><arg name="first"><space/>Scott
<space/></arg><arg name="title"><space/>ENIAC – The Triumphs and Tragedies of the World's First Computer
<space/></arg><arg name="publisher"><space/>Walker and Company
<space/></arg><arg name="year"><space/>1999
<space/></arg><arg name="page"><space/>16
<space/></arg><arg name="isbn"><space/>0-8027-1348-3
</arg></template></extension></paragraph><heading level='3'>Analytical Engine</heading><paragraph><link><target>File:Diagram for the computation of Bernoulli numbers.jpg</target><part>thumb</part><part>right</part><part>Lovelace's diagram from Note G, the<space/><link><target>Ada Lovelace#First computer program</target><part>first published computer algorithm</part></link></part></link>In 1837,<space/><link><target>Charles Babbage</target></link><space/>was inspired by Jacquard's loom to attempt to build the<space/><link><target>Analytical engine</target><part>Analytical Engine</part></link>.<extension extension_name='ref' name="eniac-ch1-p16"></extension>The names of the components of the calculating device were borrowed from the textile industry. In the textile industry, yarn was brought from the store to be milled. The device would have had a &quot;store&quot;memory to hold 1,000 numbers of 40 decimal digits each. Numbers from the &quot;store&quot; would then have then been transferred to the &quot;mill&quot; (analogous to the CPU of a modern machine), for processing. It was programmed using two sets of perforated cardsone to direct the operation and the other for the input variables.<extension extension_name='ref' name="eniac-ch1-p16"></extension><extension extension_name='ref'><template><target>cite journal</target><arg name="first"><space/>Allan G.
<space/></arg><arg name="last"><space/>Bromley
<space/></arg><arg name="authorlink"><space/>Allan G. Bromley
<space/></arg><arg name="year"><space/>1998
<space/></arg><arg name="url"><space/>http://profs.scienze.univr.it/~manca/storia-informatica/babbage.pdf
<space/></arg><arg name="title"><space/>Charles Babbage’s Analytical Engine, 1838
<space/></arg><arg name="journal"><space/>[[IEEE Annals of the History of Computing]]
<space/></arg><arg name="volume"><space/>20
<space/></arg><arg name="number"><space/>4 
</arg></template></extension><space/>However, after more than 17,000 pounds of the British government's money, the thousands of cogged wheels and gears never fully worked together.<extension extension_name='ref' name="sco-ch1-p15"><template><target>cite book</target><arg name="last"><space/>Tanenbaum
<space/></arg><arg name="first"><space/>Andrew S.
<space/></arg><arg name="title"><space/>Structured Computer Organization, Third Edition
<space/></arg><arg name="publisher"><space/>Prentice Hall
<space/></arg><arg name="year"><space/>1990
<space/></arg><arg name="page"><space/>15
<space/></arg><arg name="isbn"><space/>0-13-854662-2
</arg></template></extension></paragraph><paragraph>During a nine-month period in 184243,<space/><link><target>Ada Lovelace</target></link><space/>translated the memoir of Italian mathematician<space/><link><target>Luigi Menabrea</target></link>. The memoir covered the Analytical Engine. The translation contained Note G which completely detailed a method for calculating<space/><link><target>Bernoulli number</target><trail>s</trail></link><space/>using the Analytical Engine. This note is recognized by some historians as the world's first written computer program.<extension extension_name='ref'><template><target>citation</target><arg name="author"><space/>J. Fuegi and J. Francis</arg><arg name="title"><space/>Lovelace & Babbage and the creation of the 1843 'notes'</arg><arg name="journal"><space/>Annals of the History of Computing</arg><arg name="volume"><space/>25</arg><arg name="issue"><space/>4</arg><arg name="date">October–December 2003</arg><arg name="doi"><space/>10.1109/MAHC.2003.1253887</arg><arg name="pages"><space/>16, 19, 25</arg></template></extension></paragraph><heading level='3'>Universal Turing machine</heading><paragraph>In 1936,<space/><link><target>Alan Turing</target></link><space/>introduced the<space/><link><target>Universal Turing machine</target></link>a theoretical device that can model every computation that can be performed on a<space/><link><target>Turing complete</target></link><space/>computing machine.<extension extension_name='ref' name="discrete-ch10-p654"><template><target>cite book</target><arg name="last"><space/>Rosen
<space/></arg><arg name="first"><space/>Kenneth H.
<space/></arg><arg name="title"><space/>Discrete Mathematics and Its Applications
<space/></arg><arg name="publisher"><space/>McGraw-Hill, Inc.
<space/></arg><arg name="year"><space/>1991
<space/></arg><arg name="page"><space/>654
<space/></arg><arg name="isbn"><space/>0-07-053744-5
</arg></template></extension>It is a<space/><link><target>finite-state machine</target></link><space/>that has an infinitely long read/write tape. The machine can move the tape back and forth, changing its contents as it performs an<space/><link><target>algorithm</target></link>. The machine starts in the initial state, goes through a sequence of steps, and halts when it encounters the halt state.<extension extension_name='ref' name="formal_languages-ch9-p234"><template><target>cite book</target><arg name="last"><space/>Linz
<space/></arg><arg name="first"><space/>Peter
<space/></arg><arg name="title"><space/>An Introduction to Formal Languages and Automata
<space/></arg><arg name="publisher"><space/>D. C. Heath and Company
<space/></arg><arg name="year"><space/>1990
<space/></arg><arg name="page"><space/>234
<space/></arg><arg name="isbn"><space/>0-669-17342-8
</arg></template></extension>This machine is considered by some to be the origin of the<space/><link><target>stored-program computer</target></link>used by<space/><link><target>John von Neumann</target></link><space/>(1946) for the &quot;Electronic Computing Instrument&quot; that now bears the<space/><link><target>von Neumann architecture</target></link><space/>name.<extension extension_name='ref'><template><target>Citation</target><arg name="first"><space/>Martin<space/></arg><arg name="last"><space/>Davis<space/></arg><arg name="author-link"><space/>Martin Davis
<space/></arg><arg name="title"><space/>Engines of Logic: Mathematicians and the origin of the Computer
<space/></arg><arg name="edition"><space/>1st
<space/></arg><arg name="year"><space/>2000
<space/></arg><arg name="place"><space/>New York NY
<space/></arg><arg name="publisher"><space/>W. W. Norton & Company
<space/></arg><arg name="id"><space/>(pb.)
<space/></arg><arg name="isbn"><space/>0-393-32229-7</arg></template></extension></paragraph><heading level='3'>Early programmable computers</heading><paragraph>The<space/><link><target>Z3 (computer)</target><part>Z3 computer</part></link>, invented by<space/><link><target>Konrad Zuse</target></link><space/>(1941) in<space/><link><target>Germany</target></link>, was a digital and programmable computer.<extension extension_name='ref' name="hoc-zuse"><template><target>cite web</target><arg name="url"><space/>http://history-computer.com/ModernComputer/Relays/Zuse.html
<space/></arg><arg name="title"><space/>History of Computing
</arg></template></extension><space/>A digital computer uses electricity as the calculating component. The Z3 contained 2,400 relays to create the<space/><link><target>Electronic circuit</target><part>circuits</part></link>. The circuits provided a<space/><link><target>Binary code</target><part>binary</part></link>,<space/><link><target>floating-point</target></link>, nine-instruction computer. Programming the Z3 was through a specially designed keyboard and<space/><link><target>punched tape</target></link>.</paragraph><paragraph>The<space/><link><target>ENIAC</target><part>Electronic Numerical Integrator And Computer</part></link><space/>(Fall 1945) was a<space/><link><target>Turing complete</target></link>, general-purpose computer that used 17,468<space/><link><target>vacuum tube</target><trail>s</trail></link><space/>to create the<space/><link><target>Electronic circuit</target><part>circuits</part></link>. At its core, it was a series of<space/><link><target>Pascaline</target><trail>s</trail></link><space/>wired together.<extension extension_name='ref' name="eniac-ch5-p102"><template><target>cite book</target><arg name="last"><space/>McCartney
<space/></arg><arg name="first"><space/>Scott
<space/></arg><arg name="title"><space/>ENIAC – The Triumphs and Tragedies of the World's First Computer
<space/></arg><arg name="publisher"><space/>Walker and Company
<space/></arg><arg name="year"><space/>1999
<space/></arg><arg name="page"><space/>102
<space/></arg><arg name="isbn"><space/>0-8027-1348-3
</arg></template></extension><space/>Its 40 units weighed 30 tons, occupied 1,800 square feet, and consumed $650 per hour (<link><target>Inflation</target><part>in 1940s currency</part></link>) in electricity when idle.<extension extension_name='ref' name="eniac-ch5-p102"></extension><space/>It had 20<space/><link><target>base-10</target></link><space/><link><target>Accumulator (computing)</target><part>accumulators</part></link>. Programming the ENIAC took up to two months.<extension extension_name='ref' name="eniac-ch5-p102"></extension><space/>Three function tables were on wheels and needed to be rolled to fixed function panels. Function tables were connected to function panels using heavy black cables. Each function table had 728 rotating knobs. Programming the ENIAC also involved setting some of the 3,000 switches. Debugging a program took a week.<extension extension_name='ref' name="eniac-ch5-p102"></extension><space/>The ENIAC featured<space/><link><target>Parallel computing</target><part>parallel operations</part></link>. Different sets of accumulators could simultaneously work on different algorithms. It used<space/><link><target>Punched card</target><part>punched card machines</part></link><space/>for input and output, and it was controlled with a<space/><link><target>clock signal</target></link>. It ran for eight years, calculating hydrogen bomb parameters, predicting weather patterns, and producing firing tables to aim artillery guns.</paragraph><paragraph>The<space/><link><target>Manchester Small-Scale Experimental Machine</target></link><space/>(June 1948) was a<space/><link><target>stored-program computer</target></link>.<extension extension_name='ref'><template><target>citation</target><arg name="last">Enticknap<space/></arg><arg name="first">Nicholas<space/></arg><arg name="title">Computing's Golden Jubilee<space/></arg><arg name="journal">Resurrection<space/></arg><arg name="issue">20<space/></arg><arg name="publisher">The Computer Conservation Society<space/></arg><arg name="date">Summer 1998<space/></arg><arg name="url">http://www.cs.man.ac.uk/CCS/res/res20.htm#d<space/></arg><arg name="issn">0958-7403<space/></arg><arg name="accessdate">19 April 2008</arg></template></extension><space/>Programming transitioned away from moving cables and setting dials; instead, a computer program was stored in memory as numbers. Only three<space/><link><target>bit</target><trail>s</trail></link><space/>of memory were available to store each instruction, so it was limited to eight instructions. 32 switches were available for programming.</paragraph><heading level='3'>Later computers</heading><paragraph><link><target>File:Dg-nova3.jpg</target><part>thumb</part><part>right</part><part>Switches for manual input on a<space/><link><target>Data General Nova</target></link><space/>3, manufactured in the mid 1970s</part></link>Computers manufactured until the 1970s had front-panel switches for programming. The computer program was written on paper for reference. An instruction was represented by a configuration of on/off settings. After setting the configuration, an execute button was pressed. This process was then repeated. Computer programs also were manually input via<space/><link><target>paper tape</target></link><space/>or<space/><link><target>punched cards</target></link>. After the medium was loaded, the starting address was set via switches and the execute button pressed.<extension extension_name='ref' name="osc-ch1-p6"><template><target>cite book</target><arg name="last"><space/>Silberschatz
<space/></arg><arg name="first"><space/>Abraham
<space/></arg><arg name="title"><space/>Operating System Concepts, Fourth Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1994
<space/></arg><arg name="page"><space/>6
<space/></arg><arg name="isbn"><space/>0-201-50480-4
</arg></template></extension></paragraph><paragraph>In 1961, the<space/><link><target>Burroughs large systems#B5000</target><part>Burroughs B5000</part></link><space/>was built specifically to be programmed in the<space/><link><target>ALGOL 60</target></link><space/>language. The hardware featured circuits to ease the<space/><link><target>compiler</target><part>compile</part></link><space/>phase.<extension extension_name='ref' name="sco-ch1-p20"><template><target>cite book</target><arg name="last"><space/>Tanenbaum
<space/></arg><arg name="first"><space/>Andrew S.
<space/></arg><arg name="title"><space/>Structured Computer Organization, Third Edition
<space/></arg><arg name="publisher"><space/>Prentice Hall
<space/></arg><arg name="year"><space/>1990
<space/></arg><arg name="page"><space/>20
<space/></arg><arg name="isbn"><space/>0-13-854662-2
</arg></template></extension></paragraph><paragraph>In 1964, the<space/><link><target>IBM System/360</target></link><space/>was a line of six computers each having the same<space/><link><target>instruction set</target><part>instruction set architecture</part></link>. The Model 30 was the smallest and least expensive. Customers could upgrade and retain the same<space/><link><target>application software</target></link>.<extension extension_name='ref' name="sco-ch1-p21"><template><target>cite book</target><arg name="last"><space/>Tanenbaum
<space/></arg><arg name="first"><space/>Andrew S.
<space/></arg><arg name="title"><space/>Structured Computer Organization, Third Edition
<space/></arg><arg name="publisher"><space/>Prentice Hall
<space/></arg><arg name="year"><space/>1990
<space/></arg><arg name="page"><space/>21
<space/></arg><arg name="isbn"><space/>0-13-854662-2
</arg></template></extension><space/>Each System/360 model featured<space/><link><target>Computer multitasking#Multiprogramming</target><part>multiprogramming</part></link>. With operating system support, multiple programs could be in memory at once. When one was waiting for<space/><link><target>input/output</target></link>, another could compute. Each model also could<space/><link><target>emulator</target><part>emulate</part></link><space/>other computers. Customers could upgrade to the System/360 and retain their<space/><link><target>IBM 7090#IBM 7094</target><part>IBM 7094</part></link><space/>or<space/><link><target>IBM 1401</target></link><space/>application software.<extension extension_name='ref' name="sco-ch1-p21"></extension></paragraph><heading level='2'>Computer programming</heading><paragraph><template><target>Main</target><arg>Computer programming</arg></template></paragraph><paragraph><link><target>Computer programming</target></link><space/>is the process of writing or editing<space/><link><target>source code</target></link>. Editing source code involves testing, analyzing, refining, and sometimes coordinating with other programmers on a jointly developed program. A person who practices this skill is referred to as a computer<space/><link><target>programmer</target></link>, software developer, and sometimes coder.</paragraph><paragraph>The sometimes lengthy process of computer programming is usually referred to as<space/><link><target>software development</target></link>. The term<space/><link><target>software engineering</target></link><space/>is becoming popular as the process is seen as an<space/><link><target>engineering</target></link><space/>discipline.</paragraph><heading level='3'>Programming languages</heading><paragraph><template><target>main</target><arg>Programming language</arg></template><link><target>File:Object-Oriented-Programming-Methods-And-Classes-with-Inheritance.png</target><part>thumb</part><part>A computer program written in the imperative programming style</part></link></paragraph><paragraph>Computer programs can be categorized by the<space/><link><target>programming language</target></link><space/><link><target>programming paradigm</target><part>paradigm</part></link><space/>used to produce them. Two of the main paradigms are<space/><link><target>imperative programming</target><part>imperative</part></link><space/>and<space/><link><target>declarative language</target><part>declarative</part></link>.</paragraph><heading level='4'>Imperative languages</heading><paragraph><italics>Imperative programming languages</italics><space/>specify a sequential<space/><link><target>algorithm#Computer algorithm</target><part>algorithm</part></link><space/>using declarations, expressions, and statements:<extension extension_name='ref' name="cpl-ch4-75"><template><target>cite book</target><arg name="last"><space/>Wilson
<space/></arg><arg name="first"><space/>Leslie B.
<space/></arg><arg name="title"><space/>Comparative Programming Languages, Second Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1993
<space/></arg><arg name="page"><space/>75
<space/></arg><arg name="isbn"><space/>0-201-56885-3
</arg></template></extension></paragraph><list type='bullet'><listitem>A<space/><italics>declaration</italics><space/>couples a<space/><link><target>variable (programming)</target><part>variable</part></link><space/>name to a<space/><link><target>datatype</target></link><space/>for example:<space/><xhtml:code><preblock><preline>var x: integer;</preline></preblock></xhtml:code></listitem><listitem>An<space/><italics>expression</italics><space/>yields a value for example:<space/><xhtml:code><preblock><preline>2 + 2</preline></preblock></xhtml:code><space/>yields 4</listitem><listitem>A<space/><italics>statement</italics><space/>might assign an expression to a variable or use the value of a variable to alter the program's<space/><link><target>control flow</target></link><space/>for example:<space/><xhtml:code>x := 2 + 2; if x = 4 then do_something();</xhtml:code></listitem></list><paragraph>One criticism of imperative languages is the side effect of an assignment statement on a class of variables called non-local variables.<extension extension_name='ref' name="cpl-ch9-213"></extension></paragraph><heading level='4'>Declarative languages</heading><paragraph><italics>Declarative programming languages</italics><space/>describe<space/><italics>what</italics><space/>computation should be performed and not<space/><italics>how</italics><space/>to compute it. Declarative programs omit the<space/><link><target>control flow</target></link><space/>and are considered<space/><italics>sets</italics><space/>of instructions. Two broad categories of declarative languages are<space/><link><target>functional language</target><trail>s</trail></link><space/>and<space/><link><target>logical language</target><trail>s</trail></link>. The principle behind functional languages (like<space/><link><target>Haskell (programming language)</target><part>Haskell</part></link>) is to not allow<space/><link><target>side effect (computer science)</target><part>side effects</part></link>, which makes it easier to reason about programs like mathematical functions.<extension extension_name='ref' name="cpl-ch9-213"><template><target>cite book</target><arg name="last"><space/>Wilson
<space/></arg><arg name="first"><space/>Leslie B.
<space/></arg><arg name="title"><space/>Comparative Programming Languages, Second Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1993
<space/></arg><arg name="page"><space/>213
<space/></arg><arg name="isbn"><space/>0-201-56885-3
</arg></template></extension><space/>The principle behind logical languages (like<space/><link><target>Prolog</target></link>) is to define the problem to be solved&amp;nbsp; the goal&amp;nbsp; and leave the detailed solution to the Prolog system itself.<extension extension_name='ref' name="cpl-ch10-244"><template><target>cite book</target><arg name="last"><space/>Wilson
<space/></arg><arg name="first"><space/>Leslie B.
<space/></arg><arg name="title"><space/>Comparative Programming Languages, Second Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1993
<space/></arg><arg name="page"><space/>244
<space/></arg><arg name="isbn"><space/>0-201-56885-3
</arg></template></extension><space/>The goal is defined by providing a list of subgoals. Then each subgoal is defined by further providing a list of its subgoals, etc. If a path of subgoals fails to find a solution, then that subgoal is<space/><link><target>backtracking</target><part>backtracked</part></link><space/>and another path is systematically attempted.</paragraph><heading level='3'>Compilation and interpretation</heading><paragraph>A computer program in the form of a<space/><link><target>human-readable</target></link>, computer programming language is called<space/><link><target>source code</target></link>. Source code may be converted into an<space/><link><target>Executable file</target><part>executable image</part></link><space/>by a<space/><link><target>compiler</target></link><space/>or<space/><link><target>execution (computing)</target><part>executed</part></link><space/>immediately with the aid of an<space/><link><target>Interpreter (computing)</target><part>interpreter</part></link>.</paragraph><paragraph>Compilers are used to translate source code from a programming language into either<space/><link><target>Object file</target><part>object code</part></link><space/>or<space/><link><target>machine code</target></link>.<extension extension_name='ref'><template><target>cite web</target><arg name="title">What is a Compiler?</arg><arg name="url">http://lambda.uta.edu/cse5317/notes/node3.html</arg><arg name="accessdate">2012-01-10</arg></template></extension><space/>Object code needs further processing to become machine code, and machine code consists of the<space/><link><target>central processing unit</target><part>central processing unit's</part></link><space/>native instructions, ready for execution. Compiled computer programs are commonly referred to as executables, binary images, or simply as<space/><link><target>Binary file</target><part>binaries</part></link>&amp;nbsp; a reference to the<space/><link><target>Binary numeral system</target><part>binary</part></link><space/><link><target>file format</target></link><space/>used to store the executable code.</paragraph><paragraph>Interpreters are used to execute source code from a programming language immediately, without an intermediate file. The interpreter<space/><link><target>Parsing</target><part>decodes</part></link><space/>each<space/><link><target>Statement (computer science)</target><part>statement</part></link><space/>and performs its behavior. One advantage of interpreters is the ability to generate an<space/><link><target>Session (computer science)</target><part>interactive session</part></link>. The programmer is presented with a prompt, and individual lines of code are typed in and performed immediately.</paragraph><paragraph>The main disadvantage of interpreters is computer programs run slower than when compiled. Interpreting code is slower because the interpreter must decode each statement and then perform it. However, software development may be faster using an interpreter because testing is immediate when the compiling step is omitted. Another disadvantage of interpreters is an interpreter must be present on the executing computer. By contrast, compiled computer programs need no compiler present during execution.</paragraph><paragraph><link><target>just-in-time compilation</target><part>Just in time compilers</part></link><space/>pre-compile computer programs ahead of time and interpret them later. For example,<space/><link><target>Java (programming language)</target><part>Java</part></link><space/>computer programs are pre-compiled into a file containing<space/><link><target>bytecode</target></link>. Bytecode is then executed by an interpreter called a<space/><link><target>virtual machine#Process virtual machines</target><part>virtual machine</part></link>.</paragraph><paragraph>Either compiled or interpreted programs might be executed in a<space/><link><target>batch processing</target><part>batch process</part></link><space/>without human interaction. Batch programming languages are called<space/><link><target>scripting language</target><trail>s</trail></link>. One common scripting language is<space/><link><target>Unix shell</target></link>, and its executing environment is called the<space/><link><target>command-line interface</target></link>.</paragraph><paragraph>No properties of a programming language require it to be exclusively compiled or exclusively interpreted. The categorization usually reflects the most popular method of language execution. For example, BASIC is thought of as an interpreted language and C a compiled language, despite the existence of BASIC compilers and C interpreters.</paragraph><heading level='2'>Storage and execution</heading><paragraph><link><target>File:Papertape3.jpg</target><part>thumb</part><part>In the 1950s, computer programs were stored on<space/><link><target>Punched tape</target><part>perforated paper tape</part></link></part></link></paragraph><paragraph>Typically, computer programs are stored in<space/><link><target>non-volatile memory</target></link><space/>until requested either directly or indirectly to be<space/><link><target>execution (computing)</target><part>executed</part></link><space/>by the computer user. Upon such a request, the program is loaded into<space/><link><target>random access memory</target></link>, by a computer program called an<space/><link><target>operating system</target></link>, where it can be accessed directly by the central processor. The central processor then executes (&quot;runs&quot;) the program, instruction by instruction, until termination. A program in execution is called a<space/><link><target>process (computing)</target><part>process</part></link>.<extension extension_name='ref' name="osc-ch4-97"><template><target>cite book</target><arg name="last"><space/>Silberschatz
<space/></arg><arg name="first"><space/>Abraham
<space/></arg><arg name="title"><space/>Operating System Concepts, Fourth Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1994
<space/></arg><arg name="page"><space/>97
<space/></arg><arg name="isbn"><space/>0-201-50480-4
</arg></template></extension><space/>Termination is either by normal self-termination or by error&amp;nbsp; software or hardware error.</paragraph><heading level='3'>Simultaneous execution</heading><paragraph><template><target>See also</target><arg>Process (computing)</arg><arg>Multiprocessing</arg></template></paragraph><paragraph>Many operating systems support<space/><link><target>computer multitasking</target><part>multitasking</part></link><space/>which enables many computer programs to appear to run simultaneously on one computer. Operating systems may run multiple programs through<space/><link><target>process scheduling</target></link>&amp;nbsp; a software mechanism to<space/><link><target>context switch</target><part>switch</part></link><space/>the CPU among processes often so users can<space/><link><target>time-sharing</target><part>interact</part></link><space/>with each program while it runs.<extension extension_name='ref' name="osc-ch4-100"><template><target>cite book</target><arg name="last"><space/>Silberschatz
<space/></arg><arg name="first"><space/>Abraham
<space/></arg><arg name="title"><space/>Operating System Concepts, Fourth Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1994
<space/></arg><arg name="page"><space/>100
<space/></arg><arg name="isbn"><space/>0-201-50480-4
</arg></template></extension><space/>Within hardware, modern day multiprocessor computers or computers with multicore processors may run multiple programs.<extension extension_name='ref' name="mcore"><template><target>cite book</target><arg name="last"><space/>Akhter
<space/></arg><arg name="first"><space/>Shameem
<space/></arg><arg name="title"><space/>Multi-Core Programming
<space/></arg><arg name="publisher"><space/>Richard Bowles (Intel Press)
<space/></arg><arg name="year"><space/>2006
<space/></arg><arg name="pages"><space/>11–13
<space/></arg><arg name="isbn"><space/>0-9764832-4-6
</arg></template></extension></paragraph><paragraph>Multiple lines of the same computer program may be simultaneously executed using<space/><link><target>thread (computer science)</target><part>threads</part></link>.<space/><link><target>Multithreading (computer architecture)</target><part>Multithreading</part></link><space/>processors are optimized to execute multiple threads efficiently.</paragraph><heading level='3'>Self-modifying programs</heading><paragraph><template><target>Main</target><arg>Self-modifying code</arg></template></paragraph><paragraph>A computer program in<space/><link><target>execution (computing)</target><part>execution</part></link><space/>is normally treated as being different from the<space/><link><target>Data (computing)</target><part>data</part></link><space/>the program operates on. However, in some cases, this distinction is blurred when a computer program modifies itself. The modified computer program is subsequently executed as part of the same program.<space/><link><target>Self-modifying code</target></link><space/>is possible for programs written in<space/><link><target>machine code</target></link>,<space/><link><target>assembly language</target></link>,<space/><link><target>Lisp (programming language)</target><part>Lisp</part></link>,<space/><link><target>C (programming language)</target><part>C</part></link>,<space/><link><target>COBOL</target></link>,<space/><link><target>PL/1</target></link>, and<space/><link><target>Prolog</target></link>.</paragraph><heading level='2'>Functional categories</heading><paragraph>Computer programs may be categorized along functional lines. The main functional categories are<space/><link><target>application software</target></link><space/>and<space/><link><target>system software</target></link>. System software includes the<space/><link><target>operating system</target></link><space/>which couples<space/><link><target>computer hardware</target></link><space/>with application software.<extension extension_name='ref' name="osc-overview"></extension><space/>The purpose of the operating system is to provide an environment in which application software executes in a convenient and efficient manner.<extension extension_name='ref' name="osc-overview"><template><target>cite book</target><arg name="last"><space/>Silberschatz
<space/></arg><arg name="first"><space/>Abraham
<space/></arg><arg name="title"><space/>Operating System Concepts, Fourth Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1994
<space/></arg><arg name="page"><space/>1
<space/></arg><arg name="isbn"><space/>0-201-50480-4
</arg></template></extension><space/>In addition to the operating system, system software includes<space/><link><target>Firmware</target><part>embedded programs</part></link>,<space/><link><target>Booting</target><part>boot programs</part></link>, and<space/><link><target>Microcode</target><part>micro programs</part></link>. Application software designed for<space/><link><target>end user</target><trail>s</trail></link><space/>have a<space/><link><target>Interface (computing)</target><part>user interface</part></link>. Application software not designed for the end user includes<space/><link><target>middleware</target></link>, which couples one application with another. Application software also includes<space/><link><target>Utility software</target><part>utility programs</part></link>. The distinction between system software and application software is under debate.</paragraph><heading level='3'>Application software</heading><paragraph><template><target>Main</target><arg>Application software</arg></template><link><target>File:Gcalctool-scientific.png</target><part>thumb</part><part>Example of an app:<space/><link><target>GCalctool</target></link>, a software calculator</part></link></paragraph><paragraph>There are many types of application software:</paragraph><list type='bullet'><listitem>The word<space/><bold>app</bold><space/>came to being in 21st century. It is a<space/><link><target>Clipping (morphology)</target><part>clipping</part></link><space/>of the word &quot;application&quot;. They have been designed for many platforms, but the word was first used for smaller mobile apps. Desktop apps are traditional computer programs that run on<space/><link><target>desktop computer</target><trail>s</trail></link>.<space/><link><target>Mobile app</target><trail>s</trail></link><space/>run on<space/><link><target>mobile device</target><trail>s</trail></link>.<space/><link><target>Web app</target><trail>s</trail></link><space/>run inside a<space/><link><target>web browser</target></link>. Both mobile and desktop apps may be purchased from<space/><link><target>app store</target><trail>s</trail></link><space/>such as<space/><link><target>Windows Store</target></link>,<space/><link><target>Apple App Store</target></link>,<space/><link><target>Mac App Store</target></link>,<space/><link><target>Google Play</target></link><space/>or<space/><link><target>Intel AppUp</target></link>.</listitem><listitem>An<space/><bold><link><target>application suite</target></link></bold><space/>consists of multiple applications bundled together. Examples include<space/><link><target>Microsoft Office</target></link>,<space/><link><target>LibreOffice</target></link><space/>and<space/><link><target>iWork</target></link>. They bundle a word processor, spreadsheet, and other applications.</listitem><listitem><bold><link><target>Enterprise software</target><part>Enterprise applications</part></link></bold><space/>bundle accounting, personnel, customer, and vendor applications. Examples include<space/><link><target>enterprise resource planning</target></link>,<space/><link><target>customer relationship management</target></link>, and<space/><link><target>supply chain management software</target></link>.</listitem><listitem><bold>Enterprise infrastructure software</bold><space/>supports the enterprise's<space/><link><target>software systems</target></link>. Examples include databases, email servers, and network servers.</listitem><listitem><bold><link><target>Information worker</target></link><space/>software</bold><space/>are designed for workers at the departmental level. Examples include<space/><link><target>time management</target></link>,<space/><link><target>schedule (workplace)</target><part>resource management</part></link>, analytical, collaborative and documentation tools. Word processors, spreadsheets, email and blog clients, personal information system, and individual media editors may aid in multiple information worker tasks.</listitem><listitem><bold>Media development software</bold><space/>generates print and electronic media for others to consume, most often in a commercial or educational setting. These produce graphics, publications, animations, and videos.</listitem><listitem><bold>Product engineering software</bold><space/>is used to help develop large machines and other application software. Examples includes<space/><link><target>computer-aided design</target></link><space/>(CAD),<space/><link><target>computer-aided engineering</target></link><space/>(CAE), and<space/><link><target>integrated development environment</target><trail>s</trail></link>.</listitem><listitem><bold>Entertainment Software</bold><space/>can refer to video games, movie recorders and players, and music recorders and players.</listitem></list><heading level='3'>Utility programs</heading><paragraph><link><target>Utility software</target><part>Utility programs</part></link><space/>are application programs designed to aid<space/><link><target>system administrator</target><trail>s</trail></link><space/>and<space/><link><target>computer programmer</target><trail>s</trail></link>.</paragraph><heading level='3'>Operating system</heading><paragraph><template><target>See also</target><arg>Operating system</arg></template></paragraph><paragraph>An<space/><link><target>operating system</target></link><space/>is a computer program that acts as an intermediary between a user of a computer and the computer hardware.<extension extension_name='ref' name="osc-overview"></extension></paragraph><paragraph>In the 1950s, the programmer, who was also the operator, would write a program and run it.<extension extension_name='ref' name="osc-ch1-p6"></extension>After the program finished executing, the output may have been printed, or it may have been punched onto paper tape or cards for later processing.<extension extension_name='ref' name="osc-ch1-p6"></extension>More often than not the program did not work.<extension extension_name='ref' name="sco-ch1-p11"><template><target>cite book</target><arg name="last"><space/>Tanenbaum
<space/></arg><arg name="first"><space/>Andrew S.
<space/></arg><arg name="title"><space/>Structured Computer Organization, Third Edition
<space/></arg><arg name="publisher"><space/>Prentice Hall
<space/></arg><arg name="year"><space/>1990
<space/></arg><arg name="page"><space/>11
<space/></arg><arg name="isbn"><space/>0-13-854662-2
</arg></template></extension>The programmer then looked at the console lights and fiddled with the console switches. If less fortunate, a memory printout was made for further study.<extension extension_name='ref' name="sco-ch1-p11"></extension>In the 1960s, programmers reduced the amount of wasted time by automating the operator's job.<extension extension_name='ref' name="sco-ch1-p11"></extension><space/>A program called an<space/><italics>operating system</italics><space/>was kept in the computer at all times.<extension extension_name='ref' name="sco-ch1-p11"></extension></paragraph><paragraph>Originally, operating systems were programmed in<space/><link><target>assembly language</target><part>assembly</part></link>; however, modern operating systems are typically written in<space/><link><target>C (programming language)</target><part>C</part></link>.</paragraph><heading level='3'>Boot program</heading><paragraph>A<space/><link><target>stored-program computer</target></link><space/>requires an initial computer program stored in its<space/><link><target>read-only memory</target></link><space/>to<space/><link><target>booting</target><part>boot</part></link>. The boot process is to identify and initialize all aspects of the system, from<space/><link><target>processor register</target><trail>s</trail></link><space/>to<space/><link><target>device driver</target><part>device controllers</part></link><space/>to<space/><link><target>volatile memory</target><part>memory</part></link><space/>contents.<extension extension_name='ref' name="osc-ch2-p30"><template><target>cite book</target><arg name="last"><space/>Silberschatz
<space/></arg><arg name="first"><space/>Abraham
<space/></arg><arg name="title"><space/>Operating System Concepts, Fourth Edition
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="year"><space/>1994
<space/></arg><arg name="page"><space/>30
<space/></arg><arg name="isbn"><space/>0-201-50480-4
</arg></template></extension><space/>Following the initialization process, this initial computer program loads the<space/><link><target>operating system</target></link><space/>and sets the<space/><link><target>program counter</target></link><space/>to begin normal operations.</paragraph><heading level='3'>Embedded programs</heading><paragraph><link><target>File:USB flash drive.JPG</target><part>thumb</part><part>230px</part><part>right</part><part>The<space/><link><target>microcontroller</target></link><space/>on the right of this<space/><link><target>USB flash drive</target></link><space/>is controlled with embedded<space/><link><target>firmware</target></link>.</part></link></paragraph><paragraph>Independent of the host computer, a<space/><link><target>Peripheral</target><part>hardware device</part></link><space/>might have embedded<space/><link><target>firmware</target></link><space/>to control its operation. Firmware is used when the computer program is rarely or never expected to change, or when the program must not be lost when the power is off.<extension extension_name='ref' name="sco-ch1-p11"></extension></paragraph><heading level='3'>Microcode programs</heading><paragraph><template><target>main</target><arg>Microcode</arg></template></paragraph><paragraph><link><target>Microcode</target></link><space/>programs control some<space/><link><target>central processing unit</target><trail>s</trail></link><space/>and some other hardware. This code moves data between the<space/><link><target>Processor register</target><part>registers</part></link>,<space/><link><target>Bus (computing)</target><part>buses</part></link>,<space/><link><target>Arithmetic Logic Unit</target><part>arithmetic logic unit</part><trail>s</trail></link>, and other functional units in the CPU. Unlike conventional programs, microcode is not usually written by, or even visible to, the end users of systems, and is usually provided by the manufacturer, and is considered internal to the device.</paragraph><heading level='2'>See also</heading><list type='bullet'><listitem><link><target>Automatic programming</target></link></listitem><listitem><link><target>Killer application</target></link></listitem><listitem><link><target>Software bug</target></link></listitem></list><heading level='2'>References</heading><paragraph><template><target>reflist</target><arg>30em</arg></template></paragraph><heading level='2'>Further reading</heading><list type='bullet'><listitem><template><target>cite book</target><arg name="last"><space/>Knuth
<space/></arg><arg name="first"><space/>Donald E.
<space/></arg><arg name="title"><space/>[[The Art of Computer Programming]], Volume 1, 3rd Edition
<space/></arg><arg name="year"><space/>1997
<space/></arg><arg name="publisher"><space/>Addison-Wesley
<space/></arg><arg name="location"><space/>Boston
<space/></arg><arg name="isbn"><space/>0-201-89683-4
</arg></template></listitem><listitem><template><target>cite book</target><arg name="last">Knuth
<space/></arg><arg name="first">Donald E.
<space/></arg><arg name="title">The Art of Computer Programming, Volume 2, 3rd Edition
<space/></arg><arg name="year">1997
<space/></arg><arg name="publisher">Addison-Wesley
<space/></arg><arg name="location"><space/>Boston
<space/></arg><arg name="isbn">0-201-89684-2
</arg></template></listitem><listitem><template><target>cite book</target><arg name="last">Knuth
<space/></arg><arg name="first">Donald E.
<space/></arg><arg name="title">The Art of Computer Programming, Volume 3, 3rd Edition
<space/></arg><arg name="year">1997
<space/></arg><arg name="publisher">Addison-Wesley
<space/></arg><arg name="location"><space/>Boston
<space/></arg><arg name="isbn">0-201-89685-0
</arg></template></listitem></list><paragraph><template><target>Authority control</target></template></paragraph><paragraph><template><target>DEFAULTSORT:Computer Program</target></template><link><target>Category:Computer programming</target></link><link><target>Category:Articles with example Java code</target></link><link><target>Category:Articles with example C code</target></link><link><target>Category:Articles with example C Sharp code</target></link><link><target>Category:Software</target></link></paragraph></article>